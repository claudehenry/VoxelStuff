{"name":"Camera3D.java","path":"src/com/ch/Camera3D.java","content":{"structured":{"description":"A 3D camera class `Camera3D` that inherits from the `Camera` class. The `Camera3D` class has several methods for calculating and manipulating the camera's projection matrix, viewport size, and position. The code also defines a `processInput` method that handles keyboard and mouse input, moving the camera based on user input. The code uses the `GL11` class for handling OpenGL rendering.","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera3D.CameraStruct3D Pages: 1 -->\n<svg width=\"198pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 198.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera3D.CameraStruct3D</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"190,-19 0,-19 0,0 190,0 190,-19\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D.CameraStruct3D</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera_1_1CameraStruct.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"176.5,-74 13.5,-74 13.5,-55 176.5,-55 176.5,-74\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera.CameraStruct</text>\n</a>\n</g>\n</g>\n<!-- Node2&#45;&gt;Node1 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node2&#45;&gt;Node1</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M95,-44.66C95,-35.93 95,-25.99 95,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"91.5,-44.75 95,-54.75 98.5,-44.75 91.5,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","items":[{"id":"bb2de2ea-2c20-c2a0-3545-4d2d0f4d8fd9","ancestors":[],"type":"function","description":"is a subclass of the Camera class that extends the basic camera functionality with additional features such as adjusting to the viewport size and processing input from the mouse and keyboard. The class includes a protected inner class called CameraStruct3D which contains the camera's intrinsic parameters and provides methods for calculating the projection matrix and rotating the camera's position and orientation.","name":"Camera3D","code":"public class Camera3D extends Camera {\n\n\tpublic Camera3D(float fov, float aspect, float zNear, float zFar) {\n\t\tsuper(new Matrix4f());\n\t\tthis.values = new CameraStruct3D(fov, aspect, zNear, zFar);\n\t\tcalculateProjectionMatrix(values);\n\t}\n\n\t@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}\n\n\t@Override\n\tpublic void adjustToViewport(int width, int height) {\n\t\t((CameraStruct3D) this.values).aspect = (float) width / height;\n\t\tcalculateProjectionMatrix(values);\n\t\ttry {\n\t\t\tcalculateViewMatrix();\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tGL11.glViewport(0, 0, width, height);\n\t}\n\n\tprotected class CameraStruct3D extends CameraStruct {\n\n\t\tpublic float fov, aspect, zNear, zFar;\n\n\t\tpublic CameraStruct3D(float fov, float aspect, float zNear, float zFar) {\n\t\t\tthis.fov = fov;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.zNear = zNear;\n\t\t\tthis.zFar = zFar;\n\t\t}\n\n\t\tpublic Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}\n\n\t}\n\n\tpublic void processInput(float dt, float speed, float sens) {\n\n\t\tfloat dx = Mouse.getDX();\n\t\tfloat dy = Mouse.getDY();\n\t\tfloat roty = (float)Math.toRadians(dx * sens);\n\t\tgetTransform().rotate(new Vector3f(0, 1, 0), (float) roty);\n\t\tgetTransform().rotate(getTransform().getRot().getRight(), (float) -Math.toRadians(dy * sens));\n\t\t\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))\n\t\t\tspeed *= 10;\n\t\t\n\t\tfloat movAmt = speed * dt;\n\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_W))\n\t\t\tmove(getTransform().getRot().getForward(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_S))\n\t\t\tmove(getTransform().getRot().getForward(), -movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_A))\n\t\t\tmove(getTransform().getRot().getLeft(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_D))\n\t\t\tmove(getTransform().getRot().getRight(), movAmt);\n\t\t\n\t}\n\n\tprivate void move(Vector3f dir, float amt) {\n\t\tgetTransform().setPos(getTransform().getPos().add(dir.mul(amt)));\n\t}\n\n}","location":{"start":10,"insert":10,"offset":" ","indent":0,"comment":null},"item_type":"class","length":70},{"id":"5176f4ad-6ef5-d1bc-4c45-b026564ed039","ancestors":["bb2de2ea-2c20-c2a0-3545-4d2d0f4d8fd9"],"type":"function","description":"calculates a matrix representing the projection of a 3D scene from a given camera's perspective.","params":[{"name":"data","type_name":"CameraStruct","description":"3D camera's projection matrix, which is used to calculate the final projection matrix returned by the function.\n\n* `getAsMatrix4()` is a method that returns the `Matrix4f` representation of the input data.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a Matrix4f object containing the projection matrix as specified by the provided `CameraStruct` data.\n\nThe `Matrix4f` object returned by the function represents a 4D projection matrix that is used to transform 3D points and vectors into screen space. It consists of four rows and four columns, with each element representing a value in the range [0, 1]. The matrix elements are manipulated using standard matrix operations, such as addition, multiplication by a scalar, and multiplication by another matrix.\n\nThe returned matrix is a direct result of the `projection` variable assigned to it, which is a `CameraStruct` object containing parameters defining the desired projection transformation, such as the field of view, aspect ratio, and near and far clipping planes.","complex_type":true},"usage":{"language":"java","code":"CameraStruct data = new CameraStruct(45, 16/9, 0.1, 100);\nMatrix4f projectionMatrix = camera.calculateProjectionMatrix(data);\n","description":"\nThis example creates a new instance of the CameraStruct class with the following values: 45 for fov, 16/9 for aspect, 0.1 for zNear, and 100 for zFar. These values are then passed to the calculateProjectionMatrix method, which returns a projection matrix based on these values. The resulting projection matrix can then be used in conjunction with other camera methods like render or adjustToViewport."},"name":"calculateProjectionMatrix","code":"@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}","location":{"start":18,"insert":18,"offset":" ","indent":1,"comment":null},"item_type":"method","length":4},{"id":"116868da-4576-2797-8941-e31be911140d","ancestors":["bb2de2ea-2c20-c2a0-3545-4d2d0f4d8fd9"],"type":"function","description":"adjusts the camera's projection matrix and view matrix to fit within the bounds of a specified size window, while maintaining the aspect ratio of the camera's image.","params":[{"name":"width","type_name":"int","description":"2D viewport width of the current rendering context.","complex_type":false},{"name":"height","type_name":"int","description":"2D viewport size of the renderer's window, which is used to calculate the perspective projection matrix and view matrix.","complex_type":false}],"usage":{"language":"java","code":"@Override\n\tpublic void adjustToViewport(int width, int height) {\n\t\t((CameraStruct3D) this.values).aspect = (float) width / height;\n\t\tcalculateProjectionMatrix(values);\n\t\ttry {\n\t\t\tcalculateViewMatrix();\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tGL11.glViewport(0, 0, width, height);\n\t}\n","description":"\nIn the above example, the method adjustToViewport takes in two integers as inputs, the width and height of a viewport respectively. The code then accesses the aspect ratio value within the camera struct object through its values attribute, which has been cast to a CameraStruct3D object using typecasting. It updates the aspect ratio value with the value calculated from the width and height input values, before calling calculateProjectionMatrix() method on the current object's values.\n\nThe code then tries to call the calculateViewMatrix() method on the current object's values but catches a NullPointerException in case it throws one, which is handled by doing nothing as the exception was not expected. The GL11 class is called and its glViewport() method is called with the width and height of the viewport as inputs, resulting in the camera being updated to reflect the new viewport dimensions."},"name":"adjustToViewport","code":"@Override\n\tpublic void adjustToViewport(int width, int height) {\n\t\t((CameraStruct3D) this.values).aspect = (float) width / height;\n\t\tcalculateProjectionMatrix(values);\n\t\ttry {\n\t\t\tcalculateViewMatrix();\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tGL11.glViewport(0, 0, width, height);\n\t}","location":{"start":23,"insert":23,"offset":" ","indent":1,"comment":null},"item_type":"method","length":10},{"id":"2c1145c3-61d0-3299-734d-27973c438927","ancestors":["bb2de2ea-2c20-c2a0-3545-4d2d0f4d8fd9"],"type":"function","description":"is a subclass of the CameraStruct class, which represents a 3D camera in a mathematical format. The class has several fields and methods that allow for manipulation of the camera's position, orientation, and perspective projection matrix.","name":"CameraStruct3D","code":"protected class CameraStruct3D extends CameraStruct {\n\n\t\tpublic float fov, aspect, zNear, zFar;\n\n\t\tpublic CameraStruct3D(float fov, float aspect, float zNear, float zFar) {\n\t\t\tthis.fov = fov;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.zNear = zNear;\n\t\t\tthis.zFar = zFar;\n\t\t}\n\n\t\tpublic Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}\n\n\t}","location":{"start":34,"insert":34,"offset":" ","indent":1,"comment":null},"item_type":"class","length":16},{"id":"01fe5880-0a08-05b5-5542-6faecd482905","ancestors":["bb2de2ea-2c20-c2a0-3545-4d2d0f4d8fd9","2c1145c3-61d0-3299-734d-27973c438927"],"type":"function","description":"generates a matrix representing a perspective projection, where the focal length, aspect ratio, near and far distances are specified.","params":[],"returns":{"type_name":"Matrix4f","description":"a matrix representation of a perspective projection transformation.\n\n* The Matrix4f object is initialized with Perspective transformation parameters fov, aspect, zNear, and zFar.\n* This matrix represents a perspective projection view matrix, which maps 3D points to 2D screen coordinates based on their distance from the viewer's eye.\n* The Field of View (FOV) parameter determines the maximum angle that can be seen in the horizontal direction, measured in radians. A larger FOV means a wider field of view.\n* The Aspect parameter represents the ratio of the screen's width to height. This affects how the projection is scaled along the X and Y axes.\n* The Near and Far parameters represent the distances from the eye to the near and far limits of the projection, respectively. These values determine the minimum and maximum distances that can be represented in the projection.","complex_type":true},"usage":{"language":"java","code":"Camera3D camera = new Camera3D(80, 16 / 9, 0.1f, 100.0f);\nMatrix4f projection = camera.getProjectionMatrix();\nSystem.out.println(projection); // prints the perspective projection matrix\n","description":""},"name":"getAsMatrix4","code":"public Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}","location":{"start":45,"insert":45,"offset":" ","indent":2,"comment":null},"item_type":"method","length":3},{"id":"f8b1ecf8-f3fd-9990-9040-4288026e444b","ancestors":["bb2de2ea-2c20-c2a0-3545-4d2d0f4d8fd9"],"type":"function","description":"processes input from the mouse and keyboard, rotating the object based on sensor input and speeding up movement when the shift key is pressed.","params":[{"name":"dt","type_name":"float","description":"time step of the simulation, which is used to calculate the movement of the entity based on its speed and sensitivity.","complex_type":false},{"name":"speed","type_name":"float","description":"3D movement speed of the object being controlled by the user, which is multiplied by the time step `dt` to determine the total distance moved during each frame.","complex_type":false},{"name":"sens","type_name":"float","description":"sensitivity of the movement, which determines how much the character will move in response to a given input from the user.","complex_type":false}],"usage":{"language":"java","code":"public void myMethod() {\n    float dt = 0.016f; // Delta time in seconds, should be a very small positive value\n    float speed = 3.0f; // Movement speed in units per second, can be negative to move backwards\n    float sensitivity = 10.0f; // Mouse sensitivity, smaller values make the camera more sensitive\n    processInput(dt, speed, sensitivity);\n}\n","description":""},"name":"processInput","code":"public void processInput(float dt, float speed, float sens) {\n\n\t\tfloat dx = Mouse.getDX();\n\t\tfloat dy = Mouse.getDY();\n\t\tfloat roty = (float)Math.toRadians(dx * sens);\n\t\tgetTransform().rotate(new Vector3f(0, 1, 0), (float) roty);\n\t\tgetTransform().rotate(getTransform().getRot().getRight(), (float) -Math.toRadians(dy * sens));\n\t\t\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))\n\t\t\tspeed *= 10;\n\t\t\n\t\tfloat movAmt = speed * dt;\n\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_W))\n\t\t\tmove(getTransform().getRot().getForward(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_S))\n\t\t\tmove(getTransform().getRot().getForward(), -movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_A))\n\t\t\tmove(getTransform().getRot().getLeft(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_D))\n\t\t\tmove(getTransform().getRot().getRight(), movAmt);\n\t\t\n\t}","location":{"start":51,"insert":51,"offset":" ","indent":1,"comment":null},"item_type":"method","length":23},{"id":"646664d0-5a74-d0b0-4548-3907c543a99b","ancestors":["bb2de2ea-2c20-c2a0-3545-4d2d0f4d8fd9"],"type":"function","description":"moves the object in the specified direction by the given amount.","params":[{"name":"dir","type_name":"Vector3f","description":"3D direction in which the object should move, with its magnitude being multiplied by the specified amount (`amt`) to determine the new position of the object.\n\n* `dir`: A `Vector3f` object representing the direction to move in 3D space. It has three attributes: `x`, `y`, and `z`, which correspond to the coordinates of the movement along the direction vector.","complex_type":true},{"name":"amt","type_name":"float","description":"amount of movement along the specified direction, which is added to the current position of the transform.","complex_type":false}],"usage":{"language":"java","code":"Vector3f dir = new Vector3f(1, 0, 0);\nfloat amt = 2;\nmove(dir, amt);\n","description":""},"name":"move","code":"private void move(Vector3f dir, float amt) {\n\t\tgetTransform().setPos(getTransform().getPos().add(dir.mul(amt)));\n\t}","location":{"start":75,"insert":75,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3}]}}}