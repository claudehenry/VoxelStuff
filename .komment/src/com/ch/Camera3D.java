{"name":"Camera3D.java","path":"src/com/ch/Camera3D.java","content":{"structured":{"description":"","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera3D.CameraStruct3D Pages: 1 -->\n<svg width=\"198pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 198.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera3D.CameraStruct3D</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"190,-19 0,-19 0,0 190,0 190,-19\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D.CameraStruct3D</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera_1_1CameraStruct.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"176.5,-74 13.5,-74 13.5,-55 176.5,-55 176.5,-74\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera.CameraStruct</text>\n</a>\n</g>\n</g>\n<!-- Node2&#45;&gt;Node1 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node2&#45;&gt;Node1</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M95,-44.66C95,-35.93 95,-25.99 95,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"91.5,-44.75 95,-54.75 98.5,-44.75 91.5,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","items":[{"id":"d2f1b422-b53b-4f39-96cf-0eed6705e544","ancestors":[],"type":"function","name":"calculateProjectionMatrix","location":{"offset":"\t","indent":1,"insert":18,"start":18},"returns":"Matrix4f","params":[{"name":"data","type":"CameraStruct"}],"code":"@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}","skip":false,"length":4,"comment":{"description":"generates a projection matrix based on input from the `CameraStruct`.","params":[{"name":"data","type":"CameraStruct","description":"3D camera parameters, including its position, view direction, and field of view, which are used to compute the projection matrix."}],"returns":{"type":"Matrix4f","description":"a Matrix4f object containing the camera's projection matrix."}}},{"id":"72cf6a2f-41be-4f5f-8d26-58c34ead8493","ancestors":[],"type":"function","name":"adjustToViewport","location":{"offset":"\t","indent":1,"insert":23,"start":23},"returns":false,"params":[{"name":"width","type":"int"},{"name":"height","type":"int"}],"code":"@Override\n\tpublic void adjustToViewport(int width, int height) {\n\t\t((CameraStruct3D) this.values).aspect = (float) width / height;\n\t\tcalculateProjectionMatrix(values);\n\t\ttry {\n\t\t\tcalculateViewMatrix();\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tGL11.glViewport(0, 0, width, height);\n\t}","skip":false,"length":10,"comment":{"description":"adjusts a camera's projection matrix to fit within a specified viewport size. It does this by calculating the aspect ratio of the viewport and then using that ratio to scale the camera's projection matrix.","params":[{"name":"width","type":"int","description":"width of the viewport."},{"name":"height","type":"int","description":"2D size of the viewport in pixels and is used to calculate the aspect ratio of the camera's projection matrix and to set the viewport size in GL11.glViewport()."}],"returns":null}},{"id":"6b29999b-c865-47e5-96f4-242458072556","ancestors":[],"type":"function","name":"getAsMatrix4","location":{"offset":"\t","indent":2,"insert":45,"start":45},"returns":"Matrix4f","params":[],"code":"public Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}","skip":false,"length":3,"comment":{"description":"returns a Matrix4f object initialized with a perspective projection matrix based on the given field of view (fov), aspect ratio, near plane (zNear), and far plane (zFar).","params":[],"returns":{"type":"Matrix4f","description":"a matrix representation of a perspective projection transformation."}}},{"id":"1417e622-b90b-424d-bbb0-c1130ae6f97e","ancestors":[],"type":"function","name":"processInput","location":{"offset":"\t","indent":1,"insert":51,"start":51},"returns":false,"params":[{"name":"dt","type":"float"},{"name":"speed","type":"float"},{"name":"sens","type":"float"}],"code":"public void processInput(float dt, float speed, float sens) {\n\n\t\tfloat dx = Mouse.getDX();\n\t\tfloat dy = Mouse.getDY();\n\t\tfloat roty = (float)Math.toRadians(dx * sens);\n\t\tgetTransform().rotate(new Vector3f(0, 1, 0), (float) roty);\n\t\tgetTransform().rotate(getTransform().getRot().getRight(), (float) -Math.toRadians(dy * sens));\n\t\t\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))\n\t\t\tspeed *= 10;\n\t\t\n\t\tfloat movAmt = speed * dt;\n\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_W))\n\t\t\tmove(getTransform().getRot().getForward(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_S))\n\t\t\tmove(getTransform().getRot().getForward(), -movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_A))\n\t\t\tmove(getTransform().getRot().getLeft(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_D))\n\t\t\tmove(getTransform().getRot().getRight(), movAmt);\n\t\t\n\t}","skip":false,"length":23,"comment":{"description":"processes input from the mouse and keyboard, applying rotations and movements to an object based on user inputs.","params":[{"name":"dt","type":"float","description":"time step for which the code is being executed, and it is used to determine the movement of the object based on its speed and sensitivity."},{"name":"speed","type":"float","description":"3D movement speed of the object being manipulated by the code, and it is multiplied by the time differential `dt` to determine the total distance traveled during each frame."},{"name":"sens","type":"float","description":"sensitivity of the mouse input, which determines how much the character will move based on the user's cursor position."}],"returns":null}},{"id":"4364befd-75e8-48cf-b06d-bca96c186f39","ancestors":[],"type":"function","name":"move","location":{"offset":"\t","indent":1,"insert":75,"start":75},"returns":false,"params":[{"name":"dir","type":"Vector3f"},{"name":"amt","type":"float"}],"code":"private void move(Vector3f dir, float amt) {\n\t\tgetTransform().setPos(getTransform().getPos().add(dir.mul(amt)));\n\t}","skip":false,"length":3,"comment":{"description":"updates the position of an object by adding a directional vector multiplied by a scalar amount to its current position.","params":[{"name":"dir","type":"Vector3f","description":"3D direction of movement, which is added to the current position of the object using the multiplication operator."},{"name":"amt","type":"float","description":"amount of movement along the specified direction, which is added to the current position of the transform."}],"returns":null}}]}}}