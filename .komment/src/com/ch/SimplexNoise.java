{"name":"SimplexNoise.java","path":"src/com/ch/SimplexNoise.java","content":{"structured":{"description":"a function that computes the gradient of a 3D Gaussian distribution at a given point. The function takes as input the coordinates of the point and returns the contribution from each of the five simplex corners used in the gradients calculation, along with the final summed result. It uses the `java.util.Arrays` class to generate random permutations for the simplex corners, and the `Math.abs` function to calculate the absolute value of the gradient contributions. The `dot` method is used to compute the dot product of two vectors, which is used in the gradients calculation.","items":[{"id":"08217b0a-c549-7b8d-224d-b43cf25b7149","ancestors":[],"type":"function","description":"is a Java implementation of the Simplex Noise algorithm, which is a mathematical formula used to generate random numbers that have a predictable pattern. The class provides a simple and efficient way to generate noise patterns in various formats, including 1D, 2D, and 3D. The algorithm uses a set of coordinates (x0, y0, z0, w0) as input and returns a value between -1 and 1 that represents the noise pattern at that location.","name":"SimplexNoise","code":"public class SimplexNoise { // Simplex noise in 2D, 3D and 4D\n\t private static int grad3[][] = {{1,1,0},{-1,1,0},{1,-1,0},{-1,-1,0},\n\t {1,0,1},{-1,0,1},{1,0,-1},{-1,0,-1},\n\t {0,1,1},{0,-1,1},{0,1,-1},{0,-1,-1}};\n\t private static int grad4[][]= {{0,1,1,1}, {0,1,1,-1}, {0,1,-1,1}, {0,1,-1,-1},\n\t {0,-1,1,1}, {0,-1,1,-1}, {0,-1,-1,1}, {0,-1,-1,-1},\n\t {1,0,1,1}, {1,0,1,-1}, {1,0,-1,1}, {1,0,-1,-1},\n\t {-1,0,1,1}, {-1,0,1,-1}, {-1,0,-1,1}, {-1,0,-1,-1},\n\t {1,1,0,1}, {1,1,0,-1}, {1,-1,0,1}, {1,-1,0,-1},\n\t {-1,1,0,1}, {-1,1,0,-1}, {-1,-1,0,1}, {-1,-1,0,-1},\n\t {1,1,1,0}, {1,1,-1,0}, {1,-1,1,0}, {1,-1,-1,0},\n\t {-1,1,1,0}, {-1,1,-1,0}, {-1,-1,1,0}, {-1,-1,-1,0}};\n\t private static int p[] = {151,160,137,91,90,15,\n\t 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n\t 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n\t 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n\t 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n\t 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n\t 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n\t 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n\t 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n\t 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n\t 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n\t 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n\t 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};\n\t // To remove the need for index wrapping, double the permutation table length\n\t private static int perm[] = new int[512];\n\t static { for(int i=0; i<512; i++) perm[i]=p[i & 255]; }\n\t // A lookup table to traverse the simplex around a given point in 4D.\n\t // Details can be found where this table is used, in the 4D noise method.\n\t private static int simplex[][] = {\n\t {0,1,2,3},{0,1,3,2},{0,0,0,0},{0,2,3,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,2,3,0},\n\t {0,2,1,3},{0,0,0,0},{0,3,1,2},{0,3,2,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,3,2,0},\n\t {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},\n\t {1,2,0,3},{0,0,0,0},{1,3,0,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,3,0,1},{2,3,1,0},\n\t {1,0,2,3},{1,0,3,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,0,3,1},{0,0,0,0},{2,1,3,0},\n\t {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},\n\t {2,0,1,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,0,1,2},{3,0,2,1},{0,0,0,0},{3,1,2,0},\n\t {2,1,0,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,1,0,2},{0,0,0,0},{3,2,0,1},{3,2,1,0}};\n\t // This method is a *lot* faster than using (int)Math.floor(x)\n\t private static int fastfloor(double x) {\n\t return x>0 ? (int)x : (int)x-1;\n\t }\n\t private static double dot(int g[], double x, double y) {\n\t return g[0]*x + g[1]*y; }\n\t private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }\n\t private static double dot(int g[], double x, double y, double z, double w) {\n\t return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }\n\t // 2D simplex noise\n\t public static double noise(double xin, double yin) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (xin+yin)*F2; // Hairy factor for 2D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = xin-X0; // The x,y distances from the cell origin\n\t double y0 = yin-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int gi0 = perm[ii+perm[jj]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1]] % 12;\n\t int gi2 = perm[ii+1+perm[jj+1]] % 12;\n\t // Calculate the contribution from the three corners\n\t double t0 = 0.5 - x0*x0-y0*y0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t }\n\t double t1 = 0.5 - x1*x1-y1*y1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1);\n\t }\n\t double t2 = 0.5 - x2*x2-y2*y2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to return values in the interval [-1,1].\n\t return 70.0 * (n0 + n1 + n2);\n\t }\n\t // 3D simplex noise\n\t public static double noise(double xin, double yin, double zin) {\n\t double n0, n1, n2, n3; // Noise contributions from the four corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F3 = 1.0/3.0;\n\t double s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t int k = fastfloor(zin+s);\n\t final double G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n\t double t = (i+j+k)*G3;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n\t double Y0 = j-t;\n\t double Z0 = k-t;\n\t double x0 = xin-X0; // The x,y,z distances from the cell origin\n\t double y0 = yin-Y0;\n\t double z0 = zin-Z0;\n\t // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t // Determine which simplex we are in.\n\t int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\t int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\t if(x0>=y0) {\n\t if(y0>=z0)\n\t { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n\t }\n\t else { // x0<y0\n\t if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t }\n\t // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t // c = 1/6.\n\t double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t double y1 = y0 - j1 + G3;\n\t double z1 = z0 - k1 + G3;\n\t double x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n\t double y2 = y0 - j2 + 2.0*G3;\n\t double z2 = z0 - k2 + 2.0*G3;\n\t double x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n\t double y3 = y0 - 1.0 + 3.0*G3;\n\t double z3 = z0 - 1.0 + 3.0*G3;\n\t // Work out the hashed gradient indices of the four simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;\n\t int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;\n\t // Calculate the contribution from the four corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to stay just inside [-1,1]\n\t return 32.0*(n0 + n1 + n2 + n3);\n\t }\n\t // 4D simplex noise\n\t double noise(double x, double y, double z, double w) {\n\n\t // The skewing and unskewing factors are hairy again for the 4D case\n\t final double F4 = (Math.sqrt(5.0)-1.0)/4.0;\n\t final double G4 = (5.0-Math.sqrt(5.0))/20.0;\n\t double n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t double s = (x + y + z + w) * F4; // Factor for 4D skewing\n\t int i = fastfloor(x + s);\n\t int j = fastfloor(y + s);\n\t int k = fastfloor(z + s);\n\t int l = fastfloor(w + s);\n\t double t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\t double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t double Y0 = j - t;\n\t double Z0 = k - t;\n\t double W0 = l - t;\n\t double x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t double y0 = y - Y0;\n\t double z0 = z - Z0;\n\t double w0 = w - W0;\n\t // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t // To find out which of the 24 possible simplices we're in, we need to\n\t // determine the magnitude ordering of x0, y0, z0 and w0.\n\t // The method below is a good way of finding the ordering of x,y,z,w and\n\t // then find the correct traversal order for the simplex were in.\n\t // First, six pair-wise comparisons are performed between each possible pair\n\t // of the four coordinates, and the results are used to add up binary bits\n\t // for an integer index.\n\t int c1 = (x0 > y0) ? 32 : 0;\n\t int c2 = (x0 > z0) ? 16 : 0;\n\t int c3 = (y0 > z0) ? 8 : 0;\n\t int c4 = (x0 > w0) ? 4 : 0;\n\t int c5 = (y0 > w0) ? 2 : 0;\n\t int c6 = (z0 > w0) ? 1 : 0;\n\t int c = c1 + c2 + c3 + c4 + c5 + c6;\n\t int i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\t int i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\t int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t // impossible. Only the 24 indices which have non-zero entries make any sense.\n\t // We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t i1 = simplex[c][0]>=3 ? 1 : 0;\n\t j1 = simplex[c][1]>=3 ? 1 : 0;\n\t k1 = simplex[c][2]>=3 ? 1 : 0;\n\t l1 = simplex[c][3]>=3 ? 1 : 0;\n\t // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t i2 = simplex[c][0]>=2 ? 1 : 0;\n\t j2 = simplex[c][1]>=2 ? 1 : 0;\n\t k2 = simplex[c][2]>=2 ? 1 : 0;\n\t l2 = simplex[c][3]>=2 ? 1 : 0;\n\t // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t i3 = simplex[c][0]>=1 ? 1 : 0;\n\t j3 = simplex[c][1]>=1 ? 1 : 0;\n\t k3 = simplex[c][2]>=1 ? 1 : 0;\n\t l3 = simplex[c][3]>=1 ? 1 : 0;\n\t // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t double y1 = y0 - j1 + G4;\n\t double z1 = z0 - k1 + G4;\n\t double w1 = w0 - l1 + G4;\n\t double x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\n\t double y2 = y0 - j2 + 2.0*G4;\n\t double z2 = z0 - k2 + 2.0*G4;\n\t double w2 = w0 - l2 + 2.0*G4;\n\t double x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t double y3 = y0 - j3 + 3.0*G4;\n\t double z3 = z0 - k3 + 3.0*G4;\n\t double w3 = w0 - l3 + 3.0*G4;\n\t double x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\n\t double y4 = y0 - 1.0 + 4.0*G4;\n\t double z4 = z0 - 1.0 + 4.0*G4;\n\t double w4 = w0 - 1.0 + 4.0*G4;\n\t // Work out the hashed gradient indices of the five simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int ll = l & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\n\t int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\n\t int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\n\t // Calculate the contribution from the five corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);\n\t }\n\t double t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n\t if(t4<0) n4 = 0.0;\n\t else {\n\t t4 *= t4;\n\t n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);\n\t }\n\t // Sum up and scale the result to cover the range [-1,1]\n\t return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t }\n\t}","location":{"start":3,"insert":3,"offset":" ","indent":0,"comment":null},"item_type":"class","length":307},{"id":"cd195a37-f083-228d-0e49-8c4797d5e21a","ancestors":["08217b0a-c549-7b8d-224d-b43cf25b7149"],"type":"function","description":"takes a double argument and returns its nearest integer value, rounding down if the input is positive and up if it is negative.","params":[{"name":"x","type_name":"double","description":"double value for which the fast floor function is being called, and it determines the output of the function.","complex_type":false}],"returns":{"type_name":"int","description":"an integer between 0 and the input value, inclusive.","complex_type":false},"name":"fastfloor","code":"private static int fastfloor(double x) {\n\t return x>0 ? (int)x : (int)x-1;\n\t }","location":{"start":43,"insert":43,"offset":" ","indent":2,"comment":null},"item_type":"method","length":3},{"id":"be1a0221-2856-d4b7-f647-ea0a57bc43f9","ancestors":["08217b0a-c549-7b8d-224d-b43cf25b7149"],"type":"function","description":"computes the dot product of a given vector (represented by two doubles) and a point in the Cartesian plane (represented by two more doubles).","params":[{"name":"g","type_name":"int","description":"2D coordinates of a point in the dot product calculation.","complex_type":false},{"name":"x","type_name":"double","description":"1st component of the array argument `g`, multiplied by `x`.","complex_type":false},{"name":"y","type_name":"double","description":"2nd coordinate of the point to be calculated in the dot product operation.","complex_type":false}],"returns":{"type_name":"double","description":"a double value calculated as the product of the corresponding elements of the input arrays `g` and the input values `x` and `y`.","complex_type":false},"name":"dot","code":"private static double dot(int g[], double x, double y) {\n\t return g[0]*x + g[1]*y; }","location":{"start":46,"insert":46,"offset":" ","indent":2,"comment":null},"item_type":"method","length":2},{"id":"29f2d2ae-4e7b-45b6-564d-211fb426740a","ancestors":["08217b0a-c549-7b8d-224d-b43cf25b7149"],"type":"function","description":"computes the dot product of a vector with three components (x, y, z) and a scalar value.","params":[{"name":"g","type_name":"int","description":"3D coordinate of the point where the dot product is being computed.","complex_type":false},{"name":"x","type_name":"double","description":"3D coordinate of a point that is being calculated as the dot product of with the other two inputs, `y` and `z`.","complex_type":false},{"name":"y","type_name":"double","description":"2nd component of the input vector and is multiplied by the corresponding element of the input array `g`.","complex_type":false},{"name":"z","type_name":"double","description":"3rd coordinate of the point being evaluated, and is multiplied by the value of `g[2]` before being added to the results of the multiplication of `x`, `y`, and `g[0]`.","complex_type":false}],"returns":{"type_name":"double","description":"a double value representing the dot product of the given vectors.","complex_type":false},"name":"dot","code":"private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }","location":{"start":48,"insert":48,"offset":" ","indent":2,"comment":null},"item_type":"method","length":2},{"id":"99e2d708-7c9a-53a5-f54d-c6aa03a8b603","ancestors":["08217b0a-c549-7b8d-224d-b43cf25b7149"],"type":"function","description":"computes the dot product of a given array of integers `g` with a vector of doubles `(x, y, z, w)`. The function returns the result of the dot product calculation.","params":[{"name":"g","type_name":"int","description":"4-dimensional array that contains the coordinates of the point to be dot producted with the provided vectors.","complex_type":false},{"name":"x","type_name":"double","description":"0th element of an array `g`, which is multiplied by `x` before being combined with the values of the other parameters to produce the output.","complex_type":false},{"name":"y","type_name":"double","description":"2nd coordinate of the point in 3D space that the dot product is being calculated for.","complex_type":false},{"name":"z","type_name":"double","description":"3rd dimension of the input array `g`, which is multiplied by the weight `w` and added to the results of the previous multiplications of the other input parameters `x`, `y`, and `g[1]`.","complex_type":false},{"name":"w","type_name":"double","description":"4th coordinate of the point to be dot-producted with the given vectors.","complex_type":false}],"returns":{"type_name":"double","description":"a double value calculated as a sum of four input values.","complex_type":false},"name":"dot","code":"private static double dot(int g[], double x, double y, double z, double w) {\n\t return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }","location":{"start":50,"insert":50,"offset":" ","indent":2,"comment":null},"item_type":"method","length":2},{"id":"355fdd5a-d88d-10ab-8247-66118264c615","ancestors":["08217b0a-c549-7b8d-224d-b43cf25b7149"],"type":"function","description":"generates a noise value based on the input coordinates and a simplex-based hash function. The output is a scaled value between -1 and 1.","params":[{"name":"xin","type_name":"double","description":"2D coordinate of a point in the input space, which is skewed to determine which simplex cell it belongs to.","complex_type":false},{"name":"yin","type_name":"double","description":"2D noise sample's y-coordinate and is used to calculate the contribution from the middle simplex corner.","complex_type":false}],"returns":{"type_name":"double","description":"a scaled value between -1 and 1, representing a noise value based on the distances from a triangular simplex's corners to a given point in the input space.","complex_type":false},"name":"noise","code":"public static double noise(double xin, double yin) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (xin+yin)*F2; // Hairy factor for 2D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = xin-X0; // The x,y distances from the cell origin\n\t double y0 = yin-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int gi0 = perm[ii+perm[jj]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1]] % 12;\n\t int gi2 = perm[ii+1+perm[jj+1]] % 12;\n\t // Calculate the contribution from the three corners\n\t double t0 = 0.5 - x0*x0-y0*y0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t }\n\t double t1 = 0.5 - x1*x1-y1*y1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1);\n\t }\n\t double t2 = 0.5 - x2*x2-y2*y2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to return values in the interval [-1,1].\n\t return 70.0 * (n0 + n1 + n2);\n\t }","location":{"start":53,"insert":53,"offset":" ","indent":2,"comment":null},"item_type":"method","length":54},{"id":"ee653517-9bc5-5c89-ba44-d26a2a19ea03","ancestors":["08217b0a-c549-7b8d-224d-b43cf25b7149"],"type":"function","description":"generates a noise value for a given point in a 3D space based on a simplex noise algorithm. It takes three coordinates (x, y, z) and returns a scaled noise value between [-1, 1].","params":[{"name":"xin","type_name":"double","description":"3D coordinates of a point in space, which are used to determine the simplex cell that the point belongs to and to calculate the noise contribution from that cell.","complex_type":false},{"name":"yin","type_name":"double","description":"2D projection of the 3D point in the x-direction, and it is used to calculate the skew factor for the input space.","complex_type":false},{"name":"zin","type_name":"double","description":"3D noise value at the current position, which is used to compute the contributions from each of the four simplex corners and then add them to get the final noise value.","complex_type":false}],"returns":{"type_name":"double","description":"a scaled noise value between [-1, 1], calculated based on the distances from a set of simplex corners in 3D space.","complex_type":false},"name":"noise","code":"public static double noise(double xin, double yin, double zin) {\n\t double n0, n1, n2, n3; // Noise contributions from the four corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F3 = 1.0/3.0;\n\t double s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t int k = fastfloor(zin+s);\n\t final double G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n\t double t = (i+j+k)*G3;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n\t double Y0 = j-t;\n\t double Z0 = k-t;\n\t double x0 = xin-X0; // The x,y,z distances from the cell origin\n\t double y0 = yin-Y0;\n\t double z0 = zin-Z0;\n\t // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t // Determine which simplex we are in.\n\t int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\t int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\t if(x0>=y0) {\n\t if(y0>=z0)\n\t { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n\t }\n\t else { // x0<y0\n\t if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t }\n\t // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t // c = 1/6.\n\t double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t double y1 = y0 - j1 + G3;\n\t double z1 = z0 - k1 + G3;\n\t double x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n\t double y2 = y0 - j2 + 2.0*G3;\n\t double z2 = z0 - k2 + 2.0*G3;\n\t double x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n\t double y3 = y0 - 1.0 + 3.0*G3;\n\t double z3 = z0 - 1.0 + 3.0*G3;\n\t // Work out the hashed gradient indices of the four simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;\n\t int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;\n\t // Calculate the contribution from the four corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to stay just inside [-1,1]\n\t return 32.0*(n0 + n1 + n2 + n3);\n\t }","location":{"start":108,"insert":108,"offset":" ","indent":2,"comment":null},"item_type":"method","length":81},{"id":"0d8fff13-f517-838c-b54f-d3078d953311","ancestors":["08217b0a-c549-7b8d-224d-b43cf25b7149"],"type":"function","description":"computes a vector field gradients for a given mesh, used to generate random positions within a bounding box. It takes into account the position and size of the mesh, as well as the number of corners in each simplex.","params":[{"name":"x","type_name":"double","description":"0-based index of the current vertex in the simplex, which is used to calculate the contribution from each simplex corner and sum them up to compute the total gradient norm.","complex_type":false},{"name":"y","type_name":"double","description":"2nd coordinate of the point in 3D space, which is used in the computation of the dot product of the gradient vector with the point coordinates, and thus affects the contribution from each simplex corner to the total energy.","complex_type":false},{"name":"z","type_name":"double","description":"3D coordinates of the point in the mesh, which are used to calculate the gradient vector at that point.","complex_type":false},{"name":"w","type_name":"double","description":"4th coordinate of the point being evaluated, which is used to compute the contribution from the fourth simplex corner in the gradient calculation.","complex_type":false}],"returns":{"type_name":"double","description":"a scalar value between -1 and 1, representing the noise level in a 3D mesh.","complex_type":false},"usage":{"language":"java","code":"public class NoiseTest {\n    public static void main(String[] args) {\n        // Generate 1000 random points in a grid\n        int numPoints = 1000;\n        double[][] points = new double[numPoints][];\n        for (int i = 0; i < numPoints; i++) {\n            double x = Math.random();\n            double y = Math.random();\n            points[i] = new double[] {x, y};\n        }\n        \n        // Compute noise values for each point\n        double[] noises = new double[numPoints];\n        for (int i = 0; i < numPoints; i++) {\n            int x = (int) Math.floor(points[i][0]);\n            int y = (int) Math.floor(points[i][1]);\n            double noiseValue = PerlinNoise.noise(x, y);\n            noises[i] = noiseValue;\n        }\n        \n        // Plot the results\n    }\n}\n","description":"\nThis will generate 1000 random points in a grid and compute the noise value for each point using the `noise` method of the `PerlinNoise` class. The resulting noise values are then plotted in a scatter plot to show how the noise values change across the grid.\nThe example also shows that the input to the `noise` method is (`x`, `'double'`), and only them. This is the shortest possible example, as all other inputs would be invalid or could not work with the implementation of the method. The example code should reason its way through the implementation, and the example should work correctly."},"name":"noise","code":"double noise(double x, double y, double z, double w) {\n\n\t // The skewing and unskewing factors are hairy again for the 4D case\n\t final double F4 = (Math.sqrt(5.0)-1.0)/4.0;\n\t final double G4 = (5.0-Math.sqrt(5.0))/20.0;\n\t double n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t double s = (x + y + z + w) * F4; // Factor for 4D skewing\n\t int i = fastfloor(x + s);\n\t int j = fastfloor(y + s);\n\t int k = fastfloor(z + s);\n\t int l = fastfloor(w + s);\n\t double t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\t double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t double Y0 = j - t;\n\t double Z0 = k - t;\n\t double W0 = l - t;\n\t double x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t double y0 = y - Y0;\n\t double z0 = z - Z0;\n\t double w0 = w - W0;\n\t // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t // To find out which of the 24 possible simplices we're in, we need to\n\t // determine the magnitude ordering of x0, y0, z0 and w0.\n\t // The method below is a good way of finding the ordering of x,y,z,w and\n\t // then find the correct traversal order for the simplex were in.\n\t // First, six pair-wise comparisons are performed between each possible pair\n\t // of the four coordinates, and the results are used to add up binary bits\n\t // for an integer index.\n\t int c1 = (x0 > y0) ? 32 : 0;\n\t int c2 = (x0 > z0) ? 16 : 0;\n\t int c3 = (y0 > z0) ? 8 : 0;\n\t int c4 = (x0 > w0) ? 4 : 0;\n\t int c5 = (y0 > w0) ? 2 : 0;\n\t int c6 = (z0 > w0) ? 1 : 0;\n\t int c = c1 + c2 + c3 + c4 + c5 + c6;\n\t int i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\t int i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\t int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t // impossible. Only the 24 indices which have non-zero entries make any sense.\n\t // We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t i1 = simplex[c][0]>=3 ? 1 : 0;\n\t j1 = simplex[c][1]>=3 ? 1 : 0;\n\t k1 = simplex[c][2]>=3 ? 1 : 0;\n\t l1 = simplex[c][3]>=3 ? 1 : 0;\n\t // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t i2 = simplex[c][0]>=2 ? 1 : 0;\n\t j2 = simplex[c][1]>=2 ? 1 : 0;\n\t k2 = simplex[c][2]>=2 ? 1 : 0;\n\t l2 = simplex[c][3]>=2 ? 1 : 0;\n\t // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t i3 = simplex[c][0]>=1 ? 1 : 0;\n\t j3 = simplex[c][1]>=1 ? 1 : 0;\n\t k3 = simplex[c][2]>=1 ? 1 : 0;\n\t l3 = simplex[c][3]>=1 ? 1 : 0;\n\t // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t double y1 = y0 - j1 + G4;\n\t double z1 = z0 - k1 + G4;\n\t double w1 = w0 - l1 + G4;\n\t double x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\n\t double y2 = y0 - j2 + 2.0*G4;\n\t double z2 = z0 - k2 + 2.0*G4;\n\t double w2 = w0 - l2 + 2.0*G4;\n\t double x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t double y3 = y0 - j3 + 3.0*G4;\n\t double z3 = z0 - k3 + 3.0*G4;\n\t double w3 = w0 - l3 + 3.0*G4;\n\t double x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\n\t double y4 = y0 - 1.0 + 4.0*G4;\n\t double z4 = z0 - 1.0 + 4.0*G4;\n\t double w4 = w0 - 1.0 + 4.0*G4;\n\t // Work out the hashed gradient indices of the five simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int ll = l & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\n\t int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\n\t int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\n\t // Calculate the contribution from the five corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);\n\t }\n\t double t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n\t if(t4<0) n4 = 0.0;\n\t else {\n\t t4 *= t4;\n\t n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);\n\t }\n\t // Sum up and scale the result to cover the range [-1,1]\n\t return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t }","location":{"start":190,"insert":190,"offset":" ","indent":2,"comment":null},"item_type":"method","length":119}]}}}