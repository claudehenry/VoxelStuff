{"name":"SimplexNoise.java","path":"src/com/ch/SimplexNoise.java","content":{"structured":{"description":"a simplex optimization algorithm for finding the closest point in a set of points to a given target point, using a gradient descent approach. The code uses the `java.util` package for array operations and the `java.lang` package for mathematical functions.\n\nThe algorithm starts by defining a `simplex` array of size `N+1`, where `N` is the number of points in the set, and initializing it with values from the target point. The algorithm then iterates through the following steps until convergence:\n\n1. Calculate the gradient of the objective function (the distance between the target point and the current simplex point) using the `grad4` array, which is initialized with random values.\n2. Use the gradient to update the position of the current simplex point by moving it in the direction of the gradient, and scaled by a factor that depends on the magnitude of the gradient.\n3. Update the `simplex` array element at position `c` based on the new position of the current simplex point.\n4. Repeat steps 1-3 until convergence is reached.\n\nThe code then returns the result of the optimization, which is a scalar value representing the distance between the target point and the closest point in the set of points.","items":[{"id":"7491c7a9-7045-fbb4-194f-fd81eaaef6d9","ancestors":[],"type":"function","description":"TODO","name":"SimplexNoise","code":"public class SimplexNoise { // Simplex noise in 2D, 3D and 4D\n\t private static int grad3[][] = {{1,1,0},{-1,1,0},{1,-1,0},{-1,-1,0},\n\t {1,0,1},{-1,0,1},{1,0,-1},{-1,0,-1},\n\t {0,1,1},{0,-1,1},{0,1,-1},{0,-1,-1}};\n\t private static int grad4[][]= {{0,1,1,1}, {0,1,1,-1}, {0,1,-1,1}, {0,1,-1,-1},\n\t {0,-1,1,1}, {0,-1,1,-1}, {0,-1,-1,1}, {0,-1,-1,-1},\n\t {1,0,1,1}, {1,0,1,-1}, {1,0,-1,1}, {1,0,-1,-1},\n\t {-1,0,1,1}, {-1,0,1,-1}, {-1,0,-1,1}, {-1,0,-1,-1},\n\t {1,1,0,1}, {1,1,0,-1}, {1,-1,0,1}, {1,-1,0,-1},\n\t {-1,1,0,1}, {-1,1,0,-1}, {-1,-1,0,1}, {-1,-1,0,-1},\n\t {1,1,1,0}, {1,1,-1,0}, {1,-1,1,0}, {1,-1,-1,0},\n\t {-1,1,1,0}, {-1,1,-1,0}, {-1,-1,1,0}, {-1,-1,-1,0}};\n\t private static int p[] = {151,160,137,91,90,15,\n\t 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n\t 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n\t 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n\t 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n\t 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n\t 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n\t 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n\t 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n\t 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n\t 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n\t 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n\t 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};\n\t // To remove the need for index wrapping, double the permutation table length\n\t private static int perm[] = new int[512];\n\t static { for(int i=0; i<512; i++) perm[i]=p[i & 255]; }\n\t // A lookup table to traverse the simplex around a given point in 4D.\n\t // Details can be found where this table is used, in the 4D noise method.\n\t private static int simplex[][] = {\n\t {0,1,2,3},{0,1,3,2},{0,0,0,0},{0,2,3,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,2,3,0},\n\t {0,2,1,3},{0,0,0,0},{0,3,1,2},{0,3,2,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,3,2,0},\n\t {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},\n\t {1,2,0,3},{0,0,0,0},{1,3,0,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,3,0,1},{2,3,1,0},\n\t {1,0,2,3},{1,0,3,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,0,3,1},{0,0,0,0},{2,1,3,0},\n\t {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},\n\t {2,0,1,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,0,1,2},{3,0,2,1},{0,0,0,0},{3,1,2,0},\n\t {2,1,0,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,1,0,2},{0,0,0,0},{3,2,0,1},{3,2,1,0}};\n\t // This method is a *lot* faster than using (int)Math.floor(x)\n\t private static int fastfloor(double x) {\n\t return x>0 ? (int)x : (int)x-1;\n\t }\n\t private static double dot(int g[], double x, double y) {\n\t return g[0]*x + g[1]*y; }\n\t private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }\n\t private static double dot(int g[], double x, double y, double z, double w) {\n\t return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }\n\t // 2D simplex noise\n\t public static double noise(double xin, double yin) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (xin+yin)*F2; // Hairy factor for 2D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = xin-X0; // The x,y distances from the cell origin\n\t double y0 = yin-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int gi0 = perm[ii+perm[jj]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1]] % 12;\n\t int gi2 = perm[ii+1+perm[jj+1]] % 12;\n\t // Calculate the contribution from the three corners\n\t double t0 = 0.5 - x0*x0-y0*y0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t }\n\t double t1 = 0.5 - x1*x1-y1*y1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1);\n\t }\n\t double t2 = 0.5 - x2*x2-y2*y2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to return values in the interval [-1,1].\n\t return 70.0 * (n0 + n1 + n2);\n\t }\n\t // 3D simplex noise\n\t public static double noise(double xin, double yin, double zin) {\n\t double n0, n1, n2, n3; // Noise contributions from the four corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F3 = 1.0/3.0;\n\t double s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t int k = fastfloor(zin+s);\n\t final double G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n\t double t = (i+j+k)*G3;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n\t double Y0 = j-t;\n\t double Z0 = k-t;\n\t double x0 = xin-X0; // The x,y,z distances from the cell origin\n\t double y0 = yin-Y0;\n\t double z0 = zin-Z0;\n\t // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t // Determine which simplex we are in.\n\t int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\t int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\t if(x0>=y0) {\n\t if(y0>=z0)\n\t { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n\t }\n\t else { // x0<y0\n\t if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t }\n\t // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t // c = 1/6.\n\t double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t double y1 = y0 - j1 + G3;\n\t double z1 = z0 - k1 + G3;\n\t double x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n\t double y2 = y0 - j2 + 2.0*G3;\n\t double z2 = z0 - k2 + 2.0*G3;\n\t double x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n\t double y3 = y0 - 1.0 + 3.0*G3;\n\t double z3 = z0 - 1.0 + 3.0*G3;\n\t // Work out the hashed gradient indices of the four simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;\n\t int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;\n\t // Calculate the contribution from the four corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to stay just inside [-1,1]\n\t return 32.0*(n0 + n1 + n2 + n3);\n\t }\n\t // 4D simplex noise\n\t double noise(double x, double y, double z, double w) {\n\n\t // The skewing and unskewing factors are hairy again for the 4D case\n\t final double F4 = (Math.sqrt(5.0)-1.0)/4.0;\n\t final double G4 = (5.0-Math.sqrt(5.0))/20.0;\n\t double n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t double s = (x + y + z + w) * F4; // Factor for 4D skewing\n\t int i = fastfloor(x + s);\n\t int j = fastfloor(y + s);\n\t int k = fastfloor(z + s);\n\t int l = fastfloor(w + s);\n\t double t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\t double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t double Y0 = j - t;\n\t double Z0 = k - t;\n\t double W0 = l - t;\n\t double x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t double y0 = y - Y0;\n\t double z0 = z - Z0;\n\t double w0 = w - W0;\n\t // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t // To find out which of the 24 possible simplices we're in, we need to\n\t // determine the magnitude ordering of x0, y0, z0 and w0.\n\t // The method below is a good way of finding the ordering of x,y,z,w and\n\t // then find the correct traversal order for the simplex were in.\n\t // First, six pair-wise comparisons are performed between each possible pair\n\t // of the four coordinates, and the results are used to add up binary bits\n\t // for an integer index.\n\t int c1 = (x0 > y0) ? 32 : 0;\n\t int c2 = (x0 > z0) ? 16 : 0;\n\t int c3 = (y0 > z0) ? 8 : 0;\n\t int c4 = (x0 > w0) ? 4 : 0;\n\t int c5 = (y0 > w0) ? 2 : 0;\n\t int c6 = (z0 > w0) ? 1 : 0;\n\t int c = c1 + c2 + c3 + c4 + c5 + c6;\n\t int i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\t int i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\t int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t // impossible. Only the 24 indices which have non-zero entries make any sense.\n\t // We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t i1 = simplex[c][0]>=3 ? 1 : 0;\n\t j1 = simplex[c][1]>=3 ? 1 : 0;\n\t k1 = simplex[c][2]>=3 ? 1 : 0;\n\t l1 = simplex[c][3]>=3 ? 1 : 0;\n\t // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t i2 = simplex[c][0]>=2 ? 1 : 0;\n\t j2 = simplex[c][1]>=2 ? 1 : 0;\n\t k2 = simplex[c][2]>=2 ? 1 : 0;\n\t l2 = simplex[c][3]>=2 ? 1 : 0;\n\t // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t i3 = simplex[c][0]>=1 ? 1 : 0;\n\t j3 = simplex[c][1]>=1 ? 1 : 0;\n\t k3 = simplex[c][2]>=1 ? 1 : 0;\n\t l3 = simplex[c][3]>=1 ? 1 : 0;\n\t // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t double y1 = y0 - j1 + G4;\n\t double z1 = z0 - k1 + G4;\n\t double w1 = w0 - l1 + G4;\n\t double x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\n\t double y2 = y0 - j2 + 2.0*G4;\n\t double z2 = z0 - k2 + 2.0*G4;\n\t double w2 = w0 - l2 + 2.0*G4;\n\t double x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t double y3 = y0 - j3 + 3.0*G4;\n\t double z3 = z0 - k3 + 3.0*G4;\n\t double w3 = w0 - l3 + 3.0*G4;\n\t double x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\n\t double y4 = y0 - 1.0 + 4.0*G4;\n\t double z4 = z0 - 1.0 + 4.0*G4;\n\t double w4 = w0 - 1.0 + 4.0*G4;\n\t // Work out the hashed gradient indices of the five simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int ll = l & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\n\t int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\n\t int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\n\t // Calculate the contribution from the five corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);\n\t }\n\t double t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n\t if(t4<0) n4 = 0.0;\n\t else {\n\t t4 *= t4;\n\t n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);\n\t }\n\t // Sum up and scale the result to cover the range [-1,1]\n\t return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t }\n\t}","location":{"start":3,"insert":3,"offset":" ","indent":0},"item_type":"class","length":307},{"id":"1e7999ee-e429-a2ba-984b-e07a27b1489e","ancestors":["7491c7a9-7045-fbb4-194f-fd81eaaef6d9"],"type":"function","description":"takes a double argument and returns its nearest integer value if it is positive, otherwise it returns the integer value minus one.","params":[{"name":"x","type_name":"double","description":"double value that is to be rounded to the nearest integer using the fast floor algorithm.","complex_type":false}],"returns":{"type_name":"int","description":"an integer between 0 and the input value, inclusive.","complex_type":false},"usage":{"language":"java","code":"int x = 9;\nint result = fastfloor(x);\nSystem.out.println(\"Result: \" + result);\n","description":"\nThis is the output of this method:\n"},"name":"fastfloor","code":"private static int fastfloor(double x) {\n\t return x>0 ? (int)x : (int)x-1;\n\t }","location":{"start":43,"insert":43,"offset":" ","indent":2},"item_type":"method","length":3},{"id":"43cf5ed7-30f5-48be-014e-57025ef5c9e3","ancestors":["7491c7a9-7045-fbb4-194f-fd81eaaef6d9"],"type":"function","description":"takes an array `g` of two integers and two floating-point numbers `x` and `y`, and computes their dot product, which is a double value representing the product of the corresponding elements of `g`.","params":[{"name":"g","type_name":"int","description":"2D coordinates of a point in the dot product calculation.","complex_type":false},{"name":"x","type_name":"double","description":"0th element of the input array `g`, which is multiplied with it to produce the output result.","complex_type":false},{"name":"y","type_name":"double","description":"2nd component of the 2D point being dot-producted with the given vector.","complex_type":false}],"returns":{"type_name":"double","description":"a value representing the dot product of two input vectors.","complex_type":false},"usage":{"language":"java","code":"private static double dot(int g[], double x, double y) {\n  return g[0]*x + g[1]*y;\n}\n\npublic void generatePerlinNoise() {\n  // Create an array of random numbers. Each number must be a value between 0 and 255.\n  int[] perm = new int[256];\n  for (int i=0; i<256; i++) {\n    perm[i] = (int)(Math.random()*255);\n  }\n\n  // Create an array of random gradients. Each gradient must have values between -1 and 1.\n  int[] grad = new int[4];\n  for (int i=0; i<4; i++) {\n    grad[i] = (int)(Math.random()*2)-1;\n  }\n\n  // Create the noise array, with values between -1 and 1.\n  double[] noise = new double[256];\n  for (int i=0; i<256; i++) {\n    noise[i] = perlinNoise(perm, grad, 4, 4, i/256.0);\n  }\n}\n","description":"\nIn this example, we first create an array of random numbers for the perm array, and an array of random gradients for the grad array. We then create a noise array with values between -1 and 1 using perlinNoise with parameters perm, grad, 4, 4, i/256.0."},"name":"dot","code":"private static double dot(int g[], double x, double y) {\n\t return g[0]*x + g[1]*y; }","location":{"start":46,"insert":46,"offset":" ","indent":2},"item_type":"method","length":2},{"id":"d5f11c98-f82e-96ba-294a-ae3c4ed25f9f","ancestors":["7491c7a9-7045-fbb4-194f-fd81eaaef6d9"],"type":"function","description":"computes the dot product of a given vector with a scalar value, returning the result as a double value.","params":[{"name":"g","type_name":"int","description":"3D coordinates of a point that is being dot-producted with the input `x`, `y`, and `z` values.","complex_type":false},{"name":"x","type_name":"double","description":"0th element of an array and multiplies with it to produce the output result.","complex_type":false},{"name":"y","type_name":"double","description":"2nd dimension of the array `g`, and multiplies its value with the corresponding element in the array to produce the output result.","complex_type":false},{"name":"z","type_name":"double","description":"3rd dimension of the input array `g`, which is multiplied by the variable `z` before being added to the outputs of the `x` and `y` parameters.","complex_type":false}],"returns":{"type_name":"double","description":"a scalar value representing the dot product of the given vectors.","complex_type":false},"usage":{"language":"java","code":"private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }\n\npublic void exampleDot() {\n    // define the int array g that you will use to pass into the dot method.\n    int g = new int[] {3, 5, 7};\n    // call the dot method and pass in a double for x, y, and z.\n    double value = dot(g, 2.0, 4.0, 6.0);\n}\n","description":"\nThis is an example of how to use the java method:\n"},"name":"dot","code":"private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }","location":{"start":48,"insert":48,"offset":" ","indent":2},"item_type":"method","length":2},{"id":"7a2ccdd5-81c7-51a5-124f-b811a66c3b33","ancestors":["7491c7a9-7045-fbb4-194f-fd81eaaef6d9"],"type":"function","description":"takes five arguments: `g`, `x`, `y`, `z`, and `w`. It calculates their dot product and returns it as a double value.","params":[{"name":"g","type_name":"int","description":"4-dimensional vector that is dot-producted with the provided `x`, `y`, `z`, and `w` parameters to produce the output value.","complex_type":false},{"name":"x","type_name":"double","description":"0th element of the input array `g`.","complex_type":false},{"name":"y","type_name":"double","description":"second coordinate of the point in 3D space that is being dot-producted with the given vectors.","complex_type":false},{"name":"z","type_name":"double","description":"3rd component of the dot product operation, which combines the values of `x`, `y`, and `z` to produce the final result.","complex_type":false},{"name":"w","type_name":"double","description":"4th dimension in the dot product calculation.","complex_type":false}],"returns":{"type_name":"double","description":"a double value representing the dot product of the given vectors.","complex_type":false},"usage":{"language":"java","code":"private static double dot(int g[], double x, double y, double z, double w) {\n    return g[0]*x + g[1]*y + g[2]*z + g[3]*w;\n}\n\n//...\n\nint[] perm = { 151, 160, 137, 91, 90, 15,\n                131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n                190, 6, 148, 247, 120, 234, 105, 92, 49, 52, 222, 117, 22, 250, 122, 2, 78, 203, 116, 255, 0 };\nint[] grad4 = { 11, 109, 115, 119, 122, 124, 127, 129, 131, 133, 135, 136, 138, 139, 140, 141 };\n\npublic static void main(String[] args) {\n    int g = 7; // input for method dot\n    double x = 2.0; // input for method dot\n    double y = 3.0; // input for method dot\n    double z = 5.0; // input for method dot\n    double w = 6.0; // input for method dot\n    System.out.println(noise4d(perm, grad4, x, y, z, w)); // example usage of method dot\n}\n","description":""},"name":"dot","code":"private static double dot(int g[], double x, double y, double z, double w) {\n\t return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }","location":{"start":50,"insert":50,"offset":" ","indent":2},"item_type":"method","length":2},{"id":"3355713a-a091-c2a0-b741-f1a6a0db543e","ancestors":["7491c7a9-7045-fbb4-194f-fd81eaaef6d9"],"type":"function","description":"generates a noise value based on the distances between three corners of a simplex and the input coordinates. The noise value is calculated using the hashed gradient indices of the three corners and the dot product of the gradients with the input coordinates. The result is scaled to return values in the interval [-1,1].","params":[{"name":"xin","type_name":"double","description":"2D coordinates of a point in the input space, which is skewed using the `F2` factor to determine which simplex cell it belongs to.","complex_type":false},{"name":"yin","type_name":"double","description":"2D coordinate of the point where noise is being generated, and it is used to compute the contribution from the middle corner of the simplex in the hashed gradient calculation.","complex_type":false}],"returns":{"type_name":"double","description":"a noise value between -1 and 1, calculated using a 3D noise algorithm.","complex_type":false},"usage":{"language":"java","code":"public static void main(String[] args) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (args[0]+args[1])*F2; // Hairy factor for 2D\n\t int i = fastfloor(args[0]+s);\n\t int j = fastfloor(args[1]+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = args[0]-X0; // The x,y distances from the cell origin\n\t double y0 = args[1]-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\tdouble t0 = 0.5 - x0*x0-y0*y0;\n\tif(t0<0) n0=0.0;\n\telse {\n\tt0 *= t0;\n\tn0 = t0 * t0 * dot(grad3[ii], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t}\n\n\tdouble t1 = 0.5 - x1*x1-y1*y1;\n\tif(t1<0) n1=0.0;\n\telse {\n\tt1 *= t1;\n\tn1 = t1 * t1 * dot(grad3[ii+i1], x1, y1);\n\t}\n\n\tdouble t2 = 0.5 - x2*x2-y2*y2;\n\tif(t2<0) n2=0.0;\n\telse {\n\tt2 *= t2;\n\tn2 = t2 * t2 * dot(grad3[ii+1+j1], x2, y2);\n\t}\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70.0 * (n0 + n1 + n2);\n\t}\n","description":""},"name":"noise","code":"public static double noise(double xin, double yin) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (xin+yin)*F2; // Hairy factor for 2D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = xin-X0; // The x,y distances from the cell origin\n\t double y0 = yin-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int gi0 = perm[ii+perm[jj]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1]] % 12;\n\t int gi2 = perm[ii+1+perm[jj+1]] % 12;\n\t // Calculate the contribution from the three corners\n\t double t0 = 0.5 - x0*x0-y0*y0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t }\n\t double t1 = 0.5 - x1*x1-y1*y1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1);\n\t }\n\t double t2 = 0.5 - x2*x2-y2*y2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to return values in the interval [-1,1].\n\t return 70.0 * (n0 + n1 + n2);\n\t }","location":{"start":53,"insert":53,"offset":" ","indent":2},"item_type":"method","length":54},{"id":"673a90b2-8567-a8b4-544f-bc46983ee9ad","ancestors":["7491c7a9-7045-fbb4-194f-fd81eaaef6d9"],"type":"function","description":"generates a noise value for a given point in 3D space, based on the coordinates of four simplex corners and their hashed gradient indices. The output is a scaled value between [-1, 1].","params":[{"name":"xin","type_name":"double","description":"3D coordinate of the point in space where the noise is being calculated.","complex_type":false},{"name":"yin","type_name":"double","description":"2D projection of the noise sample at the current position in the 3D space, and is used to compute the hashed gradient indices for the four simplex corners.","complex_type":false},{"name":"zin","type_name":"double","description":"3D noise value at the current position, which is used to calculate the contribution from the fourth simplex corner in the hashed gradient calculation.","complex_type":false}],"returns":{"type_name":"double","description":"a scaled noise value between [-1, 1], calculated from the contributions of four simplex corners using dot products and scaling factors.","complex_type":false},"usage":{"language":"java","code":"public class Noise {\n    private static double noise(double xin) {\n        // 2D Perlin noise\n        return 0;\n    }\n}\n","description":""},"name":"noise","code":"public static double noise(double xin, double yin, double zin) {\n\t double n0, n1, n2, n3; // Noise contributions from the four corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F3 = 1.0/3.0;\n\t double s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t int k = fastfloor(zin+s);\n\t final double G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n\t double t = (i+j+k)*G3;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n\t double Y0 = j-t;\n\t double Z0 = k-t;\n\t double x0 = xin-X0; // The x,y,z distances from the cell origin\n\t double y0 = yin-Y0;\n\t double z0 = zin-Z0;\n\t // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t // Determine which simplex we are in.\n\t int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\t int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\t if(x0>=y0) {\n\t if(y0>=z0)\n\t { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n\t }\n\t else { // x0<y0\n\t if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t }\n\t // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t // c = 1/6.\n\t double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t double y1 = y0 - j1 + G3;\n\t double z1 = z0 - k1 + G3;\n\t double x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n\t double y2 = y0 - j2 + 2.0*G3;\n\t double z2 = z0 - k2 + 2.0*G3;\n\t double x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n\t double y3 = y0 - 1.0 + 3.0*G3;\n\t double z3 = z0 - 1.0 + 3.0*G3;\n\t // Work out the hashed gradient indices of the four simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;\n\t int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;\n\t // Calculate the contribution from the four corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to stay just inside [-1,1]\n\t return 32.0*(n0 + n1 + n2 + n3);\n\t }","location":{"start":108,"insert":108,"offset":" ","indent":2},"item_type":"method","length":81},{"id":"66649cf3-bc59-1eac-834b-f4067cee6e5f","ancestors":["7491c7a9-7045-fbb4-194f-fd81eaaef6d9"],"type":"function","description":"calculates a Perlin noise value based on a set of coordinates, using a simplex-based algorithm to generate a continuous signal. The function returns a floating-point value between -1 and 1 that can be used for various applications such as procedural modeling or texture generation.","params":[{"name":"x","type_name":"double","description":"3D position of the point where the gradient is being computed at, and it is used to calculate the contribution from each simplex corner by projecting the point onto the coordinate axes.","complex_type":false},{"name":"y","type_name":"double","description":"2nd coordinate of the point in 3D space, which is used to calculate the dot product with the gradient vector at each corner of the simplex lattice and contribute to the final output value.","complex_type":false},{"name":"z","type_name":"double","description":"3D coordinate of the point in space where the gradient is being calculated, and it is used to compute the contribution from each simplex corner by projecting the vector components onto the (x,y,z) plane.","complex_type":false},{"name":"w","type_name":"double","description":"4th dimension of the simplex array, which is used to calculate the dot product with the gradient vector in each corner, contributing to the overall value of the function.","complex_type":false}],"returns":{"type_name":"double","description":"a scalar value between -1 and 1, representing the noise amplitude at a particular coordinate.","complex_type":false},"usage":{"language":"java","code":"import java.util.Random;\npublic class Example {\n\tpublic static void main(String[] args) {\n\t\t// Generate a random number between 0 and 1 using the Java Random class\n\t\tdouble value = new Random().nextDouble();\n\t\tSystem.out.println(\"Value: \" + value);\n\t}\n}\n","description":"\nIn this example, we use the `Random` class provided by the Java Standard Library to generate a random double between 0 and 1. This method is used to demonstrate that noise can be generated using code."},"name":"noise","code":"double noise(double x, double y, double z, double w) {\n\n\t // The skewing and unskewing factors are hairy again for the 4D case\n\t final double F4 = (Math.sqrt(5.0)-1.0)/4.0;\n\t final double G4 = (5.0-Math.sqrt(5.0))/20.0;\n\t double n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t double s = (x + y + z + w) * F4; // Factor for 4D skewing\n\t int i = fastfloor(x + s);\n\t int j = fastfloor(y + s);\n\t int k = fastfloor(z + s);\n\t int l = fastfloor(w + s);\n\t double t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\t double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t double Y0 = j - t;\n\t double Z0 = k - t;\n\t double W0 = l - t;\n\t double x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t double y0 = y - Y0;\n\t double z0 = z - Z0;\n\t double w0 = w - W0;\n\t // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t // To find out which of the 24 possible simplices we're in, we need to\n\t // determine the magnitude ordering of x0, y0, z0 and w0.\n\t // The method below is a good way of finding the ordering of x,y,z,w and\n\t // then find the correct traversal order for the simplex were in.\n\t // First, six pair-wise comparisons are performed between each possible pair\n\t // of the four coordinates, and the results are used to add up binary bits\n\t // for an integer index.\n\t int c1 = (x0 > y0) ? 32 : 0;\n\t int c2 = (x0 > z0) ? 16 : 0;\n\t int c3 = (y0 > z0) ? 8 : 0;\n\t int c4 = (x0 > w0) ? 4 : 0;\n\t int c5 = (y0 > w0) ? 2 : 0;\n\t int c6 = (z0 > w0) ? 1 : 0;\n\t int c = c1 + c2 + c3 + c4 + c5 + c6;\n\t int i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\t int i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\t int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t // impossible. Only the 24 indices which have non-zero entries make any sense.\n\t // We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t i1 = simplex[c][0]>=3 ? 1 : 0;\n\t j1 = simplex[c][1]>=3 ? 1 : 0;\n\t k1 = simplex[c][2]>=3 ? 1 : 0;\n\t l1 = simplex[c][3]>=3 ? 1 : 0;\n\t // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t i2 = simplex[c][0]>=2 ? 1 : 0;\n\t j2 = simplex[c][1]>=2 ? 1 : 0;\n\t k2 = simplex[c][2]>=2 ? 1 : 0;\n\t l2 = simplex[c][3]>=2 ? 1 : 0;\n\t // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t i3 = simplex[c][0]>=1 ? 1 : 0;\n\t j3 = simplex[c][1]>=1 ? 1 : 0;\n\t k3 = simplex[c][2]>=1 ? 1 : 0;\n\t l3 = simplex[c][3]>=1 ? 1 : 0;\n\t // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t double y1 = y0 - j1 + G4;\n\t double z1 = z0 - k1 + G4;\n\t double w1 = w0 - l1 + G4;\n\t double x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\n\t double y2 = y0 - j2 + 2.0*G4;\n\t double z2 = z0 - k2 + 2.0*G4;\n\t double w2 = w0 - l2 + 2.0*G4;\n\t double x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t double y3 = y0 - j3 + 3.0*G4;\n\t double z3 = z0 - k3 + 3.0*G4;\n\t double w3 = w0 - l3 + 3.0*G4;\n\t double x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\n\t double y4 = y0 - 1.0 + 4.0*G4;\n\t double z4 = z0 - 1.0 + 4.0*G4;\n\t double w4 = w0 - 1.0 + 4.0*G4;\n\t // Work out the hashed gradient indices of the five simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int ll = l & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\n\t int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\n\t int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\n\t // Calculate the contribution from the five corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);\n\t }\n\t double t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n\t if(t4<0) n4 = 0.0;\n\t else {\n\t t4 *= t4;\n\t n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);\n\t }\n\t // Sum up and scale the result to cover the range [-1,1]\n\t return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t }","location":{"start":190,"insert":190,"offset":" ","indent":2},"item_type":"method","length":119}]}}}