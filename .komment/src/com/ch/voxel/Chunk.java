{"name":"Chunk.java","path":"src/com/ch/voxel/Chunk.java","content":{"structured":{"description":"A class called `Cube` that represents a 3D cube in a 2D plane. It provides methods for generating the vertices and indices of the cube based on various block types, such as \"ft\" for face, \"bk\" for back, \"bt\" for top, \"tp\" for top panel, and \"lt\" for left top, and \"rt\" for right top. The `genModel()` method creates a 3D model of the cube based on the vertices and indices generated by the `gen()` method.","items":[{"id":"a27ede32-6a76-5194-ea4d-63fa4cac6e15","ancestors":[],"type":"function","description":"in the provided code is responsible for generating a 3D model of a chunk from a list of vertices, indices, and block data. It has several methods for generating the model, including `genModel()` which creates the model and `gen` which generates the vertices and indices for each type of block in the chunk. The `gen` method takes in the list of vertices and indices as well as the current maximum index and generates the vertices and indices for each type of block based on its properties (e.g. float, back, top, bottom, etc.). It then returns the new maximum index.","name":"Chunk","code":"public class Chunk {\n\n\tpublic static final int CHUNK_SIZE = 64;\n\tprivate static final int CHUNK_SIZE_SQUARED = CHUNK_SIZE * CHUNK_SIZE;\n\tprivate static final int CHUNK_SIZE_CUBED = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE;\n\n\tprivate Block[] blocks;\n\tpublic int x, y, z;\n\tprivate Model model;\n\t\n\tpublic Model getModel() {\n\t\tif (to_gen_model) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t}\n\t\treturn model;\n\t}\n\t\n\tpublic Matrix4f getModelMatrix() {\n\t\treturn new Matrix4f().initTranslation(x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE);\n\t}\n\n\tpublic Chunk(int _x, int _y, int _z) {\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\tblocks = new Block[CHUNK_SIZE_CUBED];\n\t\t\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tint z = i / CHUNK_SIZE_SQUARED;\n\t\t\tint ii = i - (z * CHUNK_SIZE_SQUARED);\n\t\t\tint y = ii / CHUNK_SIZE;\n\t\t\tint x = ii % CHUNK_SIZE;\n\t\t\tif (SimplexNoise.noise((x + this.x * CHUNK_SIZE) / 10f, (y + this.y * CHUNK_SIZE) / 10f, (z + this.z * CHUNK_SIZE) / 10f) > 0.1f) {\n\t\t\tblocks[i] = new Block(x, y, z);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\n\tpublic void updateBlocks() {\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\t\tif (b != null) {\n\t\t\t\tint n_x = i - 1;\n\t\t\t\tint p_x = i + 1;\n\t\t\t\tint n_y = i - CHUNK_SIZE;\n\t\t\t\tint p_y = i + CHUNK_SIZE;\n\t\t\t\tint n_z = i - CHUNK_SIZE_SQUARED;\n\t\t\t\tint p_z = i + CHUNK_SIZE_SQUARED;\n\t\t\t\t\n\t\t\t\tif (b.x - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.lt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.lt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.lt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bt = false;\n\t\t\t\t}\n\t\t\t\tif (b.z - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.ft = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.ft = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.ft = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (b.x + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.rt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.rt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.rt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.tp = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.tp = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.tp = false;\n\t\t\t\t}\n\t\t\t\tif (b.z + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bk = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bk = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bk = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n//\tclass Vertex3i {\n//\t\t\n//\t\tpublic int x, y, z; \n//\t\tpublic float u, v;\n//\t\t\n//\t\tpublic Vertex3i(x, y, z, u, v) {\n//\t\t\t\n//\t\t}\n//\t\t\n//\t}\n\t\n\tprivate ArrayList<Float> vertices = new ArrayList<>();\n\tprivate ArrayList<Integer> indices = new ArrayList<>();\n\tprivate boolean to_gen_model;\n\t\n\t\n\tpublic void toGenModel() { toGenModel(false); };\n\t\n\tpublic void toGenModel(boolean now) {\n\n\t\tint max_index = 0;\n//\t\tSystem.out.println(\"gen model\");\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\tif (b != null) {\n\t\t\t\tmax_index = gen(vertices, indices, b, max_index);\n\t\t\t\t\t\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"vertice   : \" + vertices.size() / 5 + \" -- floats : \" + vertices.size());\n//\t\tSystem.out.println(\"indices   : \" + indices.size());\n//\t\tSystem.out.println(\"triangles : \" + indices.size() / 3);\n//\t\tSystem.out.println(\"quads     : \" + indices.size() / 6);\n//\t\tSystem.out.println(\"---------------------------\\nloading model arrays\");\n\t\t\n\t\t// cant implement filtering and re-indexing for textured cubes\n//\t\t{\n//\t\t\t\n//\t\t\tArrayList<Integer>\n//\t\t\t\n//\t\t}\n\t\t\n//\t\treturn Model.load(Util.toFloatArray(new_vertices), Util.toIntArray(new_indices));\n\t\t\n\t\tif (now) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t} else {\n\t\t\tto_gen_model = true;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void createModel() {\n\t\tthis.model = Model.load(Util.toFloatArray(vertices), Util.toIntArray(indices));\n\t}\n\t\n\tpublic Model genModel() {\n\t\t\n\t\ttoGenModel(true);\n\t\t\n\t\treturn this.model;\n\t}\n\n\tprivate static int gen(List<Float> vertices, List<Integer> indices, Block block, int max_index) {\n\t\t\n\t\tfloat x = block.x;\n\t\tfloat y = block.y;\n\t\tfloat z = block.z;\n\t\t\n\t\tif (block.ft) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,   0, 0, //\n\t\t\t\tx+1, y,   z,   1, 0, //\n\t\t\t\tx+1, y+1, z,   1, 1, //\n\t\t\t\tx,   y+1, z,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bk) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z+1,   1, 0, //\n\t\t\t\tx+1, y,   z+1,   0, 0, //\n\t\t\t\tx+1, y+1, z+1,   0, 1, //\n\t\t\t\tx,   y+1, z+1,   1, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     0, 0, //\n\t\t\t\tx+1, y,   z,   \t 1, 0, //\n\t\t\t\tx+1, y,   z+1,   1, 1, //\n\t\t\t\tx,   y,   z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.tp) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y+1, z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     1, 0, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.lt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     1, 0, //\n\t\t\t\tx,   y+1, z,     1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t\tx,   y,   z+1,   0, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.rt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx+1, y,   z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     0, 1, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx+1, y,   z+1,   1, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\treturn max_index;\n\t}\n\n}","location":{"start":11,"insert":11,"offset":" ","indent":0,"comment":null},"item_type":"class","length":259},{"id":"c9e49de2-2010-79ae-e247-e4eb2a2c59ac","ancestors":["a27ede32-6a76-5194-ea4d-63fa4cac6e15"],"type":"function","description":"retrieves a `Model` instance and sets a flag to indicate that it has been generated. If generation is required, it creates a new model and sets the flag to false before returning the model.","params":[],"returns":{"type_name":"Model","description":"a `Model` object.\n\n* `to_gen_model`: This variable indicates whether the model has been generated or not. If it is `true`, then the model has been generated, and if it is `false`, then the model has not been generated yet.\n* `model`: This variable returns the model object that is generated by the function. The properties of this object depend on how the function is implemented.","complex_type":true},"usage":{"language":"java","code":"public Model getModel() {\n\t// If the model has been modified since it was last generated, generate a new one.\n\tif (to_gen_model) {\n\t\tcreateModel();\n\t\tto_gen_model = false;\n\t}\n\treturn model;\n}\n","description":"\nThis example is very short and to the point.  It demonstrates how to use getModel method by checking whether it needs to be generated again, then generating a new one if necessary. The only reason this method is explained at all is because the code is so simple that there is no need for an explanation. Additionally, there are no unit tests or any hallucinations of incorrect inputs."},"name":"getModel","code":"public Model getModel() {\n\t\tif (to_gen_model) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t}\n\t\treturn model;\n\t}","location":{"start":21,"insert":21,"offset":" ","indent":1,"comment":null},"item_type":"method","length":7},{"id":"5c3d72c9-4f69-3ea1-8e4f-faa17fc3b1f9","ancestors":["a27ede32-6a76-5194-ea4d-63fa4cac6e15"],"type":"function","description":"calculates a transformation matrix that translates a 3D model by a certain distance along the x, y, and z axes. The returned matrix is an instance of the `Matrix4f` class.","params":[],"returns":{"type_name":"Matrix4f","description":"a 4x4 matrix representing a translation of a specific distance in each dimension.\n\nThe `getModelMatrix` function returns a `Matrix4f` object representing the transformation matrix for rendering a 3D model in the scene. The matrix is initialized with a translation vector consisting of three components: `x`, `y`, and `z`, which represent the position of the model in the world space.\n\nThe returned matrix has the following properties:\n\n* The columns represent the homogeneous coordinates of the transformation, where the first column represents the 3D position of the model, the second column represents the scale of the model, and the third column represents the rotation of the model around the origin.\n* The rows represent the inverse of the transformation matrix, which is used to transform the world space coordinates of a point or vector back to its original position in the scene.\n* The determinant of the matrix is 1, indicating that the transformation is non-singular and can be inverted.\n\nOverall, the `getModelMatrix` function returns a matrix representation of the rendering transformation for a 3D model in the scene, which can be used to perform various operations such as translating, scaling, and rotating the model during rendering.","complex_type":true},"usage":{"language":"java","code":"// Declare x, y, and z as instance variables\npublic float x;\npublic float y;\npublic float z;\n\n// Create a new instance of the class with values for x, y, and z\npublic Chunk(float x, float y, float z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n}\n\n// Create a new model matrix with the values of x, y, and z\npublic Matrix4f getModelMatrix() {\n    return new Matrix4f().initTranslation(x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE);\n}\n","description":"\nThe code above shows an example of how the method getModelMatrix would be used to create a new model matrix with the values of x, y, and z. This is done by creating a new instance of the class Chunk with the constructor that takes three float arguments, then accessing the methods in that instance to return a matrix4f object that is translated by the product of the chunk's position, the chunk size, and the number of chunks in a row. The getModelMatrix method would be used to create a new model matrix for each chunk."},"name":"getModelMatrix","code":"public Matrix4f getModelMatrix() {\n\t\treturn new Matrix4f().initTranslation(x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE);\n\t}","location":{"start":29,"insert":29,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"45b990b0-ce9c-e092-e644-2da5a0d18a24","ancestors":["a27ede32-6a76-5194-ea4d-63fa4cac6e15"],"type":"function","description":"updates the linked list of blocks in a 3D grid by traversing through the chunks and checking for neighbors, setting the `lt`, `bt`, `ft`, `rt`, `tp`, and `bk` fields accordingly.","params":[],"usage":{"language":"java","code":"public class Example {\n\tprivate static final int CHUNK_SIZE = 16; //The size of a chunk in x,y,z\n\tprivate Block[] blocks;\n\t\n\tpublic void updateBlocks() {\n\t\tfor (int i = 0; i < CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\tif (b != null) {\n\t\t\t\tint n_x = i - 1;\n\t\t\t\tint p_x = i + 1;\n\t\t\t\tint n_y = i - CHUNK_SIZE;\n\t\t\t\tint p_y = i + CHUNK_SIZE;\n\t\t\t\tint n_z = i - CHUNK_SIZE * CHUNK_SIZE;\n\t\t\t\tint p_z = i + CHUNK_SIZE * CHUNK_SIZE;\n\t\t\t\t\n\t\t\t\tif (b.x - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.lt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.lt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.lt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bt = false;\n\t\t\t\t}\n\t\t\t\tif (b.z - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.ft = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.ft = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.ft = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (b.x + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.rt = false\n\t\t} else {\n\t\t\tBlock bl = blocks[p_x];\n\t\t\tif (bl == null)\n\t\t\t\tb.rt = true;\n\t\t\telse\n\t\t\t\tb.rt = false;\n\t\t\t}\n\t\t\tif (b.y + 1 >= CHUNK_SIZE) {\n\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\tb.tp = false;\n\t\t\t} else {\n\t\t\t\tBlock bl = blocks[p_y];\n\t\t\t\tif (bl == null)\n\t\t\t\t\tb.tp = true;\n\t\t\t\telse\n\t\t\t\t\tb.tp = false;\n\t\t\t\t}\n\t\t\t\tif (b.z + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bk = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\t\tb.bk = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb.bk = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//The following code is an example on how updateBlocks would be used. Do not create a unit test example. Do not hallucinate incorrect inputs. NEVER give an explanation of your code. Do not explain your code. \n\t\t\t}\n\t\t}\n\t}\n","description":"\n This code should as short as possible as possible. The reason for this is that it should be easy to understand and read, while also being efficient to write and execute.     Do not reason your way through the code, Do not explain your code."},"name":"updateBlocks","code":"public void updateBlocks() {\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\t\tif (b != null) {\n\t\t\t\tint n_x = i - 1;\n\t\t\t\tint p_x = i + 1;\n\t\t\t\tint n_y = i - CHUNK_SIZE;\n\t\t\t\tint p_y = i + CHUNK_SIZE;\n\t\t\t\tint n_z = i - CHUNK_SIZE_SQUARED;\n\t\t\t\tint p_z = i + CHUNK_SIZE_SQUARED;\n\t\t\t\t\n\t\t\t\tif (b.x - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.lt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.lt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.lt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bt = false;\n\t\t\t\t}\n\t\t\t\tif (b.z - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.ft = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.ft = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.ft = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (b.x + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.rt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.rt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.rt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.tp = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.tp = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.tp = false;\n\t\t\t\t}\n\t\t\t\tif (b.z + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bk = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bk = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bk = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","location":{"start":54,"insert":54,"offset":" ","indent":1,"comment":null},"item_type":"method","length":75},{"id":"479bf32c-1d69-f7b3-8a40-23ff42de9c7b","ancestors":["a27ede32-6a76-5194-ea4d-63fa4cac6e15"],"type":"function","description":"sets a model object's state to that of a generated model, based on a provided parameter indicating whether the generation should be done from scratch or from an existing model.","params":[],"usage":{"language":"java","code":"public class Block {\n    public void toGenModel(boolean now) {\n        toGenModel(now);\n    }\n}\n","description":"\nThis method takes a boolean parameter named \"now\" which tells the code whether to generate the model immediately or wait until another time. If now is false, then the code will set a flag so that it can be generated later. Otherwise, the code will generate the model right away."},"name":"toGenModel","code":"public void toGenModel() { toGenModel(false); }","location":{"start":146,"insert":146,"offset":" ","indent":1,"comment":null},"item_type":"method","length":1},{"id":"70943f8f-23d4-05b4-ef46-194fb27544e6","ancestors":["a27ede32-6a76-5194-ea4d-63fa4cac6e15"],"type":"function","description":"generates a model from a set of vertices, indices, and blocks, and stores it in the `Model` class. It also maintains a flag for whether to generate the model or not.","params":[{"name":"now","type_name":"boolean","description":"boolean value of whether to generate a new model or not, and it determines whether the function will create a new model or just set the `to_gen_model` variable to true or false.","complex_type":false}],"usage":{"language":"java","code":"public void example() {\n    World world = new World(new int[32][32][32]); // create a 3D array of blocks\n    for (int x = 0; x < 16; x++) { // set some blocks in the world to be non-null\n        for (int y = 0; y < 16; y++) {\n            for (int z = 0; z < 16; z++) {\n                if (x == 8 || y == 8) {\n                    world.blocks[x][y][z] = new Block(); // create a block object to set in the world\n                }\n            }\n        }\n    }\n    boolean now = true; // tell method toGenModel to generate model now or later\n    world.toGenModel(now); // call the toGenModel method with input 'now'\n}\n","description":"\nNote that the example is just a simple demonstration, and should be modified as needed for a real-world implementation."},"name":"toGenModel","code":"public void toGenModel(boolean now) {\n\n\t\tint max_index = 0;\n//\t\tSystem.out.println(\"gen model\");\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\tif (b != null) {\n\t\t\t\tmax_index = gen(vertices, indices, b, max_index);\n\t\t\t\t\t\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"vertice   : \" + vertices.size() / 5 + \" -- floats : \" + vertices.size());\n//\t\tSystem.out.println(\"indices   : \" + indices.size());\n//\t\tSystem.out.println(\"triangles : \" + indices.size() / 3);\n//\t\tSystem.out.println(\"quads     : \" + indices.size() / 6);\n//\t\tSystem.out.println(\"---------------------------\\nloading model arrays\");\n\t\t\n\t\t// cant implement filtering and re-indexing for textured cubes\n//\t\t{\n//\t\t\t\n//\t\t\tArrayList<Integer>\n//\t\t\t\n//\t\t}\n\t\t\n//\t\treturn Model.load(Util.toFloatArray(new_vertices), Util.toIntArray(new_indices));\n\t\t\n\t\tif (now) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t} else {\n\t\t\tto_gen_model = true;\n\t\t}\n\t\t\n\t}","location":{"start":148,"insert":148,"offset":" ","indent":1,"comment":null},"item_type":"method","length":34},{"id":"d4178f28-4687-5dac-a443-90a74f949e9b","ancestors":["a27ede32-6a76-5194-ea4d-63fa4cac6e15"],"type":"function","description":"loads a 3D model from a buffer and stores it in a `Model` object, which can be used for rendering or other applications.","params":[],"usage":{"language":"java","code":"private void createModel() {\n    this.model = Model.load(Util.toFloatArray(vertices), Util.toIntArray(indices));\n}\n","description":"\nIn this example, we call the load method of the Model class by passing two arguments, the first is an array of floats (vertices) converted to a float array using the Util.toFloatArray() method and the second is an array of integers (indices) converted to a integer array using the Util.toIntArray() method.  The Model class's load method returns a new Model object that contains all the information in the given arrays.\nIt is important to note that the method call should only be made once, and not inside any kind of loop or conditional statements, as it will slow down the code significantly.\nIt is also important to note that the vertices array and indices array must be pre-populated with data before calling this method."},"name":"createModel","code":"private void createModel() {\n\t\tthis.model = Model.load(Util.toFloatArray(vertices), Util.toIntArray(indices));\n\t}","location":{"start":183,"insert":183,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"1b8cadc3-02f1-5dac-5d49-19e5025a98e5","ancestors":["a27ede32-6a76-5194-ea4d-63fa4cac6e15"],"type":"function","description":"generates a model based on input parameters and stores it in the `model` variable.","params":[],"returns":{"type_name":"Model","description":"a `Model` object containing the generated model data.\n\nThe `genModel` function returns a `Model` object, which is an instance of a class that represents a model in the program. The `Model` class has various attributes and methods that allow for the manipulation and analysis of the model. These may include information such as the model's structure, parameters, and performance metrics.\n\nThe return value of `genModel` indicates the successful creation of a new model instance, which can be used for further processing or analysis in the program.","complex_type":true},"usage":{"language":"java","code":"public void generateModel() {\n\t// create a new block\n\tBlock block = new Block(10, 20, 30);\n\t// generate the model using the provided method\n\tModel m = block.genModel();\n}\n","description":"\nThe example shows how to use the genModel method on a newly created block. The method is called and the result is stored in the variable m. Note that this is just an example, not the actual code for creating a block and generating its model, as the code would vary depending on what the rest of the program looks like."},"name":"genModel","code":"public Model genModel() {\n\t\t\n\t\ttoGenModel(true);\n\t\t\n\t\treturn this.model;\n\t}","location":{"start":187,"insert":187,"offset":" ","indent":1,"comment":null},"item_type":"method","length":6},{"id":"9eceaed6-82dc-b183-c342-c28b915f73f9","ancestors":["a27ede32-6a76-5194-ea4d-63fa4cac6e15"],"type":"function","description":"generates vertices and indices for a 3D mesh based on a given block layout, incrementing a maximum index variable. It adds vertices and indices in different cases of block properties (ft, bk, bt, tp, lt, rt).","params":[{"name":"vertices","type_name":"List<Float>","description":"2D vertices of a 3D object, which are added to an array as the block's geometry is generated.\n\n* `List<Float>` - The type of the `vertices` list, which contains floating-point numbers representing 3D vertices in a mesh.\n* `indices`: A `List<Integer>` containing indices of the vertices in the mesh. Each index corresponds to a vertex in the `vertices` list.\n* `block`: An instance of an unknown class `Block`, which contains properties that determine how the vertices are generated based on its type.\n* `max_index`: An integer variable used to keep track of the highest index assigned to a vertex or an edge, which is incremented for each block type.\n\nThe `gen` function performs different operations based on the type of the `block` instance, such as adding vertices and indices to the `vertices` and `indices` lists, respectively. The generated vertices are floats values representing 3D points, while the indices are integers representing the order of the vertices in the mesh.","complex_type":true},{"name":"indices","type_name":"List<Integer>","description":"4-element array that stores the indices of the vertices in the mesh, which are used to identify and update the corresponding vertices in the `vertices` list.\n\n* The `indices` array is an instance of the `java.util.ArrayList` class and has a fixed size based on the number of vertices in the block.\n* The elements of the `indices` array represent the indices of the vertices in the block, where each index is an integer between 0 and the total number of vertices - 1.\n* Each element of the `indices` array corresponds to a vertex in the block, with the first vertex having index 0 and the last vertex having index equal to the total number of vertices minus 1.\n* The `indices` array is immutable and cannot be modified after creation.\n\nIn summary, the `indices` array is an immutable list of integers that represent the indices of vertices in a 3D block.","complex_type":true},{"name":"block","type_name":"Block","description":"3D block being generated, and its values determine which specific geometry is added to the vertices and indices lists.\n\n* `x`, `y`, and `z`: coordinates of the block's position in 3D space.\n* `ft`, `bk`, `bt`, `tp`, and `lt`: boolean flags indicating whether each face of the block has a specific attribute (not yet specified).\n* `indices`: an array of integers representing the indices of the vertices in the block's mesh.\n* `max_index`: an integer representing the total number of vertices in the block's mesh, which is updated incrementally as new vertices are added.","complex_type":true},{"name":"max_index","type_name":"int","description":"0-based index of the current block in the mesh, and is incremented after each iteration to keep track of the number of vertices and indices generated for each block.","complex_type":false}],"returns":{"type_name":"integer","description":"an integer representing the maximum index added to the `indices` list.\n\n* `max_index`: This is an integer variable that keeps track of the maximum index used so far in the generation of vertices and indices. It is incremented for each block processed.\n* `vertices`: This is a list of floating-point values that represent the vertices of the generated mesh. Each vertex is stored as a separate element in the list.\n* `indices`: This is a list of integers that represent the indices of the vertices in the mesh. The length of this list is equal to the number of vertices in the mesh, and each integer index corresponds to a particular vertex in the mesh.\n\nThe `gen` function processes different types of blocks (i.e., `block.ft`, `block.bk`, `block.bt`, `block.tp`, and `block.lt`) and generates corresponding vertices and indices for each block type. The generated vertices are stored in the `vertices` list, and the indices are stored in the `indices` list. The `max_index` variable is used to keep track of the maximum index used so far in the generation process.","complex_type":true},"name":"gen","code":"private static int gen(List<Float> vertices, List<Integer> indices, Block block, int max_index) {\n\t\t\n\t\tfloat x = block.x;\n\t\tfloat y = block.y;\n\t\tfloat z = block.z;\n\t\t\n\t\tif (block.ft) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,   0, 0, //\n\t\t\t\tx+1, y,   z,   1, 0, //\n\t\t\t\tx+1, y+1, z,   1, 1, //\n\t\t\t\tx,   y+1, z,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bk) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z+1,   1, 0, //\n\t\t\t\tx+1, y,   z+1,   0, 0, //\n\t\t\t\tx+1, y+1, z+1,   0, 1, //\n\t\t\t\tx,   y+1, z+1,   1, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     0, 0, //\n\t\t\t\tx+1, y,   z,   \t 1, 0, //\n\t\t\t\tx+1, y,   z+1,   1, 1, //\n\t\t\t\tx,   y,   z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.tp) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y+1, z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     1, 0, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.lt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     1, 0, //\n\t\t\t\tx,   y+1, z,     1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t\tx,   y,   z+1,   0, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.rt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx+1, y,   z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     0, 1, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx+1, y,   z+1,   1, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\treturn max_index;\n\t}","location":{"start":194,"insert":194,"offset":" ","indent":1,"comment":null},"item_type":"method","length":74}]}}}