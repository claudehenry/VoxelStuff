{"name":"Chunk.java","path":"src/com/ch/voxel/Chunk.java","content":{"structured":{"description":"A 3D modeling application that can generate a cube-shaped model from a set of textured faces. The code uses various algorithms to filter and re-index the vertices and indices of the cube in order to create a smooth and efficient model. Additionally, the code provides methods for generating new models from scratch or loading existing models into the application. Overall, the code is designed to handle complex 3D models with textured faces and efficiently render them for visualization or other applications.","items":[{"id":"e47dfd9e-8fa5-548b-fe47-2230433a9517","ancestors":[],"type":"function","description":"TODO","name":"Chunk","code":"public class Chunk {\n\n\tpublic static final int CHUNK_SIZE = 64;\n\tprivate static final int CHUNK_SIZE_SQUARED = CHUNK_SIZE * CHUNK_SIZE;\n\tprivate static final int CHUNK_SIZE_CUBED = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE;\n\n\tprivate Block[] blocks;\n\tpublic int x, y, z;\n\tprivate Model model;\n\t\n\tpublic Model getModel() {\n\t\tif (to_gen_model) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t}\n\t\treturn model;\n\t}\n\t\n\tpublic Matrix4f getModelMatrix() {\n\t\treturn new Matrix4f().initTranslation(x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE);\n\t}\n\n\tpublic Chunk(int _x, int _y, int _z) {\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\tblocks = new Block[CHUNK_SIZE_CUBED];\n\t\t\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tint z = i / CHUNK_SIZE_SQUARED;\n\t\t\tint ii = i - (z * CHUNK_SIZE_SQUARED);\n\t\t\tint y = ii / CHUNK_SIZE;\n\t\t\tint x = ii % CHUNK_SIZE;\n\t\t\tif (SimplexNoise.noise((x + this.x * CHUNK_SIZE) / 10f, (y + this.y * CHUNK_SIZE) / 10f, (z + this.z * CHUNK_SIZE) / 10f) > 0.1f) {\n\t\t\tblocks[i] = new Block(x, y, z);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\n\tpublic void updateBlocks() {\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\t\tif (b != null) {\n\t\t\t\tint n_x = i - 1;\n\t\t\t\tint p_x = i + 1;\n\t\t\t\tint n_y = i - CHUNK_SIZE;\n\t\t\t\tint p_y = i + CHUNK_SIZE;\n\t\t\t\tint n_z = i - CHUNK_SIZE_SQUARED;\n\t\t\t\tint p_z = i + CHUNK_SIZE_SQUARED;\n\t\t\t\t\n\t\t\t\tif (b.x - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.lt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.lt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.lt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bt = false;\n\t\t\t\t}\n\t\t\t\tif (b.z - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.ft = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.ft = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.ft = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (b.x + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.rt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.rt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.rt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.tp = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.tp = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.tp = false;\n\t\t\t\t}\n\t\t\t\tif (b.z + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bk = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bk = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bk = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n//\tclass Vertex3i {\n//\t\t\n//\t\tpublic int x, y, z; \n//\t\tpublic float u, v;\n//\t\t\n//\t\tpublic Vertex3i(x, y, z, u, v) {\n//\t\t\t\n//\t\t}\n//\t\t\n//\t}\n\t\n\tprivate ArrayList<Float> vertices = new ArrayList<>();\n\tprivate ArrayList<Integer> indices = new ArrayList<>();\n\tprivate boolean to_gen_model;\n\t\n\t\n\tpublic void toGenModel() { toGenModel(false); };\n\t\n\tpublic void toGenModel(boolean now) {\n\n\t\tint max_index = 0;\n//\t\tSystem.out.println(\"gen model\");\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\tif (b != null) {\n\t\t\t\tmax_index = gen(vertices, indices, b, max_index);\n\t\t\t\t\t\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"vertice   : \" + vertices.size() / 5 + \" -- floats : \" + vertices.size());\n//\t\tSystem.out.println(\"indices   : \" + indices.size());\n//\t\tSystem.out.println(\"triangles : \" + indices.size() / 3);\n//\t\tSystem.out.println(\"quads     : \" + indices.size() / 6);\n//\t\tSystem.out.println(\"---------------------------\\nloading model arrays\");\n\t\t\n\t\t// cant implement filtering and re-indexing for textured cubes\n//\t\t{\n//\t\t\t\n//\t\t\tArrayList<Integer>\n//\t\t\t\n//\t\t}\n\t\t\n//\t\treturn Model.load(Util.toFloatArray(new_vertices), Util.toIntArray(new_indices));\n\t\t\n\t\tif (now) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t} else {\n\t\t\tto_gen_model = true;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void createModel() {\n\t\tthis.model = Model.load(Util.toFloatArray(vertices), Util.toIntArray(indices));\n\t}\n\t\n\tpublic Model genModel() {\n\t\t\n\t\ttoGenModel(true);\n\t\t\n\t\treturn this.model;\n\t}\n\n\tprivate static int gen(List<Float> vertices, List<Integer> indices, Block block, int max_index) {\n\t\t\n\t\tfloat x = block.x;\n\t\tfloat y = block.y;\n\t\tfloat z = block.z;\n\t\t\n\t\tif (block.ft) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,   0, 0, //\n\t\t\t\tx+1, y,   z,   1, 0, //\n\t\t\t\tx+1, y+1, z,   1, 1, //\n\t\t\t\tx,   y+1, z,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bk) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z+1,   1, 0, //\n\t\t\t\tx+1, y,   z+1,   0, 0, //\n\t\t\t\tx+1, y+1, z+1,   0, 1, //\n\t\t\t\tx,   y+1, z+1,   1, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     0, 0, //\n\t\t\t\tx+1, y,   z,   \t 1, 0, //\n\t\t\t\tx+1, y,   z+1,   1, 1, //\n\t\t\t\tx,   y,   z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.tp) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y+1, z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     1, 0, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.lt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     1, 0, //\n\t\t\t\tx,   y+1, z,     1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t\tx,   y,   z+1,   0, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.rt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx+1, y,   z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     0, 1, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx+1, y,   z+1,   1, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\treturn max_index;\n\t}\n\n}","location":{"start":11,"insert":11,"offset":" ","indent":0},"item_type":"class","length":259},{"id":"1d6f80be-3a6a-76a0-2845-13e6269fddb2","ancestors":["e47dfd9e-8fa5-548b-fe47-2230433a9517"],"type":"function","description":"retrieves a `Model` object from a storage location and returns it to the caller. If the `to_gen_model` flag is set, the function creates a new model instance instead of returning an existing one.","params":[],"returns":{"type_name":"Model","description":"a `Model` object.\n\nThe `model` variable is an instance of the `Model` class, which represents a mathematical model. The model can be manipulated and used for various purposes, such as solving optimization problems or performing statistical analysis.\n\nThe `to_gen_model` field indicates whether the model was generated by the function or not. If `to_gen_model` is `true`, then the model was generated by the function, and if it is `false`, then the model was already available before calling the function.\n\nNo other properties or attributes of the returned output are mentioned in the code snippet provided.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Model model = new Model();\n    for (int i = 0; i < 10; i++) {\n        Block block = new Block();\n        model.addBlock(block);\n    }\n    System.out.println(\"Model: \" + model.getModel());\n}\n","description":"\nThis program will print the model that was generated by the method addBlock in the Model class. In this example, 10 blocks are added to the model and then printed. The output would look something like this:\n\n"},"name":"getModel","code":"public Model getModel() {\n\t\tif (to_gen_model) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t}\n\t\treturn model;\n\t}","location":{"start":21,"insert":21,"offset":" ","indent":1},"item_type":"method","length":7},{"id":"79f936d5-1db5-fa94-8f4b-f775b0fcbb74","ancestors":["e47dfd9e-8fa5-548b-fe47-2230433a9517"],"type":"function","description":"computes and returns a transformation matrix representing the position and scale of an object in 3D space.","params":[],"returns":{"type_name":"Matrix4f","description":"a transformation matrix representing a translation of a certain magnitude in the x, y, and z directions.\n\n1. The matrix is a `Matrix4f` object representing a 4D transformation matrix.\n2. The matrix is initialized with a translation vector consisting of three components (x, y, and z) multiplied by the chunk size (CHUNK_SIZE).\n3. The resulting matrix represents a translation of the origin of the coordinate system by the specified amount in each dimension.","complex_type":true},"usage":{"language":"java","code":"public Matrix4f getModelMatrix() {\n\treturn new Matrix4f().initTranslation(x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE);\n}\n","description":"\nThis code will generate a matrix which can be used to move the object along with x and z coordinates. This will help to apply transformations on the object. The method returns an instance of Matrix4f class that has been initialized with translation vector."},"name":"getModelMatrix","code":"public Matrix4f getModelMatrix() {\n\t\treturn new Matrix4f().initTranslation(x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE);\n\t}","location":{"start":29,"insert":29,"offset":" ","indent":1},"item_type":"method","length":3},{"id":"487b3d90-79c0-77a6-484b-ce43dbb45414","ancestors":["e47dfd9e-8fa5-548b-fe47-2230433a9517"],"type":"function","description":"updates the blocks in a 3D grid by checking and updating their neighbors based on chunk size. It also checks for boundary conditions and sets appropriate flags.","params":[],"usage":{"language":"java","code":"public class Chunk {\n\tfinal int CHUNK_SIZE = 16;\n    final int CHUNK_SIZE_CUBED = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE;\n    final int CHUNK_SIZE_SQUARED = CHUNK_SIZE * CHUNK_SIZE;\n\tBlock[] blocks;\n\t\n\tpublic Chunk() {\n\t\tblocks = new Block[CHUNK_SIZE_CUBED];\n\t}\n\t\n\tpublic void updateBlocks() {\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\tif (b != null) {\n\t\t\t\tint n_x = i - 1;\n\t\t\t\tint p_x = i + 1;\n\t\t\t\tint n_y = i - CHUNK_SIZE;\n\t\t\t\tint p_y = i + CHUNK_SIZE;\n\t\t\t\tint n_z = i - CHUNK_SIZE_SQUARED;\n\t\t\t\tint p_z = i + CHUNK_SIZE_SQUARED;\n\t\t\t\t\n\t\t\t\tif (b.x - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.lt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.lt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.lt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bt = false;\n\t\t\t\t}\n\t\t\t\tif (b.z - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.ft = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.ft = true;\n\t\t\t\t\telse\n\t\t\tbkjklkjkjkjkjkjkjkjkjkjkl\n                        b.bk = false;\n\t\t}\n\t\tif (b.x + 1 >= CHUNK_SIZE) {\n\t\t\tBlock bl = blocks[p_x];\n\t\t\tb.rt = false;\n\t\t} else {\n\t\t\tbl = blocks[p_x];\n\t\t\tif (bl == null) {\n\t\t\t\tb.rt = true;\n\t\t\t} else {\n\t\t\t\tb.rt = false;\n\t\t\t}\n\t\t}\n\n\t\tif (b.y + 1 >= CHUNK_SIZE) {\n\t\t\tbl = blocks[p_y];\n\t\t\tb.tp = false;\n\t\t} else {\n\t\t\tbl = blocks[p_y];\n\t\t\tif (bl == null) {\n\t\t\t\tb.tp = true;\n\t\t\t} else {\n\t\t\t\tb.tp = false;\n\t\t\t}\n\t\t}\n\n\t\tif (b.z + 1 >= CHUNK_SIZE) {\n\t\t\tbl = blocks[p_z];\n\t\t\tb.bk = false;\n\t\t} else {\n\t\t\tbl = blocks[p_z];\n\t\t\tif (bl == null) {\n\t\t\t\tb.bk = true;\n\t\t\t} else {\n\t\t\t\tb.bk = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// TODO: check neighbor chunk\n\t\t\n\t\t// TODO: setBlocks\n\t}\n}\n","description":"\nHere is an example of how the method would be used: \n\npublic class Chunk {\n    public static final int CHUNK_SIZE = 16;\n    public static final int CHUNK_SIZE_CUBED = CHUNK_SIZE *CHUNK_SIZE*CHUNK_SIZE;\n    public static final int CHUNK_SIZE_SQUARED = CHUNK_SIZE * CHUNK_SIZE;\n    public Block[] blocks;\n    \n    public Chunk() {\n        blocks = new Block[CHUNK_SIZE_CUBED];\n    }\n    \n    public void updateBlocks() {\n        for (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n            Block b = blocks[i];\n            if (b != null) {\n                int n_x = i - 1;\n                int p_x = i + 1;\n                int n_y = i - CHUNK_SIZE;\n                int p_y = i + CHUNK_SIZE;\n                int n_z = i - CHUNK_SIZE_SQUARED;\n                int p_z = i + CHUNK_SIZE_SQUARED;\n                \n                if (b.x - 1 < 0) {\n                    b.lt = false;\n                } else {\n                    Block bl = blocks[n_x];\n                    \n                    if (bl == null) {\n                        b.lt = true;\n                    } else {\n                        b.lt = false;\n                    }\n                }\n                \n                if (b.y - 1 < 0) {\n                    b.bt = false;\n                } else {\n                    bl = blocks[n_y];\n                    \n                    if (bl == null) {\n                        b.bt = true;\n                    } else {\n                        b.bt = false;\n                    }\n                }\n                \n                if (b.z - 1 < 0) {\n                    b.ft = false;\n                } else {\n                    bl = blocks[n_z];\n                    \n                    if (bl == null) {\n                        b.ft = true;\n                    } else {\n                        b.ft = false;\n                    }\n                }\n                \n                if (b.x + 1 >= CHUNK_SIZE) {\n                    bl = blocks[p_x];\n                    \n                    if (bl == null) {\n                        b.rt = true;\n                    } else {\n                        b.rt = false;\n                    }\n                }\n                \n                if (b.y + 1 >= CHUNK_SIZE) {\n                    bl = blocks[p_y];\n                    \n                    if (bl == null) {\n                        b.tp = true;\n                    } else {\n                        b.tp = false;\n                    }\n                }\n                \n                if (b.z + 1 >= CHUNK_SIZE) {\n                    bl = blocks[p_z];\n                    \n                    if (bl == null) {\n                        b.bk = true;\n                    } else {\n                        b.bk = false;\n                    }\n                }\n            }\n        }\n    }\n}\n"},"name":"updateBlocks","code":"public void updateBlocks() {\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\t\tif (b != null) {\n\t\t\t\tint n_x = i - 1;\n\t\t\t\tint p_x = i + 1;\n\t\t\t\tint n_y = i - CHUNK_SIZE;\n\t\t\t\tint p_y = i + CHUNK_SIZE;\n\t\t\t\tint n_z = i - CHUNK_SIZE_SQUARED;\n\t\t\t\tint p_z = i + CHUNK_SIZE_SQUARED;\n\t\t\t\t\n\t\t\t\tif (b.x - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.lt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.lt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.lt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bt = false;\n\t\t\t\t}\n\t\t\t\tif (b.z - 1 < 0) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.ft = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[n_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.ft = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.ft = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (b.x + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.rt = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_x];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.rt = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.rt = false;\n\t\t\t\t}\n\t\t\t\tif (b.y + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.tp = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_y];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.tp = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.tp = false;\n\t\t\t\t}\n\t\t\t\tif (b.z + 1 >= CHUNK_SIZE) {\n\t\t\t\t\t//TODO: check neighbor chunk\n\t\t\t\t\tb.bk = false;\n\t\t\t\t} else {\n\t\t\t\t\tBlock bl = blocks[p_z];\n\t\t\t\t\tif (bl == null)\n\t\t\t\t\t\tb.bk = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb.bk = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","location":{"start":54,"insert":54,"offset":" ","indent":1},"item_type":"method","length":75},{"id":"1c3e535d-97ef-df92-d84b-1985fa540737","ancestors":["e47dfd9e-8fa5-548b-fe47-2230433a9517"],"type":"function","description":"transforms a given model into a Generated Model, which can be used for further processing or analysis.","params":[],"usage":{"language":"java","code":"public class Block {\n    private boolean ft;\n    private boolean bk;\n    private boolean tp;\n    private boolean lt;\n    private boolean rt;\n}\n","description":"\nHere is the implementation of toGenModel(boolean now) method:\n"},"name":"toGenModel","code":"public void toGenModel() { toGenModel(false); }","location":{"start":146,"insert":146,"offset":" ","indent":1},"item_type":"method","length":1},{"id":"9fb5d8e5-7c51-539a-1a4b-a1ed2d0a5b32","ancestors":["e47dfd9e-8fa5-548b-fe47-2230433a9517"],"type":"function","description":"generates a 3D model by recursively dividing a large chunk of vertices and indices into smaller chunks, processes them, and repeats the process until the desired level of detail is reached. It also filters out unnecessary data and re-indexes the remaining vertices and indices for efficient storage and access.","params":[{"name":"now","type_name":"boolean","description":"boolean value that determines whether to generate a new model or not.","complex_type":false}],"usage":{"language":"java","code":"boolean now = true; // This variable allows us to choose whether we want the method to return immediately or wait until it has finished generating the model. We set this to true in this example, so that the method will return immediately after it is called.\ntoGenModel(now); // This line of code calls the toGenModel method and passes the boolean value now as an argument.\n","description":"\nThis would generate the model instantly because we set now to be true."},"name":"toGenModel","code":"public void toGenModel(boolean now) {\n\n\t\tint max_index = 0;\n//\t\tSystem.out.println(\"gen model\");\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\tif (b != null) {\n\t\t\t\tmax_index = gen(vertices, indices, b, max_index);\n\t\t\t\t\t\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"vertice   : \" + vertices.size() / 5 + \" -- floats : \" + vertices.size());\n//\t\tSystem.out.println(\"indices   : \" + indices.size());\n//\t\tSystem.out.println(\"triangles : \" + indices.size() / 3);\n//\t\tSystem.out.println(\"quads     : \" + indices.size() / 6);\n//\t\tSystem.out.println(\"---------------------------\\nloading model arrays\");\n\t\t\n\t\t// cant implement filtering and re-indexing for textured cubes\n//\t\t{\n//\t\t\t\n//\t\t\tArrayList<Integer>\n//\t\t\t\n//\t\t}\n\t\t\n//\t\treturn Model.load(Util.toFloatArray(new_vertices), Util.toIntArray(new_indices));\n\t\t\n\t\tif (now) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t} else {\n\t\t\tto_gen_model = true;\n\t\t}\n\t\t\n\t}","location":{"start":148,"insert":148,"offset":" ","indent":1},"item_type":"method","length":34},{"id":"22d940c8-a7f0-34a6-aa4b-0be283876217","ancestors":["e47dfd9e-8fa5-548b-fe47-2230433a9517"],"type":"function","description":"loads a 3D model from a file into a `Model` object, using the provided vertices and indices as input.","params":[],"usage":{"language":"java","code":"private void createModel() {\n    this.model = Model.load(Util.toFloatArray(vertices), Util.toIntArray(indices));\n}\n","description":"\nThe above code creates a model object using the vertices and indices list created earlier. The method then assigns it to this.model, which would be the model property of the class that is calling the method. This way the model can be used later in the program to render or manipulate the 3D objects."},"name":"createModel","code":"private void createModel() {\n\t\tthis.model = Model.load(Util.toFloatArray(vertices), Util.toIntArray(indices));\n\t}","location":{"start":183,"insert":183,"offset":" ","indent":1},"item_type":"method","length":3},{"id":"ca123db2-ecfe-b7b2-4149-f06152d76e64","ancestors":["e47dfd9e-8fa5-548b-fe47-2230433a9517"],"type":"function","description":"generates a model based on input `toGenModel`. It returns the generated model.","params":[],"returns":{"type_name":"Model","description":"a `Model` object representing the generated model.\n\n* `model`: A `Model` object representing the generated model.\n* `toGenModel(true)`: A method called to initialize the model generation process with the given parameter.\n\nThese details provide a brief understanding of the inner workings of the `genModel` function, without including any unnecessary information or summaries.","complex_type":true},"usage":{"language":"java","code":"BlockGen b = new BlockGen();\nb.genModel(true);\n","description":"\nThis code calls the toGenModel method with a parameter of true, which will cause the model to generate immediately rather than waiting until another method is called later.  The return value is then stored in a variable named \"b\" which is of type BlockGen.  This allows the generated model to be used by other methods and classes."},"name":"genModel","code":"public Model genModel() {\n\t\t\n\t\ttoGenModel(true);\n\t\t\n\t\treturn this.model;\n\t}","location":{"start":187,"insert":187,"offset":" ","indent":1},"item_type":"method","length":6},{"id":"d65673fa-5418-2298-934f-de53f66cb399","ancestors":["e47dfd9e-8fa5-548b-fe47-2230433a9517"],"type":"function","description":"generates new vertices and indices for a 3D mesh based on the given block's topology. It recursively calls itself for each face of the block, adding vertices and indices to the mesh. The function returns the total number of indices added.","params":[{"name":"vertices","type_name":"List<Float>","description":"2D coordinates of the vertices that make up the block, which are added to an array for later use in rendering the 3D model.\n\n* `vertices`: A list of floating-point values representing 3D vertices in the mesh.\n* `indices`: A list of integer values representing the indices of the vertices in the mesh.\n* `block`: An instance of a `Block` class, which contains information about the current block being generated. The properties of the block include `x`, `y`, `z`, `ft`, `bk`, `bt`, `tp`, and `lt`. These properties determine the type of geometry that is generated for each vertex in the mesh.\n* `max_index`: An integer variable that keeps track of the total number of vertices generated so far. It is updated incrementally as new vertices are generated for each block.","complex_type":true},{"name":"indices","type_name":"List<Integer>","description":"4-element integer array that stores the indices of the vertices in the mesh, which are added to the `vertices` list and used to calculate the next index value for the `max_index` variable.\n\n* `new int[] {0, 1, 2, 0, 2, 3}`: This is an array of integers containing the starting indices for each of the four blocks.\n* `indices.add(max_index + i)`: For each element in the `indices` array, a new index is added to the list, where the index is the sum of the current maximum index and the corresponding starting index from the `new int[]`.\n* `return max_index`: The function returns the maximum index generated after deserializing the input `indices`.","complex_type":true},{"name":"block","type_name":"Block","description":"3D block of the scene being generated, and its values determine which triangles are added to the list of vertices and indices.\n\n* `x`, `y`, and `z`: These are the coordinates of the block's position in 3D space.\n* `ft`, `bk`, `bt`, `tp`, and `lt`: These are boolean values indicating whether each face of the block has a specific property (e.g., floating or non-floating).\n* `indices`: An array of integers that corresponds to the vertices of the block.\n* `max_index`: A variable that keeps track of the total number of vertices and indices generated so far.","complex_type":true},{"name":"max_index","type_name":"int","description":"index of the last vertex or index that has been processed and added to the `vertices` and `indices` lists, respectively, before returning the value at the end of the function.","complex_type":false}],"returns":{"type_name":"integer","description":"an integer representing the maximum index added to the `indices` list.\n\n* The `max_index` variable is used to keep track of the index of the current vertex or index in the `indices` list. It starts from 0 and increases by 4 for each block generated.\n* The `vertices` list stores the coordinates of the vertices in the block. Each time a new block is generated, a new set of vertices is added to the list.\n* The `indices` list stores the indices of the vertices in the block. Each time a new block is generated, a new set of indices is added to the list, starting from 0.\n* The function takes into account the `ft`, `bk`, `bt`, `tp`, and `lt` properties of the current block being generated. Depending on these properties, different sets of vertices are added to the `vertices` list, and different indices are added to the `indices` list.\n* The function returns the maximum index of the `indices` list after all blocks have been generated.","complex_type":true},"usage":{"language":"java","code":"public void generate(List<Float> vertices, List<Integer> indices) {\n\tint max_index = 0; //\n\tfor (Block block : blocks) {\n\t\tmax_index = gen(vertices, indices, block, max_index); //\n\t}\n}\n","description":""},"name":"gen","code":"private static int gen(List<Float> vertices, List<Integer> indices, Block block, int max_index) {\n\t\t\n\t\tfloat x = block.x;\n\t\tfloat y = block.y;\n\t\tfloat z = block.z;\n\t\t\n\t\tif (block.ft) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,   0, 0, //\n\t\t\t\tx+1, y,   z,   1, 0, //\n\t\t\t\tx+1, y+1, z,   1, 1, //\n\t\t\t\tx,   y+1, z,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bk) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z+1,   1, 0, //\n\t\t\t\tx+1, y,   z+1,   0, 0, //\n\t\t\t\tx+1, y+1, z+1,   0, 1, //\n\t\t\t\tx,   y+1, z+1,   1, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     0, 0, //\n\t\t\t\tx+1, y,   z,   \t 1, 0, //\n\t\t\t\tx+1, y,   z+1,   1, 1, //\n\t\t\t\tx,   y,   z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.tp) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y+1, z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     1, 0, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.lt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     1, 0, //\n\t\t\t\tx,   y+1, z,     1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t\tx,   y,   z+1,   0, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.rt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx+1, y,   z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     0, 1, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx+1, y,   z+1,   1, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\treturn max_index;\n\t}","location":{"start":194,"insert":194,"offset":" ","indent":1},"item_type":"method","length":74}]}}}