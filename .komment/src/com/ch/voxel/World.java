{"name":"World.java","path":"src/com/ch/voxel/World.java","content":{"structured":{"description":"A 3D Minecraft world, representing it as a grid of Chunk objects, each consisting of blocks represented as 3x3 matrices. The code loads a world from a binary file, rendering it in real-time using a custom shader and a Camera object for perspective projection. It also provides some internal thread to handle chunk rendering asynchronously.","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera Pages: 1 -->\n<svg width=\"115pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 115.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"100,-74 7,-74 7,-55 100,-55 100,-74\"/>\n<text text-anchor=\"middle\" x=\"53.5\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera3D.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"107,-19 0,-19 0,0 107,0 107,-19\"/>\n<text text-anchor=\"middle\" x=\"53.5\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D</text>\n</a>\n</g>\n</g>\n<!-- Node1&#45;&gt;Node2 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node1&#45;&gt;Node2</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M53.5,-44.66C53.5,-35.93 53.5,-25.99 53.5,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"50,-44.75 53.5,-54.75 57,-44.75 50,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","items":[{"id":"7c8cb6e0-8458-bcac-bb41-6dbc9ab17b76","ancestors":[],"type":"function","description":"in the given code is responsible for managing a 3D world, including its chunk structure, rendering, and collision detection. The class has several methods for generating new chunks based on the player's position, updating block positions, and rendering the chunks using a shader. It also includes a render method that takes a camera and shader as parameters and renders the chunks based on their positions.","name":"World","code":"public class World {\n\n\tprivate int x, y, z; // in chunks\n\t\t\t// private int cunk_max;\n\tprivate Chunk[][][] chunks; // TODO: unwrap\n\tprivate int W = 4, H = 2, D = 4;\n\n\tpublic World() {\n\t\tx = 0;\n\t\ty = 0;\n\t\tz = 0;\n\t\tchunks = new Chunk[W][H][D];\n\t\tgen();\n\t}\n\t\n\tprivate void gen() {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tchunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n\t\t\t\t\tchunks[i][j][k].updateBlocks();\n\t\t\t\t\tchunks[i][j][k].toGenModel();\n\t\t\t\t}\n\t}\n\n\tpublic void updatePos(float x, float y, float z) {\n\t\tfinal int _x = (int) (x / Chunk.CHUNK_SIZE);\n\t\tfinal int _y = 0;//(int) (y / Chunk.CHUNK_SIZE);\n\t\tfinal int _z = (int) (z / Chunk.CHUNK_SIZE);\n\n\t\tif (this.x == _x && this.y == _y && this.z == _z) { // short circuit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check for any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n\t\t\t//System.out.println(\"hello\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint wx = this.x;\n\t\tint wy = this.y;\n\t\tint wz = this.z;\n\t\t\n//\t\tclass internal_chunk_thread extends Thread {\n//\t\t\t\n//\t\tprivate int  wx, wy, wz;\n//\t\t\n//\t\tvoid set(int x, int y, int z) {\n//\t\t\tthis.wx = x;\n//\t\t\tthis.wy = y;\n//\t\t\tthis.wz = z;\n//\t\t}\n//\t\t\t\n//\t\tpublic void run() {\n\n\t\t/*\n\t\t * all logic is unwrapped because its more efficient.. while its a pain\n\t\t * to code and read.. tradeoff taken :D\n\t\t */\n\n\t\t/* dont think these cases occure\n\t\tif (this.x != _x && this.y != _y && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.y != _y) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.y != _y && this.z != _z) {\n\t\t\tif (this.y < _y) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t*/\n\t\tif (wx != _x) {\n\t\t\tif (wx < _x) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wy != _y) {\n\t\t\tif (wy < _y) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wz != _z) {\n\t\t\tif (wz < _z) {\n\t\t\t\tint dif = _z - wz;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 0; k < D - 1; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, (D - 1) - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint dif = wz - _z;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 1; k < D; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][0] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, 0 - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][0].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][0].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\n//\t\t}\n//\t\t\n//\t\t};\n//\t\tinternal_chunk_thread t = new internal_chunk_thread();\n//\t\tt.set(this.x, this.y, this.z);\n//\t\tt.start();\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\t/* welp... this logic sure looks aweful */\n\t}\n\n\tpublic void render(Shader s, Camera c) {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tChunk ch = chunks[i][j][k];\n\t\t\t\t\tif (ch != null) { // just in case for now although i dont suspect it will ever be\n\t//\t\t\t\t\tfloat r = (W - i) / (float) W;\n\t//\t\t\t\t\tfloat g = j / (float) H;\n\t//\t\t\t\t\tfloat b = k / (float) D;\n\t\t\t\t\t\tColor cl = new Color((\"\" + ch.x + ch.y + ch.z + (ch.x * ch.z) + (ch.y * ch.y)).hashCode());\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat r = cl.getRed() / 255f;\n\t\t\t\t\t\tfloat g = cl.getGreen() / 255f;\n\t\t\t\t\t\tfloat b = cl.getBlue() / 255f;\n\t\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n\t\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch.getModelMatrix())));\n\t\t\t\t\t\tch.getModel().draw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\n\t// public\n\n}","location":{"start":9,"insert":9,"offset":" ","indent":0,"comment":null},"item_type":"class","length":233},{"id":"0810d179-8d7f-1d9f-9b41-96594e9902cc","ancestors":["7c8cb6e0-8458-bcac-bb41-6dbc9ab17b76"],"type":"function","description":"iterates over a grid of chunks, creating and updating blocks within each chunk, and then converting them to a gen model.","params":[],"usage":{"language":"java","code":"private void gen() {\n    for (int i = 0; i < W; i++) {\n        for (int j = 0; j < H; j++) {\n            for (int k = 0; k < D; k++) {\n                chunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n                chunks[i][j][k].updateBlocks();\n                chunks[i][j][k].toGenModel();\n            }\n        }\n    }\n}\n","description":"\nIn this example, the gen method would be called to generate new chunks for the World class. The method iterates through the chunks array in each dimension and creates new Chunk objects with the given coordinates (i - W / 2 + x, j - H / 2 + y, k - D / 2 + z). It then updates the blocks within the chunk using the updateBlocks method and converts the chunk to a model object for rendering using the toGenModel method.\nThis is just an example of how gen would be used as it is not possible to know the exact implementation without knowing more about the World class. However, this is a common way that someone could use gen to generate new chunks within a world."},"name":"gen","code":"private void gen() {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tchunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n\t\t\t\t\tchunks[i][j][k].updateBlocks();\n\t\t\t\t\tchunks[i][j][k].toGenModel();\n\t\t\t\t}\n\t}","location":{"start":24,"insert":24,"offset":" ","indent":1,"comment":null},"item_type":"method","length":9},{"id":"87084877-b1b2-59a9-1c4c-e39f936b55b5","ancestors":["7c8cb6e0-8458-bcac-bb41-6dbc9ab17b76"],"type":"function","description":"updates the position of the chunk's block based on the user input and checks for collisions with other chunks, updating the chunk's blocks and reassigning them to the new position if necessary.","params":[{"name":"x","type_name":"float","description":"2D coordinate of the chunk's position within the world, which is used to update the chunk's position and dimensions based on its z-coordinate.","complex_type":false},{"name":"y","type_name":"float","description":"2D coordinate of the chunk's position in the world, which is used to determine the correct chunk to update based on the `x` and `z` coordinates.","complex_type":false},{"name":"z","type_name":"float","description":"3D position of the chunk to be generated, and it is used to determine the correct chunk to be generated based on the differences between the current chunk and the specified chunk at the specified position.","complex_type":false}],"usage":{"language":"java","code":"updatePos(10.5f, 20.3f, 30.4f);\n","description":"\nThis would change the position of the chunk to (x = 10, y = 20, z = 30).\nThe method updatePos does not take in any parameters because it uses the class fields x, y and z as input. Therefore, the method can be called using only one set of coordinates. The method is used to update the position of the chunk. Since the method does not return anything, there are no outputs."},"name":"updatePos","code":"public void updatePos(float x, float y, float z) {\n\t\tfinal int _x = (int) (x / Chunk.CHUNK_SIZE);\n\t\tfinal int _y = 0;//(int) (y / Chunk.CHUNK_SIZE);\n\t\tfinal int _z = (int) (z / Chunk.CHUNK_SIZE);\n\n\t\tif (this.x == _x && this.y == _y && this.z == _z) { // short circuit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check for any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n\t\t\t//System.out.println(\"hello\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint wx = this.x;\n\t\tint wy = this.y;\n\t\tint wz = this.z;\n\t\t\n//\t\tclass internal_chunk_thread extends Thread {\n//\t\t\t\n//\t\tprivate int  wx, wy, wz;\n//\t\t\n//\t\tvoid set(int x, int y, int z) {\n//\t\t\tthis.wx = x;\n//\t\t\tthis.wy = y;\n//\t\t\tthis.wz = z;\n//\t\t}\n//\t\t\t\n//\t\tpublic void run() {\n\n\t\t/*\n\t\t * all logic is unwrapped because its more efficient.. while its a pain\n\t\t * to code and read.. tradeoff taken :D\n\t\t */\n\n\t\t/* dont think these cases occure\n\t\tif (this.x != _x && this.y != _y && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.y != _y) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.y != _y && this.z != _z) {\n\t\t\tif (this.y < _y) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t*/\n\t\tif (wx != _x) {\n\t\t\tif (wx < _x) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wy != _y) {\n\t\t\tif (wy < _y) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wz != _z) {\n\t\t\tif (wz < _z) {\n\t\t\t\tint dif = _z - wz;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 0; k < D - 1; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, (D - 1) - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint dif = wz - _z;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 1; k < D; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][0] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, 0 - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][0].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][0].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\n//\t\t}\n//\t\t\n//\t\t};\n//\t\tinternal_chunk_thread t = new internal_chunk_thread();\n//\t\tt.set(this.x, this.y, this.z);\n//\t\tt.start();\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\t/* welp... this logic sure looks aweful */\n\t}","location":{"start":34,"insert":34,"offset":" ","indent":1,"comment":null},"item_type":"method","length":183},{"id":"4a3b8a02-bd9b-7a9d-364b-aa204e18912f","ancestors":["7c8cb6e0-8458-bcac-bb41-6dbc9ab17b76"],"type":"function","description":"renders a 3D model using a shader and a camera. It iterates over the chunks of a 3D scene, sets the color of each chunk using its position, and then draws the corresponding 3D model using the shader and camera.","params":[{"name":"s","type_name":"Shader","description":"3D rendering shader that is being applied to the graphics pipeline, and it is used to set the uniform values of the shader using the `unifrom*` methods.\n\n* `s`: A `Shader` object representing the current shader being used. Its properties include the shader's name, version, and texture units.\n* `c`: A `Camera` object representing the active camera in the scene. It has properties such as the position, orientation, and field of view.\n\nThe function iterates over a 3D grid of chunks, computing the color of each chunk using the current shader and drawing it on the screen using the active camera's view projection matrix.","complex_type":true},{"name":"c","type_name":"Camera","description":"3D camera object that determines the viewpoint for rendering the scene.\n\n* `Camera c`: This is an instance of the `Camera` class, which represents a camera in the game engine. It has various properties such as `getViewProjection()`, `getModelMatrix()`, and `draw()` that are used to render the 3D model from the specified camera perspective.\n* `Shader s`: This is an instance of the `Shader` class, which represents a shader program in the game engine. It has various properties such as `uniformf()` and `unifromMat4()` that are used to set uniform values and matrix transformations for the shader.","complex_type":true}],"usage":{"language":"java","code":"// s is an instance of Shader class \n// c is an instance of Camera class\nWorld world = new World();\nworld.render(s,c);\n","description":"\nThis will call the "},"name":"render","code":"public void render(Shader s, Camera c) {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tChunk ch = chunks[i][j][k];\n\t\t\t\t\tif (ch != null) { // just in case for now although i dont suspect it will ever be\n\t//\t\t\t\t\tfloat r = (W - i) / (float) W;\n\t//\t\t\t\t\tfloat g = j / (float) H;\n\t//\t\t\t\t\tfloat b = k / (float) D;\n\t\t\t\t\t\tColor cl = new Color((\"\" + ch.x + ch.y + ch.z + (ch.x * ch.z) + (ch.y * ch.y)).hashCode());\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat r = cl.getRed() / 255f;\n\t\t\t\t\t\tfloat g = cl.getGreen() / 255f;\n\t\t\t\t\t\tfloat b = cl.getBlue() / 255f;\n\t\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n\t\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch.getModelMatrix())));\n\t\t\t\t\t\tch.getModel().draw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t}","location":{"start":218,"insert":218,"offset":" ","indent":1,"comment":null},"item_type":"method","length":20}]}}}