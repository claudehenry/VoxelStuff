{"name":"World.java","path":"src/com/ch/voxel/World.java","content":{"structured":{"description":"A 3D rendering engine for a cube-shaped world with a fixed number of chunks per dimension, each representing a 1x1x1 block in the world. The code loads the chunks from a file and updates their contents based on a set of rules defining what blocks can be placed in each chunk. The engine then renders the chunks using a shader and a camera, with each chunk being rendered independently based on its position in the world.","items":[{"id":"64cf12f3-2866-6d92-c645-ea75ff0b87ef","ancestors":[],"type":"function","description":"TODO","name":"World","code":"public class World {\n\n\tprivate int x, y, z; // in chunks\n\t\t\t// private int cunk_max;\n\tprivate Chunk[][][] chunks; // TODO: unwrap\n\tprivate int W = 4, H = 2, D = 4;\n\n\tpublic World() {\n\t\tx = 0;\n\t\ty = 0;\n\t\tz = 0;\n\t\tchunks = new Chunk[W][H][D];\n\t\tgen();\n\t}\n\t\n\tprivate void gen() {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tchunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n\t\t\t\t\tchunks[i][j][k].updateBlocks();\n\t\t\t\t\tchunks[i][j][k].toGenModel();\n\t\t\t\t}\n\t}\n\n\tpublic void updatePos(float x, float y, float z) {\n\t\tfinal int _x = (int) (x / Chunk.CHUNK_SIZE);\n\t\tfinal int _y = 0;//(int) (y / Chunk.CHUNK_SIZE);\n\t\tfinal int _z = (int) (z / Chunk.CHUNK_SIZE);\n\n\t\tif (this.x == _x && this.y == _y && this.z == _z) { // short circuit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check for any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n\t\t\t//System.out.println(\"hello\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint wx = this.x;\n\t\tint wy = this.y;\n\t\tint wz = this.z;\n\t\t\n//\t\tclass internal_chunk_thread extends Thread {\n//\t\t\t\n//\t\tprivate int  wx, wy, wz;\n//\t\t\n//\t\tvoid set(int x, int y, int z) {\n//\t\t\tthis.wx = x;\n//\t\t\tthis.wy = y;\n//\t\t\tthis.wz = z;\n//\t\t}\n//\t\t\t\n//\t\tpublic void run() {\n\n\t\t/*\n\t\t * all logic is unwrapped because its more efficient.. while its a pain\n\t\t * to code and read.. tradeoff taken :D\n\t\t */\n\n\t\t/* dont think these cases occure\n\t\tif (this.x != _x && this.y != _y && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.y != _y) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.y != _y && this.z != _z) {\n\t\t\tif (this.y < _y) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t*/\n\t\tif (wx != _x) {\n\t\t\tif (wx < _x) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wy != _y) {\n\t\t\tif (wy < _y) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wz != _z) {\n\t\t\tif (wz < _z) {\n\t\t\t\tint dif = _z - wz;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 0; k < D - 1; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, (D - 1) - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint dif = wz - _z;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 1; k < D; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][0] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, 0 - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][0].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][0].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\n//\t\t}\n//\t\t\n//\t\t};\n//\t\tinternal_chunk_thread t = new internal_chunk_thread();\n//\t\tt.set(this.x, this.y, this.z);\n//\t\tt.start();\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\t/* welp... this logic sure looks aweful */\n\t}\n\n\tpublic void render(Shader s, Camera c) {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tChunk ch = chunks[i][j][k];\n\t\t\t\t\tif (ch != null) { // just in case for now although i dont suspect it will ever be\n\t//\t\t\t\t\tfloat r = (W - i) / (float) W;\n\t//\t\t\t\t\tfloat g = j / (float) H;\n\t//\t\t\t\t\tfloat b = k / (float) D;\n\t\t\t\t\t\tColor cl = new Color((\"\" + ch.x + ch.y + ch.z + (ch.x * ch.z) + (ch.y * ch.y)).hashCode());\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat r = cl.getRed() / 255f;\n\t\t\t\t\t\tfloat g = cl.getGreen() / 255f;\n\t\t\t\t\t\tfloat b = cl.getBlue() / 255f;\n\t\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n\t\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch.getModelMatrix())));\n\t\t\t\t\t\tch.getModel().draw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\n\t// public\n\n}","location":{"start":9,"insert":9,"offset":" ","indent":0},"item_type":"class","length":233},{"id":"8f203bbf-7efc-63a2-8345-79b67ab6378e","ancestors":["64cf12f3-2866-6d92-c645-ea75ff0b87ef"],"type":"function","description":"iterates through a 3D grid, creating new `Chunk` objects at each position and updating their block layouts before passing them to the genetic model.","params":[],"usage":{"language":"java","code":"private void gen() {\n    for (int i = 0; i < W; i++)\n        for (int j = 0; j < H; j++)\n            for (int k = 0; k < D; k++) {\n                chunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n                chunks[i][j][k].updateBlocks();\n                chunks[i][j][k].toGenModel();\n            }\n}\n","description":"\nThis example creates a new chunk for every position in the world and updates its blocks. It then converts it to a model object which can be used to render the chunk.\n\nNote that this is a very simple example of how gen could be used, as it only creates chunks and does not handle any edge cases or error handling. It is up to you to implement error checking and other features as needed for your program."},"name":"gen","code":"private void gen() {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tchunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n\t\t\t\t\tchunks[i][j][k].updateBlocks();\n\t\t\t\t\tchunks[i][j][k].toGenModel();\n\t\t\t\t}\n\t}","location":{"start":24,"insert":24,"offset":" ","indent":1},"item_type":"method","length":9},{"id":"6db9ab5f-f618-c388-2746-808480ae42ef","ancestors":["64cf12f3-2866-6d92-c645-ea75ff0b87ef"],"type":"function","description":"updates the position of a Chunk object based on its offset from the player's position, and adjusts the chunk's blocks to match the new position within the world.","params":[{"name":"x","type_name":"float","description":"2D coordinate of the chunk position relative to the world's origin, and it is used to determine which chunks are updated or generated based on their proximity to the chunk being processed.","complex_type":false},{"name":"y","type_name":"float","description":"2D coordinate of the chunk's location within the world, and is used to determine the appropriate chunks to update or generate based on their position relative to the player's position.","complex_type":false},{"name":"z","type_name":"float","description":"3D position of the chunk in the world, and it is used to determine whether the chunk needs to be updated or not based on its distance from the player's current position.","complex_type":false}],"usage":{"language":"java","code":"public static void main(String[] args) {\n    World world = new World();\n    world.updatePos(100, 50);\n}\n","description":"\nThis will change the position of the world object to x=100 and y=50."},"name":"updatePos","code":"public void updatePos(float x, float y, float z) {\n\t\tfinal int _x = (int) (x / Chunk.CHUNK_SIZE);\n\t\tfinal int _y = 0;//(int) (y / Chunk.CHUNK_SIZE);\n\t\tfinal int _z = (int) (z / Chunk.CHUNK_SIZE);\n\n\t\tif (this.x == _x && this.y == _y && this.z == _z) { // short circuit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check for any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n\t\t\t//System.out.println(\"hello\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint wx = this.x;\n\t\tint wy = this.y;\n\t\tint wz = this.z;\n\t\t\n//\t\tclass internal_chunk_thread extends Thread {\n//\t\t\t\n//\t\tprivate int  wx, wy, wz;\n//\t\t\n//\t\tvoid set(int x, int y, int z) {\n//\t\t\tthis.wx = x;\n//\t\t\tthis.wy = y;\n//\t\t\tthis.wz = z;\n//\t\t}\n//\t\t\t\n//\t\tpublic void run() {\n\n\t\t/*\n\t\t * all logic is unwrapped because its more efficient.. while its a pain\n\t\t * to code and read.. tradeoff taken :D\n\t\t */\n\n\t\t/* dont think these cases occure\n\t\tif (this.x != _x && this.y != _y && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.y != _y) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.y != _y && this.z != _z) {\n\t\t\tif (this.y < _y) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t*/\n\t\tif (wx != _x) {\n\t\t\tif (wx < _x) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wy != _y) {\n\t\t\tif (wy < _y) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wz != _z) {\n\t\t\tif (wz < _z) {\n\t\t\t\tint dif = _z - wz;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 0; k < D - 1; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, (D - 1) - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint dif = wz - _z;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 1; k < D; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][0] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, 0 - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][0].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][0].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\n//\t\t}\n//\t\t\n//\t\t};\n//\t\tinternal_chunk_thread t = new internal_chunk_thread();\n//\t\tt.set(this.x, this.y, this.z);\n//\t\tt.start();\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\t/* welp... this logic sure looks aweful */\n\t}","location":{"start":34,"insert":34,"offset":" ","indent":1},"item_type":"method","length":183},{"id":"382ad3c7-05ce-3991-cf4e-00553266f3c2","ancestors":["64cf12f3-2866-6d92-c645-ea75ff0b87ef"],"type":"function","description":"performs rendering using a shader and a camera. It iterates over chunks in a 3D environment and draws each chunk's model using the shader and camera parameters.","params":[{"name":"s","type_name":"Shader","description":"3D shader object that is being rendered, and it is used to set the uniform values for the shader using the `uniformf()` and `unifromMat4()` methods.\n\n* `s`: A `Shader` object that represents a shader program. It has various properties and attributes, such as `unifromMat4()`, `uniformf()`, `getModelMatrix()`, `getViewProjection()`, etc.\n\nThe `render` function iterates over each pixel in the 2D array `chunks`, applying the shader program to each pixel. For each pixel, it sets the color of the pixel using the `unifromMat4()` and `uniformf()` methods, and then draws the 3D model associated with the pixel using the `getModelMatrix()` method. The `getViewProjection()` method is used to compute the view-projection matrix for each pixel, which is then multiplied with the model matrix to obtain the final transformation matrix for each pixel.","complex_type":true},{"name":"c","type_name":"Camera","description":"3D camera object, which is used to transform the chunk's model matrix using the view projection matrix.\n\n* `Camera c`: This is an instance of the `Camera` class, which represents the camera used to render the 3D scene. It has various attributes such as the viewport dimensions (`width` and `height`), the near and far clipping planes, the field of view, and the aspect ratio.\n* `W`, `H`, and `D`: These are the dimensions of the simulation's world, heightmap, and depth map, respectively. They are used to iterate over the chunks in the scene.","complex_type":true}],"usage":{"language":"java","code":"Shader s = new Shader(\"shaders/color\");\nCamera c = new Camera();\nWorld w = new World(0, 0, 0);\nw.render(s, c);\n","description":"\nThis code creates a new world with the default values for `x`, `y` and `z`. It then creates a new `Shader` object using the `shaders/color` resource, which is assumed to be a valid shader file. The `Camera` object is also created with a default position.\nNext, the `render` method of the `World` object is called with these two objects as input. This causes the `World` object to render all its chunks using the specified shader and camera. As a result, the color of each block in the world will be determined by the corresponding chunk's position (x, y, z) which is used to calculate a hash code for that chunk.\nNote that this implementation does not check for `null` values in the `chunks` array, so it may produce unexpected behavior if some chunks are `null`. However, since the `World` constructor sets all chunks to `null`, we assume that they will be set to a valid value before being used."},"name":"render","code":"public void render(Shader s, Camera c) {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tChunk ch = chunks[i][j][k];\n\t\t\t\t\tif (ch != null) { // just in case for now although i dont suspect it will ever be\n\t//\t\t\t\t\tfloat r = (W - i) / (float) W;\n\t//\t\t\t\t\tfloat g = j / (float) H;\n\t//\t\t\t\t\tfloat b = k / (float) D;\n\t\t\t\t\t\tColor cl = new Color((\"\" + ch.x + ch.y + ch.z + (ch.x * ch.z) + (ch.y * ch.y)).hashCode());\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat r = cl.getRed() / 255f;\n\t\t\t\t\t\tfloat g = cl.getGreen() / 255f;\n\t\t\t\t\t\tfloat b = cl.getBlue() / 255f;\n\t\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n\t\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch.getModelMatrix())));\n\t\t\t\t\t\tch.getModel().draw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t}","location":{"start":218,"insert":218,"offset":" ","indent":1},"item_type":"method","length":20}]}}}