{"name":"Camera.java","path":"src/com/ch/Camera.java","content":{"structured":{"description":"a `Camera` class that handles camera-related functionality, including view and projection matrices calculation, translation matrix calculation, and transformation management. The code utilizes the `Matrix4f` class from the `com.ch.math` package and the `Transform` class from the same package. The `Camera` class has a constructor that takes a `Matrix4f` object representing the camera's projection, and methods for calculating view and translation matrices, as well as getting and setting transformation values. Additionally, the code defines an abstract class `CameraStruct` that extends `Camera` and provides an implementation of `calculateProjectionMatrix` and `adjustToViewport`.","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera.CameraStruct Pages: 1 -->\n<svg width=\"198pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 198.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera.CameraStruct</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"176.5,-74 13.5,-74 13.5,-55 176.5,-55 176.5,-74\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera.CameraStruct</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera3D_1_1CameraStruct3D.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"190,-19 0,-19 0,0 190,0 190,-19\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D.CameraStruct3D</text>\n</a>\n</g>\n</g>\n<!-- Node1&#45;&gt;Node2 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node1&#45;&gt;Node2</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M95,-44.66C95,-35.93 95,-25.99 95,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"91.5,-44.75 95,-54.75 98.5,-44.75 91.5,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","items":[{"id":"ccd3658d-ae0e-7194-df40-180825e7d385","ancestors":[],"type":"function","description":"is an abstract class that provides methods for calculating view and projection matrices. It also has a transform field that can be used to adjust the camera's position and orientation in 3D space. The class has several abstract methods for calculating matrix representations of the camera's projection and transformation, as well as methods for adjusting the camera to fit within a specified viewport.","name":"Camera","code":"public abstract class Camera {\n\n\tprotected Matrix4f projection;\n\tprotected Matrix4f viewProjectionMat4;\n\tprotected CameraStruct values;\n\tprotected Transform transform;\n\n\tprotected Camera(Matrix4f projection) {\n\t\tthis.projection = projection;\n\t\ttransform = new Transform();\n\t}\n\n\tpublic Matrix4f getViewProjection() {\n\n\t\tif (viewProjectionMat4 == null || transform.hasChanged()) {\n\t\t\tcalculateViewMatrix();\n\t\t}\n\n\t\treturn viewProjectionMat4;\n\t}\n\n\tpublic Matrix4f calculateViewMatrix() {\n\n\t\tMatrix4f cameraRotation = transform.getTransformedRot().conjugate().toRotationMatrix();\n\t\tMatrix4f cameraTranslation = getTranslationMatrix();\n\n\t\treturn (viewProjectionMat4 = projection.mul(cameraRotation.mul(cameraTranslation)));\n\n\t}\n\n\tpublic Matrix4f getTranslationMatrix() {\n\t\tVector3f cameraPos = transform.getTransformedPos().mul(-1);\n\t\treturn new Matrix4f().initTranslation(cameraPos.getX(), cameraPos.getY(), cameraPos.getZ());\n\t}\n\n\tpublic Transform getTransform() {\n\t\treturn transform;\n\t}\n\t\n\tpublic abstract Matrix4f calculateProjectionMatrix(CameraStruct data);\n\n\tpublic abstract void adjustToViewport(int width, int height);\n\n\tprotected abstract class CameraStruct {\n\n\t\tprotected abstract Matrix4f getAsMatrix4();\n\n\t}\n\n}","location":{"start":6,"insert":6,"offset":" ","indent":0,"comment":null},"item_type":"class","length":50},{"id":"2b0540b8-2e24-fb85-b145-dbb8df3b4fed","ancestors":["ccd3658d-ae0e-7194-df40-180825e7d385"],"type":"function","description":"computes and returns a matrix that represents the view projection transformation, based on the current view matrix and other transforms.","params":[],"returns":{"type_name":"Matrix4f","description":"a Matrix4f object representing the view and projection transformation.\n\nThe `getViewProjection` function returns a `Matrix4f` object representing the view projection matrix. This matrix is used to transform 3D points from the world coordinate system to the camera's coordinate system. The matrix has four rows and four columns, with elements representing the transformations of x, y, z, and w coordinates.\nThe function first checks if the `viewProjectionMat4` object is null or if the `transform` field has changed since the last call to this function. If either of these conditions is true, the function calculates the view matrix using a proprietary method. The view matrix is then returned by the function.","complex_type":true},"usage":{"language":"java","code":"public class MyCamera extends Camera {\n    public MyCamera(Matrix4f projection) {\n        super(projection);\n    }\n    \n    @Override\n    protected Matrix4f calculateProjectionMatrix(CameraStruct data) {\n        // Calculate the projection matrix based on the provided data\n    }\n    \n    @Override\n    public void adjustToViewport(int width, int height) {\n        // Adjust the camera's transformation to match the viewport size\n    }\n}\n","description":"\nIn this example, MyCamera extends the Camera class and overrides calculateProjectionMatrix and adjustToViewport methods. getViewProjection method is then called on an instance of MyCamera, which will return a Matrix4f containing the projection matrix calculated based on the provided data in the call to calculateProjectionMatrix method. Additionally, adjustToViewport method is called on an instance of MyCamera with width and height parameters to adjust the camera's transformation to match the viewport size."},"name":"getViewProjection","code":"public Matrix4f getViewProjection() {\n\n\t\tif (viewProjectionMat4 == null || transform.hasChanged()) {\n\t\t\tcalculateViewMatrix();\n\t\t}\n\n\t\treturn viewProjectionMat4;\n\t}","location":{"start":18,"insert":18,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"3838fe6c-4a02-dda8-fd46-59ab1ea3f94a","ancestors":["ccd3658d-ae0e-7194-df40-180825e7d385"],"type":"function","description":"calculates a view matrix that combines the rotation and translation of a camera with the projection of a 3D scene.","params":[],"returns":{"type_name":"Matrix4f","description":"a 4x4 matrix representing the view projection transformation.\n\n* The output is a matrix object of type `Matrix4f`.\n* The matrix represents the view transformation of the camera, combining the rotation and translation of the camera.\n* The rotation part of the matrix is represented by the `cameraRotation` variable, which is a conjugate transpose of a rotation matrix.\n* The translation part of the matrix is represented by the `cameraTranslation` variable, which contains the displacement of the camera in 3D space.\n* The multiplication of the `projection` matrix with the `cameraRotation` and then with the `cameraTranslation` results in the final view transformation matrix.","complex_type":true},"usage":{"language":"java","code":"Camera camera = new Camera(); // This assumes the constructor for Camera exists \ncamera.calculateProjectionMatrix(data); // This will update the projection matrix with the data passed in.  \ncamera.adjustToViewport(width, height); // This updates the view port to match the values provided. \nMatrix4f viewMatrix = camera.calculateViewMatrix(); // This calculates and returns the view matrix\n","description":""},"name":"calculateViewMatrix","code":"public Matrix4f calculateViewMatrix() {\n\n\t\tMatrix4f cameraRotation = transform.getTransformedRot().conjugate().toRotationMatrix();\n\t\tMatrix4f cameraTranslation = getTranslationMatrix();\n\n\t\treturn (viewProjectionMat4 = projection.mul(cameraRotation.mul(cameraTranslation)));\n\n\t}","location":{"start":27,"insert":27,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"b885db03-dcd7-c28f-c248-6921f49e54ab","ancestors":["ccd3658d-ae0e-7194-df40-180825e7d385"],"type":"function","description":"generates a 4x4 transformation matrix that represents a translation from the current position of the transform to a new position.","params":[],"returns":{"type_name":"Matrix4f","description":"a 4x4 transformation matrix representing the camera's position in world coordinates, with the origin at the camera's position.\n\n* The Matrix4f object represents a 4x4 transformation matrix that translates by the vector (x, y, z) in the world coordinates.\n* The translation vector is computed as the inverse of the transform position vector multiplied by -1.\n* The resulting matrix is stored in a new Matrix4f object and returned from the function.","complex_type":true},"usage":{"language":"java","code":"Matrix4f translation = camera.getTranslationMatrix();\n","description":"\nIn this example, the method getTranslationMatrix is called on the camera object and its return value is assigned to a variable called translation. The result of this method call is a 4x4 matrix representing the camera's position in world space."},"name":"getTranslationMatrix","code":"public Matrix4f getTranslationMatrix() {\n\t\tVector3f cameraPos = transform.getTransformedPos().mul(-1);\n\t\treturn new Matrix4f().initTranslation(cameraPos.getX(), cameraPos.getY(), cameraPos.getZ());\n\t}","location":{"start":36,"insert":36,"offset":" ","indent":1,"comment":null},"item_type":"method","length":4},{"id":"1f8a8196-d737-d085-6942-e51363fb43e6","ancestors":["ccd3658d-ae0e-7194-df40-180825e7d385"],"type":"function","description":"returns the `transform` object, which contains the mapping between original and transformed data.","params":[],"returns":{"type_name":"Transform","description":"a reference to an instance of the `Transform` class.\n\nThe `transform` variable is an instance of the `Transform` class, which represents a transformation matrix. The `Transform` class has several properties and methods for manipulating transformations, including scaling, rotating, and translating objects in 3D space.","complex_type":true},"usage":{"language":"java","code":"public void display() {\n  Camera camera = new PerspectiveCamera(new Matrix4f());\n  Transform transform = camera.getTransform();\n}\n","description":"\nIn the above example, the getTransform() method of the Camera class is called on an object of type PerspectiveCamera to get its Transform object."},"name":"getTransform","code":"public Transform getTransform() {\n\t\treturn transform;\n\t}","location":{"start":41,"insert":41,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"798a7b5a-690d-e2b3-6d4e-a4f978e81a41","ancestors":["ccd3658d-ae0e-7194-df40-180825e7d385"],"type":"function","description":"is an abstract class that serves as a base for other classes inheriting from it in the Camera package. It contains an abstract method `getAsMatrix4()` that returns a Matrix4f object, which is not implemented in this class. The purpose of this class seems to be to provide a common framework for other classes to build upon and inherit functionality from.","name":"CameraStruct","code":"protected abstract class CameraStruct {\n\n\t\tprotected abstract Matrix4f getAsMatrix4();\n\n\t}","location":{"start":49,"insert":49,"offset":" ","indent":1,"comment":null},"item_type":"class","length":5}]}}}