{"name":"Quaternion.java","path":"src/com/ch/math/Quaternion.java","content":{"structured":{"description":"A Quaternion class that represents 3D rotations and transformations. The class provides various methods for calculating quaternion values from Euler angles and vice versa, as well as setting and getting quaternion components. Additionally, it includes methods for calculating the length of a quaternion and converting between different coordinate systems.","items":[{"id":"7013fc73-856b-aa81-1642-07175010035e","ancestors":[],"type":"function","description":"in Java is a mathematical construct used to represent rotations in 3D space. It has four fields: x, y, z, and w, which represent the real and imaginary parts of a complex number that represents the rotation. The class also provides methods for calculating the quaternion's conjugate, inverse, and norm, as well as for converting between different rotational representations such as Euler angles and rotation matrices. Additionally, it provides methods for rotating vectors by the quaternion's rotation.","name":"Quaternion","code":"public class Quaternion {\n\n\tprivate float x;\n\tprivate float y;\n\tprivate float z;\n\tprivate float w;\n\n\tpublic Quaternion() {\n\t\tthis(0, 0, 0, 0);\n\t}\n\n\t\n\tpublic Quaternion(float w, float x, float y, float z) {\n\t\tthis.w = w;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n\n\tpublic Quaternion(Vector3f axis, float angle) {\n\t\tfloat sinHalfAngle = (float) Math.sin(angle / 2);\n\t\tfloat cosHalfAngle = (float) Math.cos(angle / 2);\n\n\t\tthis.x = axis.getX() * sinHalfAngle;\n\t\tthis.y = axis.getY() * sinHalfAngle;\n\t\tthis.z = axis.getZ() * sinHalfAngle;\n\t\tthis.w = cosHalfAngle;\n\t}\n\n\tpublic float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}\n\n\tpublic Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}\n\n\tpublic Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}\n\n\tpublic Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}\n\n\tpublic Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\tpublic Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\tpublic Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}\n\n\tpublic Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}\n\n\tpublic Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}\n\n\tpublic float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}\n\n\tpublic Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}\n\n\tpublic Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}\n\n\t// From Ken Shoemake's \"Quaternion Calculus and Fast Animation\" article\n\tpublic Quaternion(Matrix4f rot) {\n\t\tfloat trace = rot.get(0, 0) + rot.get(1, 1) + rot.get(2, 2);\n\n\t\tif (trace > 0) {\n\t\t\tfloat s = 0.5f / (float) Math.sqrt(trace + 1.0f);\n\t\t\tw = 0.25f / s;\n\t\t\tx = (rot.get(1, 2) - rot.get(2, 1)) * s;\n\t\t\ty = (rot.get(2, 0) - rot.get(0, 2)) * s;\n\t\t\tz = (rot.get(0, 1) - rot.get(1, 0)) * s;\n\t\t} else {\n\t\t\tif (rot.get(0, 0) > rot.get(1, 1) && rot.get(0, 0) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(0, 0) - rot.get(1, 1) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(1, 2) - rot.get(2, 1)) / s;\n\t\t\t\tx = 0.25f * s;\n\t\t\t\ty = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\tz = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t} else if (rot.get(1, 1) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(1, 1) - rot.get(0, 0) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(2, 0) - rot.get(0, 2)) / s;\n\t\t\t\tx = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\ty = 0.25f * s;\n\t\t\t\tz = (rot.get(2, 1) + rot.get(1, 2)) / s;\n\t\t\t} else {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(2, 2) - rot.get(0, 0) - rot.get(1, 1));\n\t\t\t\tw = (rot.get(0, 1) - rot.get(1, 0)) / s;\n\t\t\t\tx = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t\ty = (rot.get(1, 2) + rot.get(2, 1)) / s;\n\t\t\t\tz = 0.25f * s;\n\t\t\t}\n\t\t}\n\n\t\tfloat length = (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t\tx /= length;\n\t\ty /= length;\n\t\tz /= length;\n\t\tw /= length;\n\t}\n\n\tpublic Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}\n\n\tpublic Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}\n\n\tpublic Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}\n\n\tpublic Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param eulerAngles - @see <a href=\"https://en.wikipedia.org/wiki/Euler_angles#Proper_Euler_angles\">Wikipedia's Article on Euler Angles</a> for a description\n\t *                    of their usage/definition.\n\t * @return The {@link Quaternion} associated with the Euler angles.\n\t */\n\tpublic static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}\n\n\tpublic Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}\n\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\tpublic void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\tpublic float getZ() {\n\t\treturn z;\n\t}\n\n\tpublic void setZ(float z) {\n\t\tthis.z = z;\n\t}\n\n\tpublic float getW() {\n\t\treturn w;\n\t}\n\n\tpublic void setW(float w) {\n\t\tthis.w = w;\n\t}\n\n\tpublic boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}\n\t\n}","location":{"start":6,"insert":6,"offset":" ","indent":0,"comment":null},"item_type":"class","length":260},{"id":"4d78b836-bfee-c28f-b748-8b421972b45e","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"computes the Euclidean distance of a point in 3D space from origin, using the Pythagorean theorem and square root operation.","params":[],"returns":{"type_name":"float","description":"a float value representing the Euclidean distance of a 3D point from its origin.","complex_type":false},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nq.set(1, 2, 3, 4);\nSystem.out.println(\"Length of the quaternion: \" + q.length());\n","description":"\nThis is a short and concise example that does not require explanation as it is self-explanatory. This method would return the length of the quaternion which in this case would be 14.583792806312497."},"name":"length","code":"public float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}","location":{"start":35,"insert":35,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"8523a0e9-3155-1893-114a-a9007eddc586","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"normalizes a given quaternion by dividing each component by its length, resulting in a new quaternion with a length of 1.","params":[],"returns":{"type_name":"Quaternion","description":"a normalized quaternion representation of the input quaternion.\n\n* The `Quaternion` object represents a normalized quaternion, with length equal to 1.\n* The `w`, `x`, `y`, and `z` fields represent the component values of the quaternion, which are normalized to have a length of 1.\n* The function returns a new `Quaternion` object representing the normalized quaternion.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4).normalize();\nSystem.out.println(\"q: \" + q);\n","description":"\nExpected output:\n"},"name":"normalized","code":"public Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}","location":{"start":39,"insert":39,"offset":" ","indent":1,"comment":null},"item_type":"method","length":5},{"id":"d0492f32-c25e-c9b0-e548-0908542f8b86","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"generates a quaternion with the same magnitude as the input and the opposite direction of its axis.","params":[],"returns":{"type_name":"instance","description":"a new Quaternion object with the conjugate of the input quaternion's components.\n\n* The output is a new instance of the `Quaternion` class with the same scalar components as the original input but with the `w` component reversed. This means that if the original quaternion has `w = w0`, then the conjugate quaternion will have `w = -w0`.\n* The `x`, `y`, and `z` components of the output are the same as those of the original input.\n* The conjugate quaternion is a mirror image of the original quaternion, meaning that if the original quaternion rotates an object in one direction, then the conjugate quaternion will rotate the same object in the opposite direction.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nQuaternion r = q.conjugate(); // r is (-1, -2, -3, -4)\n","description":"\nThis code first creates a quaternion q with the values (1, 2, 3, 4). It then calls the conjugate method on this quaternion, which produces another quaternion r. The resulting quaternion r has all its components negated. This is because a quaternion's conjugate has the same real part as the original quaternion, but the imaginary components are negated.\n\nIt's important to note that the conjugate of a quaternion does not change its length (magnitude), i.e., the distance from the origin in 3D space. Also, the conjugate of a quaternion q is such that q \\* r == -q \\* conj(r). This means that the product of two quaternions, when one of them is the conjugate of the other, is zero, if and only if the two quaternions are opposite."},"name":"conjugate","code":"public Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}","location":{"start":45,"insert":45,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"a7b3bf0e-0349-ec87-364e-82c7a4005907","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"multiplies a quaternion by a scalar value and returns the result as a new quaternion object.","params":[{"name":"r","type_name":"float","description":"4D vector that is multiplied with the quaternion represented by the function.","complex_type":false}],"returns":{"type_name":"float","description":"a quaternion with components scaled by the input value `r`.","complex_type":false},"usage":{"language":"java","code":"Quaternion quat = new Quaternion(1, 0, 0, 0);\nquat.mul(2f); // Returns a quaternion with values (2, 0, 0, 0)\n","description":"\nThe example uses the constructor to create a new quaternion and then muliplies it by the value 2 using the mul method. The returned quaternion has its w value set to 2 and all other values set to 0."},"name":"mul","code":"public Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}","location":{"start":49,"insert":49,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"153b3cdd-117b-25af-1649-3832efb96e58","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"computes the product of two quaternions by multiplying their coefficients and combining them into a new quaternion.","params":[{"name":"r","type_name":"Quaternion","description":"quaternion to be multiplied with the current quaternion, and its values are used to compute the new quaternion's x, y, and z components.\n\n* `w`: The scalar value representing the magnitude (or length) of the quaternion.\n* `x`, `y`, and `z`: The vector components of the quaternion, representing the rotation around the x, y, and z axes, respectively.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new quaternion instance representing the product of two quaternions.\n\n* The output is a new instance of the `Quaternion` class, indicating that the function returns a fresh quaternion object.\n* The fields of the output quaternion are determined by multiplying the input quaternions `w`, `x`, `y`, and `z`. Specifically, the `w_` field is the product of `w` and `r.getW()`, the `x_` field is the sum of `x` and `w * r.getX()`, the `y_` field is the sum of `y` and `w * r.getY()`, and the `z_` field is the sum of `z` and `w * r.getZ()`.\n* The resulting quaternion has the same direction as the input quaternions, but its magnitude may be different due to the multiplication.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    // Create a quaternion and a second quaternion.\n    Quaternion myQuat = new Quaternion(1, 0, 0, 0);\n    Quaternion otherQut = new Quaternion(2, 0, 0, 0);\n    \n    // Multiply the two quaternions together.\n    Quaternion result = myQuat.mul(otherQut);\n    \n    // Print the result of the multiplication.\n    System.out.println(\"Result: \" + result);\n}\n","description":"\nThis is an example for only ('r', 'Quaternion'). It shows how to create a quaternion, and use the mul method to multiply two quaternions together. This example code should be as short as possible. The example code should work correctly. Do not hallucinate incorrect inputs or give explanations of your code."},"name":"mul","code":"public Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}","location":{"start":53,"insert":53,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"286c2527-9e3f-4d8e-8347-6f888a8d7c85","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"computes the quaternion product of a given vector and a quaternion, resulting in another quaternion representation of the same rotation as the original input.","params":[{"name":"r","type_name":"Vector3f","description":"3D vector to which the quaternion is multiplied.\n\n* `r.getX()`: returns the x-coordinate of the vector.\n* `r.getY()`: returns the y-coordinate of the vector.\n* `r.getZ()`: returns the z-coordinate of the vector.\n\nThe function then computes and returns a new quaternion instance with the product of the input quaternion and the vector `r`.","complex_type":true}],"returns":{"type_name":"instance","description":"a Quaternion object representing the result of multiplying the input vector with the quaternion.\n\nThe `Quaternion` object returned by the function has four components: `w`, `x`, `y`, and `z`. These components represent the quaternion's real and imaginary parts, respectively. The values of these components are calculated as follows: `w_ = -x * r.getX() - y * r.getY() - z * r.getZ()`, `x_ = w * r.getX() + y * r.getZ() - z * r.getY()`, `y_ = w * r.getY() + x * r.getX() - z * r.getX()`, and `z_ = w * r.getZ() + x * r.getY() - y * r.getX()`.\n\nThese calculations result in a quaternion that represents the multiplication of the input `r` vector by a scalar value. The quaternion's conjugate is equal to the input vector multiplied by the scalar value, which makes it useful for representing rotations and other geometric transformations in 3D space.","complex_type":true},"usage":{"language":"java","code":"Vector3f vector = new Vector3f(1, 0, 0);\nQuaternion quaternion = new Quaternion();\nquaternion.set(2, 3, 4, 5);\nQuaternion result = quaternion.mul(vector);\n","description":"\nThe resulting value of 'result' is "},"name":"mul","code":"public Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}","location":{"start":62,"insert":62,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"9dd6bb65-111a-7a99-0045-9ffe26dad51e","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"takes a `Quaternion` argument `r`, subtracts its components from those of the original quaternion, and returns a new quaternion representing the resultant rotation.","params":[{"name":"r","type_name":"Quaternion","description":"4D quaternion to be subtracted from the current quaternion, resulting in the updated quaternion output.\n\n* `w`: The scalar value representing the real part of the quaternion.\n* `x`, `y`, and `z`: The scalar values representing the imaginary parts of the quaternion, each representing a different component of the quaternion.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new Quaternion object representing the result of subtracting the quaternion `r` from the original quaternion.\n\n* The `Quaternion` object returned has four components - `w`, `x`, `y`, and `z`, which represent the differences between the input `r` and the current quaternion.\n* These components are in the range of `-1 to 1`, representing the magnitude of the difference between the two quaternions.\n* The `Quaternion` object is created by subtracting `r` from the current quaternion, resulting in a new quaternion that represents the difference between the two.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nQuaternion r = new Quaternion(1, 2, 3, 4);\n\nq.set(0, 0, 0, 0).sub(r); // returns a Quaternion with w= -1, x=-2, y=-3, z=-4\n","description":"\nThe example is short and easy to read because all of the calculations are being done within the sub method itself."},"name":"sub","code":"public Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}","location":{"start":71,"insert":71,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"b1912d4f-63ba-0f89-f147-bb20262a367a","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"takes a `Quaternion` argument `r` and returns a new `Quaternion` instance with the sum of its own values and those of `r`.","params":[{"name":"r","type_name":"Quaternion","description":"4D quaternion to be added to the current quaternion, resulting in the new quaternion output.\n\n* `r.getW()`: Retrieves the real part of the quaternion's scalar component.\n* `r.getX()`, `r.getY()`, and `r.getZ()`: Retrieves the imaginary parts of the quaternion's scalar components.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new Quaternion instance representing the sum of the input Quaternions.\n\n* The output is a new Quaternion object representing the sum of the input Quaternions.\n* The `w` field of the output represents the sum of the `w` fields of the input Quaternions.\n* The `x`, `y`, and `z` fields of the output represent the sum of the `x`, `y`, and `z` fields of the input Quaternions, respectively.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion q = new Quaternion(1, 0, 0, 0);\n    Quaternion r = new Quaternion(2, 3, 4, 5);\n    \n    // Addition of two quaternions. Result is a new quaternion.\n    Quaternion result = q.add(r);\n}\n","description":""},"name":"add","code":"public Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}","location":{"start":75,"insert":75,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"9c0106f4-b1ab-e7a6-9145-da11a89cb933","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"generates a rotation matrix from a given vector representing the forward, up, and right components of the rotation. The returned matrix can be used to perform rotations in 3D space.","params":[],"returns":{"type_name":"Matrix4f","description":"a rotation matrix in the form of a 4x4 matrix.\n\nThe Matrix4f object returned by the function represents a 4x4 rotation matrix, where each element is a 32-bit floating-point number. The matrix is initialized using the `initRotation` method, which takes three vectors as input: forward, up, and right. These vectors represent the x, y, and z components of the rotation axis, respectively.\n\nThe forward vector has a magnitude of 2 and an angle of 0 or π/2 radians, depending on the orientation of the rotation axis. The up vector has a magnitude of 1 and an angle of π/2 radians, regardless of the orientation of the rotation axis. Finally, the right vector has a magnitude of 1 and an angle of 0 radians, as it is always perpendicular to both the forward and up vectors.\n\nThe matrix itself represents a rotation around the origin of the coordinate system, where each element is computed based on the dot product of the corresponding axis vectors and the angles between them. The resulting matrix has the properties that its determinant is 1, and its inverse is equal to its transpose. This makes it an orthonormal matrix, which is required for many applications in computer graphics and robotics.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nMatrix4f mat = q.toRotationMatrix();\n","description":"\nThis code will create a quaternion with the specified values and then pass it to the method toRotationMatrix to get a rotation matrix that represents the same rotation as the quaternion. This can be useful if you want to convert a quaternion into a 4x4 matrix that can be used to rotate objects in a scene, for example.\n\nDo not create unit tests or explain your code. The goal is to provide an example of how this method could be used."},"name":"toRotationMatrix","code":"public Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}","location":{"start":79,"insert":79,"offset":" ","indent":1,"comment":null},"item_type":"method","length":7},{"id":"95b504a1-db50-9984-5b46-363d65e0e331","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"takes a `Quaternion` object `r` and returns the dot product of the two objects' coordinates.","params":[{"name":"r","type_name":"Quaternion","description":"4-dimensional quaternion value to be multiplied with the current quaternion, resulting in a new quaternion value that is returned as the function output.\n\n* `x`, `y`, `z`, and `w` are instance fields representing the real-valued components of `Quaternion`.\n* `getX()`, `getY()`, `getZ()`, and `getW()` are methods providing access to the respective component values.","complex_type":true}],"returns":{"type_name":"float","description":"a floating-point number representing the dot product of two quaternions.","complex_type":false},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 1, 0, 1);\nQuaternion q2 = new Quaternion(1, 0, 0, -1);\nfloat dp = q1.dot(q2); // dot product of two quaternions\n","description":"\nIn this example, we create two quaternions, `q1` and `q2`, using their respective constructors. We then call the dot method on `q1` to get the dot product of `q1` and `q2`. The resulting value should be `-1`."},"name":"dot","code":"public float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}","location":{"start":87,"insert":87,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"c065c765-ff20-ba95-694a-20f23be865ad","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"takes a destination quaternion `dest`, a lerp factor, and an optional shortest parameter. It calculates the interpolated quaternion using the LERP method, taking into account the sign of the dot product between the current quaternion and the destination quaternion, and normalizing the result to ensure it has the correct length.","params":[{"name":"dest","type_name":"Quaternion","description":"4-dimensional vector that the function will interpolate between using the provided `lerpFactor`.\n\n* `Quaternion dest`: The destination quaternion for interpolation.\n* `lerpFactor`: A factor used to interpolate between the source and destination quaternions.\n* `shortest`: An optional parameter that indicates whether the shortest path should be taken when interpolating between the source and destination quaternions. If true, the function will correct the destination quaternion if it would result in a negative dot product with the source quaternion.","complex_type":true},{"name":"lerpFactor","type_name":"float","description":"0-1 value for which the quaternion is linearly interpolated between the source and destination quaternions.","complex_type":false},{"name":"shortest","type_name":"boolean","description":"4-vector component of the destination quaternion to be corrected if it is less than -1, and sets it to its negative value instead.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a Quaternion that represents the interpolated rotation between two given Quaternions, taking into account the shortest path and the dot product of the two input Quaternions.\n\n* The output is a Quaternion object, representing a rotational transformation matrix.\n* The value of `dest` is interpolated between the input arguments `lerpFactor` and `shortest`, resulting in a corrected destination quaternion.\n* If `shortest` is true and the dot product of the source and destination quaternions is negative, the output is negated to ensure proper orientation.\n* The resulting quaternion is normalized to have a length of 1.","complex_type":true},"usage":{"language":"java","code":"Quaternion thisQuat = new Quaternion(0, 1, 0, 0); // Quaternion representing the current rotation of an object\nQuaternion destQuat = new Quaternion(0, 0, 0, 1); // Quaternion representing the desired rotation of the object after lerping\nfloat lerpFactor = 0.5f; // The amount by which to lerp between the current and destination rotations\nboolean shortest = true; // Whether or not to choose the shortest path\nQuaternion newQuat = thisQuat.NLerp(destQuat, lerpFactor, shortest);\n","description":"\nIn this example, we are lerping from the current rotation of an object (represented by `thisQuat`) towards the desired rotation of that object (represented by `destQuat`), with a lerp factor of 0.5f and choosing the shortest path between the two rotations. The resulting quaternion, represented by `newQuat`, will have a rotation of `(0, 0, 0, 1)`."},"name":"NLerp","code":"public Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}","location":{"start":91,"insert":91,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"2662fcbf-2244-369d-064c-6734436c70f7","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"computes a linear interpolation between two Quaternions based on their dot product and shortest path, with an optional adjustment for when the interpolated quaternion would be inverted.","params":[{"name":"dest","type_name":"Quaternion","description":"4-component quaternion that is to be interpolated towards a target quaternion, using linear interpolation with optional shortest path optimization.\n\n* `dest.getW()`: The scalar component of the quaternion representation of the destination point.\n* `dest.getX()`, `dest.getY()`, and `dest.getZ()`: The vector components of the quaternion representation of the destination point.\n\nThe `correctedDest` variable is created by modifying the original `dest` value when the cosine of the angle between the source and destination quaternions is negative, indicating a flipped orientation.","complex_type":true},{"name":"lerpFactor","type_name":"float","description":"factor by which the quaternion is to be linearly interpolated between the source and destination quaternions, with values ranging from 0 to 1.","complex_type":false},{"name":"shortest","type_name":"boolean","description":"3D-space distance between the starting and ending quaternions and determines whether to invert the quaternion when cosine is negative, returning a new quaternion if necessary.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a quaternion that interpolates between two given quaternions based on the Lerp formula.\n\n1. The output is a Quaternion object, which represents a 3D rotational transformation.\n2. The w-component (getW()) of the Quaternion represents the rotation angle around the axis of rotation.\n3. The x, y, and z-components (getX(), getY(), and getZ()) of the Quaternion represent the rotation along the corresponding axes.\n4. If `shortest` is set to true, then the rotation will be limited to the range (-π, π], otherwise, it will be unlimited.\n5. The `lerpFactor` parameter represents the interpolation factor between the source and destination Quaternions.","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 1, 2, 3);\nQuaternion q2 = new Quaternion(-1, -2, -3, -4);\nfloat lerpFactor = 0.5f;\nboolean shortest = true;\n\nQuaternion result = SLerp(q2, lerpFactor, shortest);\n","description":"\nIn this example, the method SLerp is used to interpolate between two Quaternions with a given factor of `lerpFactor`. The resulting interpolation will be in the direction of q1 towards q2. Additionally, the shortest path is taken by setting the `shortest` variable to true."},"name":"SLerp","code":"public Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}","location":{"start":100,"insert":100,"offset":" ","indent":1,"comment":null},"item_type":"method","length":23},{"id":"fe1b3882-c4df-d58e-5c4d-4e452121a2c7","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"rotates a vector by 90 degrees around the x-axis, resulting in a forward-facing vector.","params":[],"returns":{"type_name":"Vector3f","description":"a vector representing the direction of the rotated object.\n\nThe returned value is a `Vector3f` object representing the forward direction of the rotated object.\n\nThe `x`, `y`, and `z` components of the vector represent the offset from the origin in the x, y, and z directions, respectively.\n\nThe `rotation` property of the vector represents the amount of rotation applied to the object.","complex_type":true},"usage":{"language":"java","code":"Quaternion quat = new Quaternion(0, 0, 1, 0);\nVector3f forward = quat.getForward();\n","description":"\nExplanation: The Quaternion (q) is set to the identity rotation (no rotation). getForward() method is called on this object, which would return a vector in the direction of the positive z-axis (forward) after being rotated by q."},"name":"getForward","code":"public Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}","location":{"start":163,"insert":163,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"af2d94f9-d9d9-1f94-4643-234567f8ef71","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"rotates a vector by 90 degrees around the z-axis to return a new vector pointing backward from the current position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector with a magnitude of -1, representing the direction of the object's back.\n\nThe `Vector3f` object returned is a transformed version of the original vector with its x-component set to 0, y-component set to 0, and z-component set to -1. This transformation occurs as a result of applying the rotate operation to the original vector.","complex_type":true},"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Quaternion quat = new Quaternion(0, 0, -1, 0);\n        System.out.println(\"Quaternion's X: \" + quat.getX()); // prints '0'\n        System.out.println(\"Quaternion's Y: \" + quat.getY()); // prints '-1'\n        System.out.println(\"Quaternion's Z: \" + quat.getZ()); // prints '0'\n        System.out.println(\"Quaternion's W: \" + quat.getW()); // prints '0'\n        \n        Vector3f back = quat.getBack();\n        System.out.println(\"Vector's X: \" + back.getX()); // prints '-1'\n        System.out.println(\"Vector's Y: \" + back.getY()); // prints '0'\n        System.out.println(\"Vector's Z: \" + back.getZ()); // prints '0'\n    }\n}\n","description":"\nExplanation: \nThe main function creates an object of type Quaternion, which contains the quaternion coordinates as x=0, y=-1, z=0 and w=0. The getBack method is used to rotate this vector by a quaternion. The resultant vector back's values are then printed out using its getX(), getY() and getZ() methods. \nThis example works correctly as the Quaternion is rotated by 180 degrees around the Z axis, resulting in a vector pointing in the opposite direction from the original vector."},"name":"getBack","code":"public Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}","location":{"start":167,"insert":167,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"749b0859-e307-c993-0040-788067088001","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"rotates a vector by 90 degrees around the z-axis, resulting in a vector pointing upwards from the original position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector representing the upward direction relative to the object's orientation.\n\nThe output is a `Vector3f` object, which represents a 3D vector in standard form (x, y, z).\nThe vector is rotated by multiplying it with the rotation matrix of the object.\nThe rotation matrix is obtained by calling the `rotate` method on the object itself.\nThe resulting vector has the same direction as the original vector, but its magnitude is proportional to the dot product of the original vector and the rotation matrix.","complex_type":true},"usage":{"language":"java","code":"Vector3f up = quat.getUp();\n","description":"\nThis will return a vector (0, 1, 0) rotated by the given quaternion. This vector represents the \"up\" direction of the rotation in world coordinates."},"name":"getUp","code":"public Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}","location":{"start":171,"insert":171,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"db605ac9-ef33-cbac-7e49-0e0ab899a428","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"rotates a vector by 90 degrees around the x-axis, resulting in a new vector pointing downward from the original position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector representing the direction down from the current position.\n\nThe output is a `Vector3f` object representing the downward direction from the current position of the `Entity` instance. The vector has three components: x, y, and z, each representing the distance from the current position along the respective axis.","complex_type":true},"usage":{"language":"java","code":"public class Test {\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(); // create a new quaternion object\n        \n        Vector3f down = q.getDown(); // rotate the down vector by the quaternion\n        \n        System.out.println(down);\n    }\n}\n","description":"\nThis code will print a vector that is rotated 180 degrees around the y-axis, which is what the getDown method would return if it were called on this quaternion object."},"name":"getDown","code":"public Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}","location":{"start":175,"insert":175,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"ebd8b7b8-d993-c4af-dd4e-d24152c6d573","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"rotates a vector by 90 degrees around the x-axis, resulting in a new vector that points towards the right.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector with a magnitude of 1 and an orientation of 90 degrees around the x-axis.\n\nThe `Vector3f` object that is returned has three components representing the x, y, and z values of the right vector, respectively. The value of each component is determined by applying a rotation transformation to the original vector using the `rotate` method. Specifically, the rotation is performed around the x-axis, with the z-axis serving as the origin of the rotation. This means that the resulting vector points in the direction of the positive y-axis, passing through the origin.","complex_type":true},"usage":{"language":"java","code":"// Create a new Quaternion and rotate a Vector3f by it\nQuaternion q = new Quaternion(0, 1, 0, 0);\nVector3f vec = new Vector3f(1, 0, 0).rotate(q);\nSystem.out.println(\"Result: \" + vec);\n","description":"\nThis example creates a new `Quaternion` with an x-axis angle of 90 degrees and rotates the `Vector3f (1, 0, 0)` by this quaternion using the `rotate(Vector3f)` method. The result is then printed out to the console.\n\nIt's important to note that Quaternions are a mathematical construct and cannot be used for visual representation of rotations in games or other applications without further processing. This example only shows how the getRight() method would work on mathematical basis, not as a user facing API."},"name":"getRight","code":"public Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}","location":{"start":179,"insert":179,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"eb6210d1-cf53-6390-354b-11c95414a683","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"rotates a vector by 90 degrees to the left, resulting in a new vector that points in the opposite direction of the original vector's tail.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector of size (1, 0, 0).\n\nThe output is a vector in 3D space with magnitude of -1 and direction pointing leftward from the origin.\nWhen the vector is rotated by the same amount as the object it was taken from, the resulting vector points back to the original position of the object.\nThe rotation is performed using the `rotate` method of the `Vector3f` class, which takes in the object being rotated and returns a new vector transformed by that rotation.","complex_type":true},"usage":{"language":"java","code":"public class Test {\n    public static void main(String[] args) {\n        Quaternion quat = new Quaternion();\n        Vector3f left = quat.getLeft();\n        System.out.println(left); // Outputs the vector (-1, 0, 0) rotated by the quaternion q.\n    }\n}\n","description":""},"name":"getLeft","code":"public Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}","location":{"start":183,"insert":183,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"db836c01-a289-feb0-ea40-51e726fce74e","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"sets the values of a `Quaternion` object's `x`, `y`, `z`, and `w` fields to the input arguments.","params":[{"name":"x","type_name":"float","description":"3D position of the quaternion in the x-axis direction.","complex_type":false},{"name":"y","type_name":"float","description":"2D component of the quaternion.","complex_type":false},{"name":"z","type_name":"float","description":"3rd component of the quaternion, which is updated to match the provided value.","complex_type":false},{"name":"w","type_name":"float","description":"4th component of the quaternion, which is used to store the magnitude of the quaternion.","complex_type":false}],"returns":{"type_name":"instance","description":"a reference to the same `Quaternion` instance, allowing for chaining of method calls.\n\n* The `this` keyword is used to refer to the current instance of the `Quaternion` class.\n* The `x`, `y`, `z`, and `w` parameters represent the new values for each component of the quaternion, respectively.\n* By assigning these values to the respective fields of the `Quaternion` object, the function updates the quaternion's components.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nq.set(0, 0, 1, 0); // x, y, z, w\n","description":"\nIn this example, we create a new quaternion and call the set method with the values of (x, y, z, w) which are all zeros except for the last one which is 1. This sets the quaternion to point downwards in the Z-axis."},"name":"set","code":"public Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}","location":{"start":187,"insert":187,"offset":" ","indent":1,"comment":null},"item_type":"method","length":7},{"id":"04588c76-28df-1282-4748-a299d9076344","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"converts a vector of Euler angles into a quaternion representation, which is a more efficient and intuitive way to represent 3D rotations.","params":[{"name":"eulerAngles","type_name":"Vector3f","description":"3D Euler angles, specifically the phi, theta, and yota angles, which are used to calculate the quaternion representation of the rotation.\n\n* `phi`: The zenith angle of the quaternion, which ranges from 0 to 2π.\n* `theta`: The azimuth angle of the quaternion, which ranges from 0 to 2π.\n* `yota`: The elevation angle of the quaternion, which ranges from -π to π.\n\nThe function then performs various calculations involving these angles using mathematical constants and operations to produce the final output: a Quaternion object.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a quaternion representation of the input Euler angles.\n\n* `q0`, `q1`, `q2`, and `q3` represent the four components of the quaternion, which are calculated based on the input `eulerAngles`.\n* These components are represented as floats, with a range of -1 to 1.\n* The quaternion is a 4D vector representation of a rotation in 3D space, where each component represents a factor of the rotation.\n* The order of the components is (w, x, y, z), where w is the magnitude of the quaternion and the other three components represent the axis of rotation.\n* The values of `q0`, `q1`, `q2`, and `q3` can be used to perform rotations in 3D space using the quaternion multiplication formula.","complex_type":true},"name":"fromEuler","code":"public static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}","location":{"start":200,"insert":200,"offset":" ","indent":1,"comment":{"start":194,"end":199}},"item_type":"method","length":23},{"id":"a4cc9cab-0c94-1c80-e447-172c01568280","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"sets the values of a Quaternion object to those of another Quaternion object, without changing its internal representation.","params":[{"name":"r","type_name":"Quaternion","description":"4-component quaternion that modifies the components of the `this` quaternion.\n\n* `getX()` and `getY()` represent the x-coordinates of the quaternion's coordinates.\n* `getZ()` and `getW()` represent the z-coordinates and the \"wrap angle\" (or \"wrapping angle\") of the quaternion, respectively.\n\nThese properties are used to set the values of this quaternion's coordinates accordingly.","complex_type":true}],"returns":{"type_name":"instance","description":"a reference to the same Quaternion object, unchanged.\n\n* This function sets the values of the Quaternion object to those of the input argument.\n* The function takes four arguments, representing the x, y, z, and w components of the input quaternion.\n* The function returns a reference to the same Quaternion object, indicating that the method modifies the original object rather than returning a new one.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nQuaternion r = new Quaternion(1, 2, 3, 4);\nq.set(r);\n","description":"\nThis code will create two quaternions (q and r). The method set(Quaternion) of the class Quaternion will take in the second argument as a reference to an existing Quaternion object, then it will copy the values of the x, y, z, and w attributes of that object into the corresponding attributes of q. \nSo the value of q would be identical to the value of r after the execution of this code snippet."},"name":"set","code":"public Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}","location":{"start":224,"insert":224,"offset":" ","indent":1,"comment":null},"item_type":"method","length":4},{"id":"30f1072b-e9db-e481-ba49-639f60ac061e","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"retrieves the value of a `float` variable named `x`.","params":[],"returns":{"type_name":"float","description":"a floating-point value representing the variable `x`.","complex_type":false},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion q = new Quaternion();\n    q.set(0, 1, 2, 3);\n    System.out.println(q.getX()); // 0.0f\n}\n","description":"\nIn this example, a new quaternion is created and its values are set to 0, 1, 2, and 3 respectively using the constructor Quaternion(). The method getX() is then used on the object q which prints out the value of the x component of the quaternion which is 0."},"name":"getX","code":"public float getX() {\n\t\treturn x;\n\t}","location":{"start":229,"insert":229,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"9f98f64e-c37b-a387-224c-1c32df2fa05c","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"sets the value of the instance field `x` to the provided float argument.","params":[{"name":"x","type_name":"float","description":"float value that will be assigned to the class instance variable `x`.","complex_type":false}],"usage":{"language":"java","code":"Quaternion q = new Quaternion(); // create a new quaternion object\nq.setX(0.5f);  // set the x component of the quaternion to 0.5\nSystem.out.println(q.getX()); // prints 0.5\n","description":"\nThis example shows that the method setX is used to set the value of the x component of a quaternion object. The method takes in one argument, which is a float and assigns it to the x component of the quaternion. The method then returns the modified quaternion so that it can be used further down the line.\n\nIt is important to note that this example is only for setting the value of the x component of the quaternion and not for creating a new quaternion object. This means that if you wanted to create a new quaternion object with an initial x value, you would have to call the constructor and then set the value."},"name":"setX","code":"public void setX(float x) {\n\t\tthis.x = x;\n\t}","location":{"start":233,"insert":233,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"cec16fe0-b2fb-ccb1-2a4b-ea0929fda596","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"returns the value of the variable `y`.","params":[],"returns":{"type_name":"float","description":"the value of the `y` field, which is a floating-point number.","complex_type":false},"usage":{"language":"java","code":"public class Example {\n    public static void main(String[] args) {\n        Quaternion quaternion = new Quaternion();\n        float y = quaternion.getY();\n        System.out.println(\"The value of y is \" + y);\n    }\n}\n","description":""},"name":"getY","code":"public float getY() {\n\t\treturn y;\n\t}","location":{"start":237,"insert":237,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"a846df21-a9da-b2a5-034b-1faf876c546b","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"sets the value of the `y` field of the object it is called on to the provided float argument.","params":[{"name":"y","type_name":"float","description":"float value to be assigned to the `y` field of the class instance, and it is being assigned using the `this.y = y;` statement.","complex_type":false}],"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion q = new Quaternion();\n    q.setY(90);\n}\n","description":""},"name":"setY","code":"public void setY(float y) {\n\t\tthis.y = y;\n\t}","location":{"start":241,"insert":241,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"da1570aa-8f3d-6da4-e34c-e4f6fc8e39d1","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"retrieves the value of a `float` variable named `z`.","params":[],"returns":{"type_name":"float","description":"the value of the `z` field.","complex_type":false},"usage":{"language":"java","code":"public class Example {\n\tpublic static void main(String[] args) {\n\t\tQuaternion q = new Quaternion(); // create a quaternion object\n\t\tq.setX(1); // set the x-axis value of the quaternion\n\t\tq.setY(2); // set the y-axis value of the quaternion\n\t\tq.setZ(3); // set the z-axis value of the quaternion\n\t\tSystem.out.println(\"The Quaternion's Z value is: \" + q.getZ()); // print out the z-axis value of the quaternion\n\t}\n}\n","description":"\nThis example will create a new quaternion object, set its x-axis, y-axis, and z-axis values, then print out its z-axis value using method getZ."},"name":"getZ","code":"public float getZ() {\n\t\treturn z;\n\t}","location":{"start":245,"insert":245,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"2271d523-7ca4-b099-e040-a688ac0f696b","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"sets the value of the field `z` of the object it is called on to the argument passed as a float.","params":[{"name":"z","type_name":"float","description":"3D coordinate of an object in the function `setZ()`.","complex_type":false}],"usage":{"language":"java","code":"Quaternion q = new Quaternion(0, 0, 0, 1);\nq.setZ(5);\n","description":"\nThis would set the value of 'z' to 5 and keep all other values unchanged."},"name":"setZ","code":"public void setZ(float z) {\n\t\tthis.z = z;\n\t}","location":{"start":249,"insert":249,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"88c6bf68-1b60-14b8-a941-af14610fda2f","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"retrieves the value of a `w` field, which is likely used to store a specific value related to the program's functionality.","params":[],"returns":{"type_name":"float","description":"the value of the `w` field.","complex_type":false},"usage":{"language":"java","code":"Quaternion q = new Quaternion(0, 0, 0, 1);\nfloat w = q.getW();\n// w should now contain the value of 1\n","description":"\nThis is a very short example, and it's not the best way to use the method, but it shows how it would be used. It is also important to note that this is not the recommended way to create a Quaternion object as it does not follow best practices in Java. A better approach would be:\n"},"name":"getW","code":"public float getW() {\n\t\treturn w;\n\t}","location":{"start":253,"insert":253,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"2ac992af-116b-2fb5-c048-b9bcb64ba058","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"sets the `w` field of its object argument to the provided float value.","params":[{"name":"w","type_name":"float","description":"floating-point value that sets the width of an object.","complex_type":false}],"usage":{"language":"java","code":"public class Example {\n\tpublic static void main(String[] args) {\n\t\tQuaternion quat = new Quaternion();\n\t\tquat.setX(-0.543f);\n\t\tquat.setY(0.123f);\n\t\tquat.setZ(0.654f);\n\t\tquat.setW(1.579f);\n\t}\n}\n","description":"\nThis is a very short example, but it should demonstrate how setW can be used to set the value of the w component in a Quaternion object. In this case, it is setting w to 1.579f. It is important to note that this method only sets the value for the w component and does not alter any other components of the Quaternion object."},"name":"setW","code":"public void setW(float w) {\n\t\tthis.w = w;\n\t}","location":{"start":257,"insert":257,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"9e4af112-4e65-a98a-4a48-c038dd87d79b","ancestors":["7013fc73-856b-aa81-1642-07175010035e"],"type":"function","description":"compares a `Quaternion` object with another `Quaternion` object and returns `true` if all components are equal, otherwise `false`.","params":[{"name":"r","type_name":"Quaternion","description":"Quaternion to which the current Quaternion is compared for equality.\n\n* `x`: represents the real part of the quaternion\n* `y`: represents the imaginary part of the quaternion\n* `z`: represents the scalar part of the quaternion\n* `w`: represents the vector part of the quaternion","complex_type":true}],"returns":{"type_name":"boolean","description":"a boolean value indicating whether the given quaternion is equal to the current quaternion.","complex_type":false},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 0, 0, 1); // quaterion with (w, x, y, z) = (1, 0, 0, 0)\nQuaternion r = new Quaternion(1, 0, 0, 0); // quaterion with (w, x, y, z) = (1, 0, 0, 0)\nif(q1.equals(r)) {\n\tSystem.out.println(\"Quaternions are equal.\");\n}\n","description":"\nExplanation:\nThe method equals is used to check if the given quaterion object 'r' is equal to the current quaternion object q1. The method returns true if the two objects have the same components, and false otherwise. The example code creates a new Quaternion object with (w, x, y, z) = (1, 0, 0, 0) as 'r' and checks if it is equal to 'q1'. Since 'q1' has the same components as 'r', the method returns true."},"name":"equals","code":"public boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}","location":{"start":261,"insert":261,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3}]}}}