{"name":"Quaternion.java","path":"src/com/ch/math/Quaternion.java","content":{"structured":{"description":"A `Quaternion` class for representing 3D rotations in homogeneous coordinates, with methods for constructing quaternions from Euler angles and other rotation representations, as well as methods for calculating matrix multiplication, dot product, and angle between two quaternions. The code also provides utility methods for converting between rotation representations, such as from Euler angles to rotation matrices or from rotation matrices to quaternions.","items":[{"id":"9bf2183e-0ba3-bcb7-0941-0eebb024c2b1","ancestors":[],"type":"function","description":"is a mathematical representation of a rotation in three dimensions. It has several methods for calculating rotations, including setting x, y, z, and w fields directly, as well as methods for getting forward, back, up, down, right, and left directions. It also has a method for converting Euler angles to a Quaternion representation.","name":"Quaternion","code":"public class Quaternion {\n\n\tprivate float x;\n\tprivate float y;\n\tprivate float z;\n\tprivate float w;\n\n\tpublic Quaternion() {\n\t\tthis(0, 0, 0, 0);\n\t}\n\n\t\n\tpublic Quaternion(float w, float x, float y, float z) {\n\t\tthis.w = w;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n\n\tpublic Quaternion(Vector3f axis, float angle) {\n\t\tfloat sinHalfAngle = (float) Math.sin(angle / 2);\n\t\tfloat cosHalfAngle = (float) Math.cos(angle / 2);\n\n\t\tthis.x = axis.getX() * sinHalfAngle;\n\t\tthis.y = axis.getY() * sinHalfAngle;\n\t\tthis.z = axis.getZ() * sinHalfAngle;\n\t\tthis.w = cosHalfAngle;\n\t}\n\n\tpublic float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}\n\n\tpublic Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}\n\n\tpublic Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}\n\n\tpublic Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}\n\n\tpublic Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\tpublic Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\tpublic Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}\n\n\tpublic Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}\n\n\tpublic Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}\n\n\tpublic float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}\n\n\tpublic Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}\n\n\tpublic Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}\n\n\t// From Ken Shoemake's \"Quaternion Calculus and Fast Animation\" article\n\tpublic Quaternion(Matrix4f rot) {\n\t\tfloat trace = rot.get(0, 0) + rot.get(1, 1) + rot.get(2, 2);\n\n\t\tif (trace > 0) {\n\t\t\tfloat s = 0.5f / (float) Math.sqrt(trace + 1.0f);\n\t\t\tw = 0.25f / s;\n\t\t\tx = (rot.get(1, 2) - rot.get(2, 1)) * s;\n\t\t\ty = (rot.get(2, 0) - rot.get(0, 2)) * s;\n\t\t\tz = (rot.get(0, 1) - rot.get(1, 0)) * s;\n\t\t} else {\n\t\t\tif (rot.get(0, 0) > rot.get(1, 1) && rot.get(0, 0) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(0, 0) - rot.get(1, 1) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(1, 2) - rot.get(2, 1)) / s;\n\t\t\t\tx = 0.25f * s;\n\t\t\t\ty = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\tz = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t} else if (rot.get(1, 1) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(1, 1) - rot.get(0, 0) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(2, 0) - rot.get(0, 2)) / s;\n\t\t\t\tx = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\ty = 0.25f * s;\n\t\t\t\tz = (rot.get(2, 1) + rot.get(1, 2)) / s;\n\t\t\t} else {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(2, 2) - rot.get(0, 0) - rot.get(1, 1));\n\t\t\t\tw = (rot.get(0, 1) - rot.get(1, 0)) / s;\n\t\t\t\tx = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t\ty = (rot.get(1, 2) + rot.get(2, 1)) / s;\n\t\t\t\tz = 0.25f * s;\n\t\t\t}\n\t\t}\n\n\t\tfloat length = (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t\tx /= length;\n\t\ty /= length;\n\t\tz /= length;\n\t\tw /= length;\n\t}\n\n\tpublic Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}\n\n\tpublic Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}\n\n\tpublic Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}\n\n\tpublic Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param eulerAngles - @see <a href=\"https://en.wikipedia.org/wiki/Euler_angles#Proper_Euler_angles\">Wikipedia's Article on Euler Angles</a> for a description\n\t *                    of their usage/definition.\n\t * @return The {@link Quaternion} associated with the Euler angles.\n\t */\n\tpublic static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}\n\n\tpublic Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}\n\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\tpublic void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\tpublic float getZ() {\n\t\treturn z;\n\t}\n\n\tpublic void setZ(float z) {\n\t\tthis.z = z;\n\t}\n\n\tpublic float getW() {\n\t\treturn w;\n\t}\n\n\tpublic void setW(float w) {\n\t\tthis.w = w;\n\t}\n\n\tpublic boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}\n\t\n}","location":{"start":6,"insert":6,"offset":" ","indent":0,"comment":null},"item_type":"class","length":260},{"id":"9f2dbae3-4d08-248d-b748-b3013bb62f0e","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"calculates the Euclidean distance of a 3D point from origin using the formula (x^2 + y^2 + z^2)^(1/2).","params":[],"returns":{"type_name":"float","description":"the square root of the sum of the squares of the component values of a vector.","complex_type":false},"usage":{"language":"java","code":"public static void main(String[] args) {\n    // Initialize a quaternion with random values\n    Quaternion q = new Quaternion(0.5f, 0.25f, -0.125f, 0.75f);\n    \n    // Print the length of the quaternion (should be approximately equal to 1)\n    System.out.println(\"The length of the quaternion is \" + q.length());\n}\n","description":""},"name":"length","code":"public float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}","location":{"start":35,"insert":35,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"f6b0aa9c-82ff-b085-be41-a77328c3a1ce","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"normalizes a given quaternion by dividing each component by its length, resulting in a quaternion with a length of 1.","params":[],"returns":{"type_name":"Quaternion","description":"a normalized quaternion representation of the original input quaternion.\n\n* The first component of the Quaternion represents the magnitude of the quaternion, which is computed as `w / length`.\n* The second and third components represent the x and y coordinates of the quaternion, respectively, and are computed as `x / length` and `y / length`, respectively.\n* The fourth component represents the z coordinate of the quaternion and is computed as `z / length`.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(0, 0, 0, 0).normalized();\n","description":"\nHere the quaternion q is initialized with 0, 0, 0, and 0 as its components. Then it is normalized to a length of 1 using method normalized() which returns a new Quaternion object with components w / length, x / length, y / length, z / length respectively. The length of the quaternion is calculated using method length().\n"},"name":"normalized","code":"public Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}","location":{"start":39,"insert":39,"offset":" ","indent":1,"comment":null},"item_type":"method","length":5},{"id":"80a448fb-1a37-89bd-8943-9a37aba35a35","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"generates a new quaternion with the same magnitude as the original but with the axis reversed.","params":[],"returns":{"type_name":"instance","description":"a new quaternion with the same w value as the input, and the opposite x, y, and z values.\n\n* The input argument `w` is unchanged in the output quaternion.\n* The input arguments `-x`, `-y`, and `-z` are combined to create a new quaternion with the same magnitude as the original but with its sign flipped.","complex_type":true},"usage":{"language":"java","code":"// Example usage of the conjugate method\nQuaternion q = new Quaternion(1, 2, 3, 4);\nq.conjugate(); // x = -2, y = -3, z = -4, w = 1\n","description":"\nThe example code is short and to the point because it only uses one line of code to demonstrate how the conjugate method works. The code creates a quaternion with a specific set of values and then invokes the conjugate method on that quaternion, resulting in a new quaternion with the same real part as the original but with all of its imaginary parts negated. This helps demonstrate the effect of the conjugate method on a quaternion and how it can be used to perform mathematical operations on it.\n\nIt is important to note that this example does not provide an explanation for the code. The code should work correctly, without any syntax or compilation errors. The example should never create incorrect inputs for the conjugate method. It is also important to never hallucinate incorrect inputs for the conjugate method."},"name":"conjugate","code":"public Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}","location":{"start":45,"insert":45,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"74d803a9-497c-9c86-674d-3d955c2fd576","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"multiplies a quaternion by a scalar value, returning a new quaternion with the product.","params":[{"name":"r","type_name":"float","description":"4-dimensional vector that is multiplied with the quaternion.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a quaternion representation of the product of the input scalar value and the quaternion's components.\n\n* The output is a new instance of the `Quaternion` class.\n* The `w`, `x`, `y`, and `z` fields of the input quaternion are multiplied by the input `r`.\n* The resultant quaternion represents a rotation by the angle `r` around the origin.","complex_type":true},"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Quaternion quat1 = new Quaternion();\n        Quaternion quat2 = new Quaternion();\n        float r = 0.5f;\n        \n        quat1.setX(1);\n        quat1.setY(1);\n        quat1.setZ(1);\n        quat1.setW(1);\n        \n        quat2.setX(-1);\n        quat2.setY(-1);\n        quat2.setZ(-1);\n        quat2.setW(-1);\n        \n        Quaternion result = quat1.mul(r);\n        System.out.println(\"The resulting quaternion is: \" + result);\n    }\n}\n","description":""},"name":"mul","code":"public Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}","location":{"start":49,"insert":49,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"b3f2aa7e-bd36-5ab7-0243-5c083bf0bb9a","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"computes the product of two quaternions and returns the result as a new quaternion.","params":[{"name":"r","type_name":"Quaternion","description":"quaternion to be multiplied with the current quaternion, and its value is used to compute the output quaternion's components.\n\n* `w`: The magnitude (or length) of the quaternion, represented as a float value.\n* `x`, `y`, and `z`: The coefficients of the quaternion's rotation representation, represented as floats.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new quaternion object representing the result of multiplying the input quaternions.\n\n* The output is a new `Quaternion` instance with the multiplied values of `w`, `x`, `y`, and `z` components.\n* The `w_` component represents the product of `w` and `r.getW()` components, minus the sum of `x`, `y`, and `z` components of `r` multiplied by their respective coefficients.\n* The `x_`, `y_`, and `z_` components represent the products of `x`, `y`, and `z` components of `this` quaternion and `r`, respectively, minus the sums of their respective coefficients.\n\nThe output has the following attributes:\n\n* It is a valid quaternion with non-negative `w` component and `x`, `y`, and `z` components that sum to zero.\n* Its `w` component represents the magnitude of the quaternion, which is equal to the product of `w_` and the absolute value of `r.getW()`.\n* Its `x`, `y`, and `z` components represent the directions of the quaternion, which are related to the directions of the original quaternion and the multiplicand quaternion.","complex_type":true},"usage":{"language":"java","code":"// Create two quaternions with random values\nQuaternion q1 = new Quaternion(float) Math.random(), ((float) Math.random()), ((float) Math.random()));\nQuaternion q2 = new Quaternion(q1.getW() + 10, q1.getX() - 3, q1.getY() + 5, q1.getZ() + 7);\n// Multiply the two quaternions together\nQuaternion r = q1.mul(q2);\n","description":"\nThis method is used to multiply a quaternion with another quaternion. The resulting quaternion would represent the same rotation as multiplying the two original quaternions together. Note that the multiplication of two quaternions can also be represented by a matrix."},"name":"mul","code":"public Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}","location":{"start":53,"insert":53,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"2df3c666-910f-8281-5743-4140cefc922f","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"multiplies a quaternion by a vector, resulting in another quaternion with the same magnitude but rotated in the opposite direction.","params":[{"name":"r","type_name":"Vector3f","description":"3D vector to be multiplied with the quaternion.\n\n* `getX()` and `getY()` are methods that return the x-coordinates and y-coordinates of the vector, respectively.\n* `getZ()` returns the z-coordinate of the vector.\n\nThe function then computes the product of the quaternion and the vector using the multiplication of the scalar component of the quaternion with the corresponding components of the vector. The resulting quaternion is then returned.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new `Quaternion` object containing the product of the input `Vector3f` and the quaternion.\n\n* The returned `Quaternion` instance has four components: `w`, `x`, `y`, and `z`. These represent the real and imaginary parts of the quaternion multiplication.\n* The values of `w`, `x`, `y`, and `z` are determined by the multiplication of the input `Vector3f` instances `r` and the quaternion representation of the function. Specifically, they are calculated as: `w = -x * r.getX() - y * r.getY() - z * r.getZ()`, `x_ = w * r.getX() + y * r.getZ() - z * r.getY()`, `y_ = w * r.getY() + x * r.getX() - z * r.getZ()`, and `z_ = w * r.getZ() + x * r.getY() - y * r.getX()`.\n* The output quaternion represents the result of multiplying the input quaternion with the provided vector, which can be used in various applications such as 3D graphics, robotics, and computer vision.","complex_type":true},"usage":{"language":"java","code":"Vector3f vector = new Vector3f(1, 2, 3);\nQuaternion quat = new Quaternion();\nquat.set(0, 1, 0, 0);\nQuaternion result = quat.mul(vector);\n","description":"\nThis code will multiply the quaternion 'quat' with a vector of x = 1, y = 2, and z = 3. The resulting quaternion would be a quaternion representing the rotation of the vector by the quaternion 'quat'. Note that this is just an example, the actual implementation may vary depending on the context in which the method is used."},"name":"mul","code":"public Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}","location":{"start":62,"insert":62,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"baf6c47c-5c14-03aa-1f47-c3e78a3f827d","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"takes a Quaternion `r` and returns a new Quaternion with the difference between the input and the current instance.","params":[{"name":"r","type_name":"Quaternion","description":"4-dimensional vector to be subtracted from the current quaternion.\n\nThe `Quaternion r` is a serialized representation of a quaternion value with four elements - `w`, `x`, `y`, and `z`. Each element represents a real number that contributes to the overall quaternion value.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new quaternion with the difference of the input quaternion's values.\n\nThe Quaternion `r` is subtracted from the input Quaternion `this`, resulting in a new Quaternion object with the values `w - r.getW()`, `x - r.getX()`, `y - r.getY()`, and `z - r.getZ()`.","complex_type":true},"usage":{"language":"java","code":"public class Example {\n    public static void main(String[] args) {\n        Quaternion r = new Quaternion(1, 2, 3, 4);\n        Quaternion q = new Quaternion(5, 6, 7, 8);\n        Quaternion result = r.sub(q);\n        System.out.println(\"r: \" + r);\n        System.out.println(\"q: \" + q);\n        System.out.println(\"result: \" + result);\n    }\n}\n","description":"\nThe output of this example would be:\n"},"name":"sub","code":"public Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}","location":{"start":71,"insert":71,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"065654bc-6afc-b2a8-f04a-db1da744865b","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"takes a `Quaternion` object `r` and returns a new `Quaternion` object representing the sum of the two quaternions.","params":[{"name":"r","type_name":"Quaternion","description":"4D vector to be added to the current quaternion.\n\n* `w`: The real part of the quaternion.\n* `x`, `y`, and `z`: The imaginary parts of the quaternion, each representing a complex number.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new Quaternion object representing the sum of the input quaternions.\n\n* The `Quaternion` object returned has a value that is the sum of the values of the input objects.\n* The `W`, `X`, `Y`, and `Z` fields of the returned object represent the real and imaginary parts of the quaternion, which are the sums of their corresponding fields from the input objects.\n* The resulting quaternion has the same rotation angle as the input quaternions.","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 1, 0, 0);\nQuaternion q2 = new Quaternion(0, 0, 0, 1);\nQuaternion sum = q1.add(q2);\n","description":"\nThe resulting quaternion sum would be (0, 1, 0, 1)"},"name":"add","code":"public Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}","location":{"start":75,"insert":75,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"862114a9-bd5b-aa9f-d64d-76494b679992","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"computes a rotation matrix based on three unit vectors representing the axis of rotation and the angle of rotation. The resulting matrix can be used for various purposes, such as rotating objects in 3D space.","params":[],"returns":{"type_name":"Matrix4f","description":"a 4x4 rotation matrix representing the given rotation.\n\n* The Matrix4f object represents a 4x4 homogeneous transformation matrix.\n* The elements of the matrix are defined based on the input values of x, y, and z, which represent the rotational angles about the x, y, and z axes, respectively.\n* The resulting matrix has the following properties:\n\t+ It represents a rotation around the origin, as expected from the input angles.\n\t+ The determinant of the matrix is non-zero, indicating that the matrix is invertible and can be used for transformations.\n\t+ The elements of the matrix are scaled by factors of 2, which is a common convention in 3D graphics and computer vision applications.","complex_type":true},"usage":{"language":"java","code":"Quaternion quat = new Quaternion(1.0f, 2.0f, 3.0f, 4.0f); // a random quaternion\nMatrix4f rotationMatrix = quat.toRotationMatrix(); // convert to rotation matrix\n","description":"\nThis is how the example code would work:\nThe given quaternion (x, y, z, w) is converted into a rotation matrix. The forward vector of the rotation matrix is calculated using the following formula: 2*(x*z - w*y), 2*(y*z + w*x), and 1 - 2*(x*x + y*y). The up vector and right vector are calculated similarly, as follows: 2*(x*y + w*z), 1 - 2*(x*x + z*z), and 2*(x*z + w*y) respectively.\nThe resulting rotation matrix is then constructed using these three vectors.\nThis method would work correctly for any quaternion."},"name":"toRotationMatrix","code":"public Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}","location":{"start":79,"insert":79,"offset":" ","indent":1,"comment":null},"item_type":"method","length":7},{"id":"d30496e5-6145-d3a7-704f-1eea72c036b8","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"computes the dot product of a quaternion and another quaternion, returning a float value representing the magnitude of the cross product between the two quaternions.","params":[{"name":"r","type_name":"Quaternion","description":"4-dimensional quaternion to be multiplied with the current quaternion, resulting in the dot product of the two quaternions.\n\n* `x`, `y`, `z`, and `w` represent the real components of the quaternion.\n* The `getX()`, `getY()`, `getZ()`, and `getW()` methods return the individual real values of the quaternion.","complex_type":true}],"returns":{"type_name":"float","description":"a floating-point number representing the dot product of the input quaternion and the provided quaternion.","complex_type":false},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 0, 0, 0);\nQuaternion r = new Quaternion(2, 3, 4, 5);\nfloat d = q.dot(r); // d == 14\n","description":"\nIn this example, dot method is used to calculate the dot product of two quaternions which are stored in the variables 'q' and 'r'. The result of the dot product is then stored in the variable 'd'. It can be seen that the dot product of these quaternions is 14."},"name":"dot","code":"public float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}","location":{"start":87,"insert":87,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"0f61b363-f729-15b7-1340-f3dc63be664e","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"computes a linear interpolation between two quaternions based on the given lerp factor and whether the resulting quaternion should be shortest.","params":[{"name":"dest","type_name":"Quaternion","description":"4-dimensional vector that will be modified to perform a linear interpolation of two other quaternions using the `NLerp()` method.\n\n* `Quaternion dest`: This represents a quaternion value that is used to calculate the lerped result. It has four attributes - `w`, `x`, `y`, and `z` - which correspond to the real and imaginary parts of the quaternion.","complex_type":true},{"name":"lerpFactor","type_name":"float","description":"0 to 1 value that determines how quickly the Quaternion is interpolated or smoothed between the source and destination values.","complex_type":false},{"name":"shortest","type_name":"boolean","description":"shortest quaternion route between the given `dest` and the result, by negating the quaternion if necessary to ensure the dot product of the resulting quaternion with `dest` is as small as possible.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a new quaternion that represents a linear interpolation between the input `dest` and the original quaternion.\n\n* The output is a `Quaternion` object that represents the interpolated rotation between the two input quaternions.\n* If `shortest` is true and the dot product of the input quaternions is less than 0, the output quaternion is flipped to ensure that the result is in the positive quadrant.\n* The output is normalized to have a length of 1.","complex_type":true},"usage":{"language":"java","code":"Quaternion start = new Quaternion(0, 1, 0, 0);\nQuaternion dest = new Quaternion(1, 0, 0, 0);\nQuaternion result = start.NLerp(dest, 0.5f, true);\n","description":"\nThe input values are as follows:\n\n* `dest`: The destination quaternion. In this case, the value is `(1, 0, 0, 0)`.\n* `lerpFactor`: The factor of how much to lerp towards the destination. In this case, the value is `0.5`.\n* `shortest`: Whether to use the shortest path between two quaternions or not. In this case, it is set to `true`.\n\nThe result will be a quaternion that represents a 90 degree angle around the Y axis."},"name":"NLerp","code":"public Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}","location":{"start":91,"insert":91,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"849474a6-519b-b59a-584d-2b0f532a4666","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"calculates a quaternion interpolation between two given quaternions, accounting for shortest path and smoothness constraints. It returns a new quaternion that represents the interpolation between the input quaternions.","params":[{"name":"dest","type_name":"Quaternion","description":"4D quaternion that the method will lerp to, with its magnitude and direction being adjusted based on the `lerpFactor` parameter and the `shortest` parameter.\n\n* `dot(dest)`: returns the dot product of the current quaternion and `dest`.\n* `cos`: returns the cosine of the dot product of the current quaternion and `dest`.\n* `shortest`: a boolean indicating whether to normalize `dest` if its dot product with the current quaternion is negative.\n* `correctedDest`: a new quaternion instance created by normalizing `dest` if `shortest` is true and its dot product with the current quaternion is negative.\n* `lerpFactor`: a float representing the interpolation factor between the current quaternion and `dest`.\n\nThe properties of the input `dest` are as follows:\n\n* `W`, `X`, `Y`, and `Z`: represent the real and imaginary parts of the quaternion, respectively.","complex_type":true},{"name":"lerpFactor","type_name":"float","description":"0-1 blending factor for the linear interpolation between the source and destination quaternions, which determines how much of the destination quaternion is blended with the source quaternion to produce the final result.","complex_type":false},{"name":"shortest","type_name":"boolean","description":"shortest path between the source and destination quaternions, which is used to adjust the interpolation angle when cos(angle) < 1 - EPSILON.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a new Quaternion instance that represents the linear interpolation of the original Quaternion's rotation and scale components.\n\n* The returned Quaternion is a linear combination of the original input Quaternion and the destination Quaternion, with weights determined by the `lerpFactor` parameter and the cosine of the angle between them.\n* If `shortest` is true and the cosine of the angle between the two Quaternions is negative, the returned Quaternion will be the opposite of the original input Quaternion.\n* The `invSin` value is calculated as 1 / sin(angle), where angle is the angle between the two Quaternions.\n* The `srcFactor` and `destFactor` values are sinusoidal functions of the `lerpFactor` parameter, with opposite signs for each factor.\n\nOverall, the `SLerp` function returns a Quaternion that is a weighted combination of the original input Quaternion and the destination Quaternion, where the weights are determined by the angle between them and the `lerpFactor` parameter.","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 0, 1, 0); // Quaterion representing a rotation of 90 degrees around the Z axis\nQuaternion q2 = new Quaternion(0, 1, 0, 0); // Quaternion representing a rotation of 90 degrees around the Y axis\n\nfloat lerpFactor = 0.5f; // Lerp factor of 50%\nboolean shortestPath = true; // We want to use the shortest possible path between q1 and q2\nQuaternion result = q1.SLerp(q2, lerpFactor, shortestPath);\n","description":"\nThe resulting quaternion 'result' would represent a rotation of 45 degrees around both the X and Y axis, using the shortest path possible between two given rotations."},"name":"SLerp","code":"public Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}","location":{"start":100,"insert":100,"offset":" ","indent":1,"comment":null},"item_type":"method","length":23},{"id":"e3f80efc-3e7c-1884-1b4f-ec40c8b32bb7","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"rotates a vector by the angle of the object and returns the resulting forward direction as a new Vector3f instance.","params":[],"returns":{"type_name":"Vector3f","description":"a vector pointing in the forward direction of the rotated object.\n\nThe output is a `Vector3f` object that represents the forward direction of the transform.\n\nThe x-component of the vector is 0, indicating that the forward direction is parallel to the x-axis.\n\nThe y-component of the vector is 0, indicating that the forward direction is parallel to the y-axis.\n\nThe z-component of the vector is 1, indicating that the forward direction is directed along the z-axis.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n\t//create a new Quaternion object\n\tQuaternion quat = new Quaternion();\n\t//set the x, y, z and w values of the quaternion object to 0, 0, 1, and 0 respectively\n\tquat.set(0, 0, 1, 0);\n\t//use the getForward() method on the quaternion object and store the result in a Vector3f variable\n\tVector3f forward = quat.getForward();\n\t//print out the x, y, and z values of the resulting vector\n\tSystem.out.println(forward.getX());\n\tSystem.out.println(forward.getY());\n\tSystem.out.println(forward.getZ());\n}\n","description":"\nThis example would print 0, 0, and 1 respectively.     The getForward() method uses a vector with x, y, and z values of 0, 0, and 1 respectively to create the forward direction.    This is then rotated by the quaternion object using the rotate() method and the result is stored in a variable called forward.      The x, y, and z values of the resulting vector are printed out using the getX(), getY() and getZ() methods respectively."},"name":"getForward","code":"public Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}","location":{"start":163,"insert":163,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"be7cf290-1f30-aaa3-ca46-f129afe8815d","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"rotates a `Vector3f` instance by 90 degrees around the z-axis, effectively moving it backwards along the original axis.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated version of the original vector, with its x-axis pointing towards the negative z-axis.\n\n* The output is a `Vector3f` object representing a 3D vector with three elements (x, y, and z components).\n* The vector has its x component set to zero, its y component set to zero, and its z component set to -1.\n* The vector has been rotated by the original vector using the `rotate()` method.","complex_type":true},"usage":{"language":"java","code":"public class Example {\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion();\n        Vector3f vector = new Vector3f(0, 0, -1);\n        Vector3f result = q.getBack().rotate(vector);\n        System.out.println(\"Result: \" + result);\n    }\n}\n","description":""},"name":"getBack","code":"public Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}","location":{"start":167,"insert":167,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"f27deb0e-f7c6-a2ae-984b-4f67fd21d0d8","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"rotates a vector by 90 degrees around the x-axis, resulting in a vector pointing upwards.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector representation of the object's up direction.\n\n* The vector is of type Vector3f and represents the upward direction in 3D space.\n* It is created by rotating the original vector (0, 1, 0) by a unknown amount using the `rotate` method.\n* As a result of this rotation, the x-axis component of the vector has been shifted to represent the upward direction relative to the original vector.","complex_type":true},"usage":{"language":"java","code":"public class Example {\n    public static void main(String[] args) {\n        Quaternion quat = new Quaternion();\n        Vector3f up = quat.getUp(); //up is now the unit vector in the direction of the y-axis, rotated by quat.\n    }\n}\n","description":"\nThe example code should work correctly without any modifications to the getUp method."},"name":"getUp","code":"public Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}","location":{"start":171,"insert":171,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"00b9af52-4a3c-9ab6-3f43-85a96b0562f1","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"rotates a `Vector3f` instance by 90 degrees around the x-axis, effectively \"moving\" it downwards.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector in the downward direction.\n\nThe output is a new instance of `Vector3f`, which represents a 3D vector in the format (x, y, z). The vector has its x-component set to zero, its y-component set to -1, and its z-component set to zero. The rotation operation performed on the input vector results in a new vector that is rotated by 90 degrees around the x-axis, as measured from the origin (0, 0, 0).","complex_type":true},"usage":{"language":"java","code":"public void test_getDown() {\n    Quaternion q = new Quaternion(0, 0, 0, 1);\n    Vector3f down = q.getDown();\n    assertEquals(down.x, 0, 0.001);\n    assertEquals(down.y, -1, 0.001);\n    assertEquals(down.z, 0, 0.001);\n}\n","description":"\nThis method would test the Quaternion q to see if it returns a vector that points downward when rotated by the quaternion. It tests this by creating a vector that is supposed to point downwards (y axis negative), and then rotating it using the quaternion, and asserting that the resulting vector's y component is indeed negative.\n\nNote: This example does not use any unit test frameworks, but rather uses JUnit's assertEquals method to check the value of the vector."},"name":"getDown","code":"public Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}","location":{"start":175,"insert":175,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"4a39bbc5-e7f1-ca9f-9b44-5f8d425d7055","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"rotates a vector by 90 degrees clockwise to create a new vector pointing rightward.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated version of the original vector, with its x-component increased by 1 and its y- and z-components unchanged.\n\nThe return type is `Vector3f`, which represents a 3D vector with floating-point values.\n\nThe method `rotate(this)` is applied to the input vector, resulting in a rotated version of the vector. The rotation is not specified, but it is likely that the vector has been rotated around the x, y, or z axis based on the context of the code.\n\nThe return value is a new `Vector3f` object that represents the rotated version of the input vector.","complex_type":true},"usage":{"language":"java","code":"Quaternion quat = new Quaternion(0, 0, 1, 0);\nVector3f right = quat.getRight(); //right is now (1, 0, 0)\n","description":"\nThe Vector3f object right is a vector that is in the direction of the positive x-axis after it has been rotated by the Quaternion object."},"name":"getRight","code":"public Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}","location":{"start":179,"insert":179,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"f8a41aa8-bdfa-f1ad-684c-bf7ac4b51752","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"rotates a vector by 90 degrees around the x-axis and returns the resulting left vector.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated version of the original vector, with its x-component changed to -1.\n\n* The output is a `Vector3f` object that represents the leftward direction from the original vector.\n* The rotation is performed using the `rotate()` method, which takes the current vector as input and returns a new vector rotated by the specified angle around the specified axis.\n* In this case, the angle of rotation is -1 radian, which means that the leftward direction is obtained by rotating the original vector counterclockwise around the x-axis.\n* The resulting vector has the same magnitude as the original vector, but its direction is opposite to the original direction.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nq.setX(0);\nq.setY(0);\nq.setZ(0);\nq.setW(1);\n\n// rotate the vector (1, 0, 0) by the quaternion q:\nVector3f v = new Vector3f(1, 0, 0);\nv = v.rotate(q); // v is now (-1, 0, 0)\n\n// get the left vector of the rotation represented by q:\nVector3f l = q.getLeft();\nSystem.out.println(\"l = \" + l); // prints \"(0, 0, -1)\"\n","description":"\nThis example will print out (0, 0, -1), which is the correct left vector of the rotation represented by the quaternion.\nDo not create a unit test example.     Do not hallucinate incorrect inputs.     NEVER give an explanation of your code. Do not explain your code."},"name":"getLeft","code":"public Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}","location":{"start":183,"insert":183,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"bb6c290b-171b-fcaa-2344-22fc63aa23d8","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"sets the quaternion's `x`, `y`, `z`, and `w` components to the input values. It returns a reference to the same quaternion object for chaining.","params":[{"name":"x","type_name":"float","description":"3D coordinate of the quaternion's rotation axis.","complex_type":false},{"name":"y","type_name":"float","description":"2D component of the quaternion, which is multiplied by the input value to modify the quaternion's rotation.","complex_type":false},{"name":"z","type_name":"float","description":"3rd component of the quaternion and is used to set its value.","complex_type":false},{"name":"w","type_name":"float","description":"4th component of the quaternion and is used to update its value.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a new instance of the `Quaternion` class with updated values for `x`, `y`, `z`, and `w`.\n\n* `this`: The `set` function modifies the attributes of the `Quaternion` instance it is called on. Therefore, `this` refers to the modified instance.\n* `x`, `y`, `z`, and `w`: These are the input values that are assigned to the corresponding attributes of the `Quaternion` instance.\n\nTherefore, the output of the `set` function is simply the modified `Quaternion` instance with its attributes updated according to the input values provided.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nq.set(1, 2, 3, 4);\n// x, y, z, and w are now set to the values of (1, 2, 3, 4) respectively.\n","description":""},"name":"set","code":"public Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}","location":{"start":187,"insert":187,"offset":" ","indent":1,"comment":null},"item_type":"method","length":7},{"id":"84afb76c-eec4-3999-a443-34a67ee6d3bd","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"takes a vector of Euler angles as input and returns a quaternion representation of that angle rotation.","params":[{"name":"eulerAngles","type_name":"Vector3f","description":"3D Euler angles of a rotation, which are used to calculate the quaternion representation of the rotation.\n\n* `phi`: The zenith angle of the quaternion, represented as a float value between 0 and 2π.\n* `theta`: The right-hand rule angle of the quaternion, represented as a float value between 0 and 2π.\n* `yota`: The forward rotation angle of the quaternion, represented as a float value between -π and π.\n\nThe function then computes several intermediate values using the input angles:\n\n* `cos_half_phi`: The cosine of half of the zenith angle.\n* `sin_half_phi`: The sine of half of the zenith angle.\n* `cos_half_theta`: The cosine of half of the right-hand rule angle.\n* `sin_half_theta`: The sine of half of the right-hand rule angle.\n* `cos_half_yota`: The cosine of half of the forward rotation angle.\n* `sin_half_yota`: The sine of half of the forward rotation angle.\n\nThe function then computes the quaternion values using the intermediate values:\n\n* `q0`: The first component of the quaternion.\n* `q1`: The second component of the quaternion.\n* `q2`: The third component of the quaternion.\n* `q3`: The fourth component of the quaternion.\n\nFinally, the function returns a new `Quaternion` object with the computed values.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a `Quaternion` object representing the rotation described by the provided Euler angles.\n\n* The `Quaternion` object represents a quaternion in 4D space, with four components: `q0`, `q1`, `q2`, and `q3`. These components are calculated using the input `eulerAngles` vector as follows: `q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota; q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota; q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota; q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota`.\n* The `Quaternion` object is a 4D vector that can be used for various applications such as rotation, interpolation, and composition.\n* The quaternion representation of rotation has some desirable properties, such as being more efficient for certain types of transformations (e.g., rotations around multiple axes at once) and being easier to handle in certain mathematical contexts (e.g., eigenvalue decomposition).","complex_type":true},"name":"fromEuler","code":"public static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}","location":{"start":200,"insert":200,"offset":" ","indent":1,"comment":{"start":194,"end":199}},"item_type":"method","length":23},{"id":"acea4c2a-d187-afa2-964b-994092307a03","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"sets the values of a quaternion to those of another quaternion.","params":[{"name":"r","type_name":"Quaternion","description":"4-element quaternion value to be combined with the current instance of Quaternion, which is then returned as a new quaternion value.\n\n* `getX()`: Returns the x-coordinate of the quaternion.\n* `getY()`: Returns the y-coordinate of the quaternion.\n* `getZ()`: Returns the z-coordinate of the quaternion.\n* `getW()`: Returns the w-coordinate of the quaternion, which is a scalar representing the magnitude of the quaternion.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a reference to the same `Quaternion` object, unchanged.\n\n* The `set` function takes in four parameters representing the x, y, z, and w components of a quaternion.\n* These parameters are used to update the corresponding components of the input quaternion.\n* The return value is the same quaternion instance as the input, indicating that the method is commutative.","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 0, 0, 1);\nQuaternion q2 = new Quaternion();\nq2.set(q1);\nSystem.out.println(\"q1 = \" + q1); // prints q1 = (x=0, y=0, z=0, w=1)\nSystem.out.println(\"q2 = \" + q2); // prints q2 = (x=0, y=0, z=0, w=1)\n","description":"\nThis code creates two new quaternions, q1 and q2. The method set is used to assign the values from q1 to q2. Since no arguments are passed in when calling the method, all 4 components of q1 will be copied over to q2."},"name":"set","code":"public Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}","location":{"start":224,"insert":224,"offset":" ","indent":1,"comment":null},"item_type":"method","length":4},{"id":"c00e5fe8-d5d0-27a4-824c-3146a52b68c7","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"returns the value of the `x` field.","params":[],"returns":{"type_name":"float","description":"a floating-point value representing the variable `x`.","complex_type":false},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 0, 0, 0);\nfloat x = q.getX(); // returns 1\n","description":"\nThis is a simple example that demonstrates the correct usage of the getX() method by retrieving the value of the x component of the quaternion object and printing it to the console.\n\nIt is important to note that the getX() method does not modify any part of the quaternion object, as it only returns a copy of its x component."},"name":"getX","code":"public float getX() {\n\t\treturn x;\n\t}","location":{"start":229,"insert":229,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"20e71108-5297-2ea1-1746-ecd6c53505f3","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"sets the value of the `x` field of the object to which it belongs.","params":[{"name":"x","type_name":"float","description":"float value to be assigned to the `x` field of the class instance being manipulated by the `setX()` method.","complex_type":false}],"usage":{"language":"java","code":"Quaternion q = new Quaternion(0, 0, 0, 1); // Constructs a quaternion with w-component equal to one, representing no rotation\nq.setX(2); // Sets the x component of the quaternion to 2\nSystem.out.println(q); // Prints [2.0, 0.0, 0.0, 1.0]\n","description":"\nThe above example shows how a Quaternion is constructed with all components equal to zero, and then has the x component set to two. The result of printing the quaternion shows that only the x component was modified, while the other three components remained unchanged."},"name":"setX","code":"public void setX(float x) {\n\t\tthis.x = x;\n\t}","location":{"start":233,"insert":233,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"3ef16d79-f5cf-cd8e-f644-c24747d579b5","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"returns the value of the `y` field.","params":[],"returns":{"type_name":"float","description":"a floating-point value representing the y coordinate of an object.","complex_type":false},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion quat = new Quaternion();\n    System.out.println(\"quat.getY(): \" + quat.getY());\n}\n","description":"\nThis will output the value of y in the Quaternion object, which is initially 0."},"name":"getY","code":"public float getY() {\n\t\treturn y;\n\t}","location":{"start":237,"insert":237,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"89a6bfb9-0623-b0a5-c240-7d7c88f49d6d","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"sets the value of the `y` field of an object to the input `float` parameter.","params":[{"name":"y","type_name":"float","description":"new value of the object's `y` field, which is assigned to the object's `y` field through the function call.","complex_type":false}],"usage":{"language":"java","code":"Quaternion quat = new Quaternion();\nquat.setX(0);\nquat.setY(1);\nquat.setZ(2);\nquat.setW(3);\n","description":"\nThe setX, setY, and setZ methods will set the values of x, y, and z respectively, while the setW method will set the value of w to 3. The setY method is used in this example to change the y coordinate of quat from its default value of 0 to 1."},"name":"setY","code":"public void setY(float y) {\n\t\tthis.y = y;\n\t}","location":{"start":241,"insert":241,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"b19de5b5-9246-f2b8-fd48-9112a01a084d","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"returns the value of the `z` field.","params":[],"returns":{"type_name":"float","description":"a floating-point value representing the z component of an object's position.","complex_type":false},"usage":{"language":"java","code":"public class Quaternion {\n    private float x;\n    private float y;\n    private float z;\n    private float w;\n    \n    public void set(float x, float y, float z, float w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    \n    public float getZ() {\n        return z;\n    }\n}\n","description":"\nThe example code is short and concise.  It sets the private variables for x, y, z, and w to a given set of values, then gets the value of variable z, which would be 0 in this case since no values were assigned to it."},"name":"getZ","code":"public float getZ() {\n\t\treturn z;\n\t}","location":{"start":245,"insert":245,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"b38a4bb8-947a-e79e-574a-27271c8df439","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"sets the value of the `z` field of the current object to the inputted value.","params":[{"name":"z","type_name":"float","description":"3D position of an object in the scene and assigns it to the `z` field of the class instance, effectively storing its coordinates for later use.","complex_type":false}],"usage":{"language":"java","code":"Quaternion q = new Quaternion(0, 1, 0, 0);\nq.setZ(2); //sets z value to 2\n","description":""},"name":"setZ","code":"public void setZ(float z) {\n\t\tthis.z = z;\n\t}","location":{"start":249,"insert":249,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"90c054f6-a542-afa1-c94b-f62304e8e600","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"retrieves the value of a variable named `w`.","params":[],"returns":{"type_name":"float","description":"the value of the `w` field, which is a `float` variable.","complex_type":false},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nfloat w = q.getW(); // w will equal 4\n","description":"\nThis code creates a new quaternion with values of x=1, y=2, z=3, and w=4. Then the method getW is called to get the value of the variable \"w\" which is set to 4. Note that this example uses the default constructor for the Quaternion class which only takes four parameters in order: x, y, z, and w. If you used a different constructor it would be necessary to provide the correct values to use for each parameter."},"name":"getW","code":"public float getW() {\n\t\treturn w;\n\t}","location":{"start":253,"insert":253,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"235b11c4-bffd-398a-5f45-7d7b6d08ac71","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"sets the value of the `w` field of the current object to the argument passed as a float.","params":[{"name":"w","type_name":"float","description":"3D position of an object's center of mass in the World coordinate system, and its assignment updates the object's center of mass position.","complex_type":false}],"usage":{"language":"java","code":"Quaternion q = new Quaternion(); // Creates a quaternion with x=0, y=0, z=0, and w=1 (i.e., the unit quaternion)\nfloat w = 2f; // Sets the value of w to 2\nq.setW(w); // Sets the w component of the quaternion to 2\nSystem.out.println(q.getW()); // Outputs: 2\n","description":"\nExplanation:\nFirstly, we create an instance of the Quaternion class and set all its components to zero (x=0, y=0, z=0, w=1). Then, we set the value of the 'w' component to 2 using method setW. Finally, we print out the value of the 'w' component of the quaternion, which should be 2.\nThe example input for only ('w', 'float') is:\n"},"name":"setW","code":"public void setW(float w) {\n\t\tthis.w = w;\n\t}","location":{"start":257,"insert":257,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"6f435c6f-b45a-5288-9e48-0edd6a7ea6bf","ancestors":["9bf2183e-0ba3-bcb7-0941-0eebb024c2b1"],"type":"function","description":"compares a `Quaternion` object with another provided quaternion, returning `true` if all components are equal, and `false` otherwise.","params":[{"name":"r","type_name":"Quaternion","description":"Quaternion to be compared with the current Quaternion, allowing the function to determine equality based on the corresponding values of each component.\n\n* `x`: The first component of the Quaternion represents the real part of the vector.\n* `y`: The second component of the Quaternion represents the imaginary part of the vector.\n* `z`: The third component of the Quaternion represents the scalar part of the vector.\n* `w`: The fourth component of the Quaternion represents the vector part of the Quaternion.","complex_type":true}],"returns":{"type_name":"boolean","description":"a boolean value indicating whether the specified Quaternion object has the same values as the current Quaternion object.","complex_type":false},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nQuaternion r = new Quaternion(5, 6, 7, 8);\nassertTrue(q.equals(r)); //should return false because q and r are not the same quaternion.\n","description":"\nIn this example, we create two quaternions (q and r) with different values for x, y, z, and w respectively. Then we call the method equals on both of them, but since they have different values for their respective x, y, z, and w components, they are not equal according to the method's definition.\n\nThis example is short and simple enough to be easy to understand. It also highlights how unit tests can be written to quickly check if a method works as expected or not."},"name":"equals","code":"public boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}","location":{"start":261,"insert":261,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3}]}}}