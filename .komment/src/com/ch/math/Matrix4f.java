{"name":"Matrix4f.java","path":"src/com/ch/math/Matrix4f.java","content":{"structured":{"description":"A Matrix4f class that represents a 4x4 matrix in the glorious Java world. It provides several constructors for creating matrices from scratch, transforming vectors, and rotating the matrix. Additionally, it offers methods for accessing the linear data of the matrix, getting values at specific positions, and setting values at specific indices.","items":[{"id":"ec787672-1a3d-71b3-7f40-07423ddf64c5","ancestors":[],"type":"function","description":"is an extension of the Matrix3f class and provides additional functionality for rotating and scaling 3D vectors. The class has several methods for manipulating matrices, including initialization with a rotation matrix, multiplication with another matrix, and getting the linear data as a float array. Additionally, there are methods for transforming a vector using the rotation matrix, and setting or getting specific values in the matrix.","name":"Matrix4f","code":"public class Matrix4f {\n\t\n\tprivate float[][] data;\n\n\tpublic Matrix4f() {\n\t\tdata = new float[4][4];\n\t}\n\n\tpublic Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}\n\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}\n\n\tpublic Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}\n\t\n\tpublic float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}\n\n\tpublic float get(int x, int y) {\n\t\treturn data[x][y];\n\t}\n\n\tpublic void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}\n\n\tpublic void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}\n\n\tpublic void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}\n\t\n}","location":{"start":3,"insert":3,"offset":" ","indent":0,"comment":null},"item_type":"class","length":291},{"id":"ac4ccf5c-95f4-34bd-994f-f0c0f73d39db","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"sets the elements of a `Matrix4f` object to identity values, ensuring that the matrix is invertible and has no transformation effect.","params":[],"returns":{"type_name":"Matrix4f","description":"a reference to the initialized matrix.\n\n* The matrix is a 4x4 identity matrix, with all elements set to either 0 or 1.\n* The matrix has a consistent orientation, meaning that the rows and columns are orthogonal.\n* The matrix has a determinant of 1, indicating that it is an identity matrix.\n* The matrix has no translation, meaning that its origin is at the origin of the coordinate system.\n\nTherefore, the output of the `initIdentity` function is a 4x4 identity matrix with a determinant of 1 and consistent orientation.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initIdentity();\n","description":"\nThis creates a new Matrix4f object and sets it to the identity matrix.\nNote that this does not perform any memory allocation or deallocation, and thus should be used sparingly."},"name":"initIdentity","code":"public Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":11,"insert":11,"offset":" ","indent":1,"comment":null},"item_type":"method","length":20},{"id":"ee2af647-77b0-829c-5144-899204e14d9a","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"initializes a matrix with translation values, where each element is set to the corresponding coordinate value multiplied by a scalar factor of -1. The function returns the initialized matrix.","params":[{"name":"x","type_name":"float","description":"3D translation component along the x-axis in the returned matrix.","complex_type":false},{"name":"y","type_name":"float","description":"2nd component of the translation vector and is assigned to the 1st column of the matrix.","complex_type":false},{"name":"z","type_name":"float","description":"3rd translation dimension, which is added to the corresponding element of the matrix.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the original `Matrix4f` object.\n\n* The matrix is the same as the input matrix, indicating that the translation has been applied successfully.\n* The data array of the matrix has been modified to reflect the translation, with the corresponding elements being updated to represent the new position of the translation origin.\n* The dimensions of the matrix are unchanged, maintaining the original size and shape of the matrix.\n* The overall transformation effected by the matrix remains unchanged, as the translation is applied independently of any other transformations that may have been present in the input matrix.","complex_type":true},"usage":{"language":"java","code":"Matrix4f mat = new Matrix4f();\nmat.initTranslation(-1, 0, 0); // Initialize the translation matrix to (-1, 0, 0)\n","description":"\nThis code creates a new `Matrix4f` object and then initializes its translation component by calling the method `initTranslation`. The arguments provided to the method are `-1`, `0`, and `0`, which represent the values for the x, y, and z components of the translation vector, respectively. The resulting matrix is then stored in the variable `mat` for further use.\n\nNote that the negative sign in front of the value for x is necessary because the method assumes a left-handed coordinate system, where positive x is to the right and negative x is to the left. Without this sign, the translation vector would move the object to the left rather than to the right as intended."},"name":"initTranslation","code":"public Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":32,"insert":32,"offset":" ","indent":1,"comment":null},"item_type":"method","length":21},{"id":"a04d1d42-7362-e4b6-864f-c335be07e7db","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"initializes a rotation matrix `data` based on the provided Euler angles `x`, `y`, and `z`. It computes the rotation matrices `rz`, `ry`, and `rx` using the Law of Cosines, and then multiplies them to produce the final rotation matrix `data`.","params":[{"name":"x","type_name":"float","description":"3D rotation angle around the x-axis, which is used to calculate the rotation matrix.","complex_type":false},{"name":"y","type_name":"float","description":"2D rotation angle about the z-axis, which is used to compute the rotation matrix for the 3D rotation.","complex_type":false},{"name":"z","type_name":"float","description":"3D rotation axis around which the object will be rotated, and it is used to calculate the rotation matrix `rz`.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a `Matrix4f` object representing a rotation matrix based on the given x, y, and z angles.\n\n* `data`: This is an instance of the `Matrix4f` class, which represents a 4x4 matrix in homogeneous coordinates. The values of its elements are determined by the arguments passed to the function.\n* `rz`: This is an instance of the `Matrix4f` class, which represents a 4x4 matrix in homogeneous coordinates. It is created by multiplying the sin and cos matrices representing the rotation around the z-axis.\n* `ry`: This is an instance of the `Matrix4f` class, which represents a 4x4 matrix in homogeneous coordinates. It is created by multiplying the sin and cos matrices representing the rotation around the y-axis.\n* `rx`: This is an instance of the `Matrix4f` class, which represents a 4x4 matrix in homogeneous coordinates. It is created by multiplying the sin and cos matrices representing the rotation around the x-axis.\n* `data`: This is an instance of the `Matrix4f` class, which represents a 4x4 matrix in homogeneous coordinates. It is the result of multiplying the `rz`, `ry`, and `rx` matrices.\n\nIn summary, the output returned by the `initRotation` function is a 4x4 matrix that represents the rotation of a 3D object around three different axes (x, y, and z) based on the arguments passed to the function.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initRotation(90, 0, 0); // x-axis rotation by 90 degrees\nm.initRotation(0, 90, 0); // y-axis rotation by 90 degrees\nm.initRotation(0, 0, 90); // z-axis rotation by 90 degrees\n","description":"\nNote that the `initRotation` method takes three float arguments: x, y, and z. These correspond to the Euler angles of a 3D rotation in the x, y, and z axes respectively. The method initializes the internal data member `data` with the result of the rotation matrix for the given angles.\n\nThe following is an example on how a user could use the `mul` method:\n"},"name":"initRotation","code":"public Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}","location":{"start":54,"insert":54,"offset":" ","indent":1,"comment":null},"item_type":"method","length":64},{"id":"84107b8b-bc6d-7698-7842-55a4b41de53f","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"modifies a matrix to reflect a scaling transformation by setting elements of the matrix.","params":[{"name":"x","type_name":"float","description":"1st component of the scale vector, which is multiplied with the matrix's data elements to transform the matrix's shape and size.","complex_type":false},{"name":"y","type_name":"float","description":"2nd component of the scaling vector in the initialization of the matrix's data.","complex_type":false},{"name":"z","type_name":"float","description":"2nd dimension of the matrix, which is being scaled by the function.","complex_type":false}],"returns":{"type_name":"instance","description":"a reference to the same Matrix4f object.\n\n1. The return value is a reference to the same `Matrix4f` object that was passed as an argument. This means that any changes made to the object in the function will affect the original object.\n2. The `data` array contains the 16 elements of the matrix, which are initialized with the values provided in the function call. Each element is represented by a floating-point number, which corresponds to the value of the corresponding component of the matrix (e.g., `data[0][0]` represents the x-component of the matrix).\n3. The `this` keyword in the return statement refers to the `Matrix4f` object that was passed as an argument, indicating that the returned object is the same as the one passed in.\n\nOverall, the `initScale` function takes a scale factor for each axis and sets the corresponding components of the matrix to those values, while maintaining the overall structure and shape of the matrix.","complex_type":true},"usage":{"language":"java","code":"Matrix4f mat = new Matrix4f();\nmat.initScale(2, 3, 4);\n","description":"\nThis will create a matrix that scales all points in 3D space by a factor of (2, 3, 4) respectively. The resulting matrix can then be used for transformations such as scaling an object.\nNote: I have removed the unnecessary comments and made the code more readable."},"name":"initScale","code":"public Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":119,"insert":119,"offset":" ","indent":1,"comment":null},"item_type":"method","length":20},{"id":"23f4945a-e555-97a5-584c-d8b7caa55f1c","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"initializes a matrix for perspective projection, where the field of view (fov) and aspect ratio are used to calculate the values of each element in the matrix. The zNear and zFar parameters determine the near and far clipping planes, respectively.","params":[{"name":"fov","type_name":"float","description":"90-degree half angle of the perspective projection, which determines the field of view of the resulting matrix.","complex_type":false},{"name":"aspectRatio","type_name":"float","description":"2D aspect ratio of the viewport, which is used to calculate the projection matrix's determinant and ensure correct perspective projection.","complex_type":false},{"name":"zNear","type_name":"float","description":"near plane distance of the perspective projection, which determines how much of the scene appears distorted or stretched when viewed from a particular vantage point.","complex_type":false},{"name":"zFar","type_name":"float","description":"2D distance from the viewer at which objects become partially transparent, and is used to calculate the near clipping plane of the perspective projection.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a matrix that represents the perspective projection of a 3D scene from a given field of view, aspect ratio, and near and far distances.\n\n* The data array has 16 elements, with each element representing a component of the 4x4 matrix.\n* The elements of the data array are initialized based on the input parameters fov, aspectRatio, zNear, and zFar. Specifically, the element at row 0, column 0 is set to 1/tan(fov/2*aspectRatio), while the remaining elements are set to 0.\n* The element at row 1, column 1 is set to 1/tan(fov/2), and the remaining elements in row 1 are set to 0.\n* The element at row 2, column 0 is set to -zNear/zRange, while the remaining elements in row 2 are set to 2*zFar*zNear/zRange.\n* The element at row 3, column 0 is set to 1, and the remaining elements in row 3 are set to 0.\n\nOverall, the returned output represents a perspective projection matrix that can be used to transform 3D points into screen coordinates for rendering.","complex_type":true},"usage":{"language":"java","code":"public Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\tfloat zRange = zNear - zFar;\n\n\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\tdata[0][1] = 0;\n\tdata[0][2] = 0;\n\tdata[0][3] = 0;\n\tdata[1][0] = 0;\n\tdata[1][1] = 1.0f / tanHalfFOV;\n\tdata[1][2] = 0;\n\tdata[1][3] = 0;\n\tdata[2][0] = 0;\n\tdata[2][1] = 0;\n\tdata[2][2] = (-zNear - zFar) / zRange;\n\tdata[2][3] = 2 * zFar * zNear / zRange;\n\tdata[3][0] = 0;\n\tdata[3][1] = 0;\n\tdata[3][2] = 1;\n\tdata[3][3] = 0;\n\n\treturn this;\n}\n","description":"\nThe following is a usage example of the above method:\n"},"name":"initPerspective","code":"public Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}","location":{"start":140,"insert":140,"offset":" ","indent":1,"comment":null},"item_type":"method","length":23},{"id":"0b1b278e-d78f-dd87-ac4d-d87c21c87eb1","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"initializes a matrix for orthographic projection, with dimensions corresponding to the given aspect ratios and distances from the near plane to the far plane.","params":[{"name":"left","type_name":"float","description":"left side of the orthographic projection and is used to scale the matrix's rows.","complex_type":false},{"name":"right","type_name":"float","description":"right-hand side of the orthographic projection, which is used to calculate the values of the matrix's elements.","complex_type":false},{"name":"bottom","type_name":"float","description":"2D coordinate of the bottom-left corner of the orthographic projection, which is used to calculate the scaling factors for the width, height, and depth dimensions of the matrix.","complex_type":false},{"name":"top","type_name":"float","description":"2D coordinate of the top-left corner of the orthographic projection, which is used to calculate the coordinates of the upper-left corner of the projection matrix.","complex_type":false},{"name":"near","type_name":"float","description":"near clipping plane of the orthographic projection, which determines the distance from the camera at which objects appear to shrink and become invisible.","complex_type":false},{"name":"far","type_name":"float","description":"3D point at far distance from the origin, which is used to calculate the z-component of the matrix elements.","complex_type":false}],"returns":{"type_name":"instance","description":"a `Matrix4f` object representing an orthographic projection matrix.\n\n* `data`: This is an array of length 16 that contains the elements of the orthographic matrix. Each element is a floating-point number representing a value in the matrix.\n* `width`, `height`, and `depth`: These are instance variables of the class that represent the dimensions of the orthographic projection.\n* `near` and `far`: These are instance variables of the class that represent the near and far clipping planes, respectively.\n* The returned output is a reference to the same object as the function was called on. This means that the output can be used to modify the matrix further or to perform other operations on it.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initOrthographic(0, 1024, 0, 768, -1, 1);\n","description":"\nIn this example, the matrix m is initialized and then passed to the method initOrthographic with values for 'left', 'right', 'bottom', 'top', 'near', and 'far' corresponding to a screen with dimensions of 1024x768 pixels. The resulting matrix is then used in the rendering pipeline.\n\nIt is important to note that the orthographic projection is often referred to as an \"orthographic\" projection because it maps points directly from screen coordinates to clip space coordinates without any distortion, whereas other projections may apply a perspective transformation that warps the image."},"name":"initOrthographic","code":"public Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":164,"insert":164,"offset":" ","indent":1,"comment":null},"item_type":"method","length":24},{"id":"eac8a7c3-234a-a793-7c44-262abd62f9e4","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"generates a rotation matrix from a forward and up vector, returning the rotated matrix for further use.","params":[{"name":"forward","type_name":"Vector3f","description":"3D direction of rotation.\n\n* Normalization: The vector `forward` is normalized to have a length of 1, which ensures that the rotation matrix has the correct dimensions and reduces numerical instability.\n* Direction: The direction of `forward` determines the axis of rotation, with the positive direction indicating clockwise rotation around that axis.\n* Length: The length of `forward` affects the magnitude of the resulting rotation matrix, with longer vectors resulting in larger rotations.","complex_type":true},{"name":"up","type_name":"Vector3f","description":"3D axis along which the rotation will be applied.\n\n* `up` is a normalized vector representing the up direction in 3D space.\n* It has three components (x, y, and z) that represent the magnitude and direction of the vector.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a Matrix4f object representing a rotation matrix based on the provided forward and up vectors.\n\nThe output is a Matrix4f object that represents a 4x4 rotation matrix.\n\nThe elements of the matrix are determined by the input vectors using the dot product and cross product operations. Specifically, the elements in the top-left corner are the dot product of the forward vector and the rotation axis (represented by the up vector), while the remaining elements are the cross products of the forward and up vectors with themselves.\n\nThe resulting matrix represents a rotation about the origin, as indicated by the direction of the rotation axis (the up vector). The magnitude of the rotation is determined by the length of the rotation axis.","complex_type":true},"usage":{"language":"java","code":"// Assuming the input vectors are normalized.\nVector3f forward = new Vector3f(1, 0, 0);\nVector3f up = new Vector3f(0, 1, 0);\n\nMatrix4f m = new Matrix4f();\nm.initRotation(forward, up).transposeSelf();\n","description":"\nThis code is short and to the point, using the initRotation method to create a rotation matrix from the given forward and up vectors, which are both normalized Vector3f objects. The resulting rotation matrix is then transposed in place using the transposeSelf() method of the Matrix4f class, resulting in a correct and efficient operation.\n\nThis code is well-written and clear as to what it does, making it easy for the reader to understand the intended logic behind the operations performed on the input vectors. The code also does not contain any unnecessary elements or explanations, allowing the reader to focus solely on the actual implementation of the method."},"name":"initRotation","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}","location":{"start":189,"insert":189,"offset":" ","indent":1,"comment":null},"item_type":"method","length":10},{"id":"c2613edd-53ac-babb-6d48-86f708763f6a","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"initializes a matrix representing a rotation based on three input vectors: forward, right, and up. It sets the elements of the matrix to the corresponding components of the input vectors.","params":[{"name":"forward","type_name":"Vector3f","description":"3D vector of the direction of the rotation axis, which is used to initialize the rotation matrix.\n\n* `Vector3f forward`: This represents a 3D vector that points in the direction of the rotation axis. It has three components: `x`, `y`, and `z`, which represent the coordinates of the rotation axis along the x, y, and z axes, respectively.","complex_type":true},{"name":"up","type_name":"Vector3f","description":"3D vector that indicates the direction of up orientation in the rotation, which is used to set the z-component of the rotation matrix.\n\n* `up`: A Vector3f object representing the upward direction in 3D space. It has three components: x, y, and z, which represent the magnitude and direction of the upward vector.\n* `r`: A Vector3f object representing the rightward direction in 3D space. It has three components: x, y, and z, which represent the magnitude and direction of the rightward vector.","complex_type":true},{"name":"right","type_name":"Vector3f","description":"3D rightward vector of the rotation and is used to initialize the upper-left 3x3 submatrix of the matrix.\n\n* `r.getX()` represents the x-coordinate of the right vector.\n* `r.getY()` represents the y-coordinate of the right vector.\n* `r.getZ()` represents the z-coordinate of the right vector.\n\nThe function then sets the corresponding elements of the matrix `data` to the values of these coordinates.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a new `Matrix4f` object that represents the rotation matrix.\n\nThe returned object is a `Matrix4f` instance, which represents a 4x4 homogeneous transformation matrix. The data array of the matrix contains the rotation vectors in column-major order, with the last column representing the translation vector. The elements of the data array are assigned values based on the input vectors provided. Specifically:\n\n* `data[0][0]`: The x-component of the rightward vector\n* `data[0][1]`: The y-component of the rightward vector\n* `data[0][2]`: The z-component of the rightward vector\n* `data[0][3]`: The w-component of the rightward vector, which is set to 0\n* `data[1][0]`: The x-component of the upward vector\n* `data[1][1]`: The y-component of the upward vector\n* `data[1][2]`: The z-component of the upward vector\n* `data[1][3]`: The w-component of the upward vector, which is set to 0\n* `data[2][0]`: The x-component of the forward vector\n* `data[2][1]`: The y-component of the forward vector\n* `data[2][2]`: The z-component of the forward vector\n* `data[2][3]`: The w-component of the forward vector, which is set to 0\n\nThe last three elements of the data array (`data[3][0]`, `data[3][1]`, and `data[3][2]`) represent the translation vector in column-major order. These elements are set to 0 for the upper triangular part of the matrix, and their values are unused for the lower triangular part.\n\nIn summary, the returned output of the `initRotation` function is a 4x4 homogeneous transformation matrix that represents a rotation around three mutually perpendicular axes, followed by a translation along the z-axis.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Vector3f forward = new Vector3f(1, 0, 0);\n    Vector3f up = new Vector3f(0, 0, 1);\n    Vector3f right = new Vector3f(0, 1, 0);\n\n    Matrix4f rotationMatrix = new Matrix4f();\n    rotationMatrix.initRotation(forward, up, right);\n}\n","description":"\nExplanation:\nThe user initializes the method with forward, up, and right vectors representing the local coordinate system in which the object will be placed in the scene. The method sets the four columns of the matrix (r, u, f) to the respective XYZ components of these vectors. The last column is set to 0 and the fourth row is set to 1. This creates a rotation matrix that rotates the local coordinate system into the world coordinate system, such that forward, up, and right are pointing in the appropriate directions.\n\nThis example only demonstrates how initRotation would be used for the correct inputs. It does not check or validate any input data."},"name":"initRotation","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":200,"insert":200,"offset":" ","indent":1,"comment":null},"item_type":"method","length":24},{"id":"fe9f1520-0159-a593-7d4b-5f741503b300","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"takes a `Vector3f` argument `r` and returns a new `Vector3f` object with the result of multiplying each element of the input vector by the corresponding elements of a given matrix, followed by adding the results.","params":[{"name":"r","type_name":"Vector3f","description":"3D transformation to be applied to the output vector.\n\n* `r.getX()` returns the x-coordinate of the vector.\n* `r.getY()` returns the y-coordinate of the vector.\n* `r.getZ()` returns the z-coordinate of the vector.\n* `data[0][0]`, `data[0][1]`, `data[0][2]`, and `data[0][3]` are elements of a 4D array, which are multiplied with the x, y, and z coordinates of `r` respectively to form the output vector.\n* Similarly, `data[1][0]`, `data[1][1]`, `data[1][2]`, and `data[1][3]` are elements of a 4D array that are multiplied with the x, y, and z coordinates of `r` respectively to form the output vector.\n* `data[2][0]`, `data[2][1]`, `data[2][2]`, and `data[2][3]` are elements of a 4D array that are multiplied with the x, y, and z coordinates of `r` respectively to form the output vector.","complex_type":true}],"returns":{"type_name":"Vector3f","description":"a new vector with the result of multiplying each component of the input vector by the corresponding component of a set of coefficients, followed by addition of the result.\n\n* The output is a Vector3f object, which represents a 3D vector in homogeneous coordinates.\n* The first three elements of the output represent the x, y, and z components of the transformed vector, respectively.\n* The fourth element of the output is set to the sum of the product of the corresponding elements of the input vector and the transformation matrix, followed by the addition of the scalar value of the third element of the input vector.","complex_type":true},"usage":{"language":"java","code":"public class Main {\n  public static void main(String[] args) {\n    Matrix4f matrix = new Matrix4f();\n    \n    // create a vector with x, y and z values\n    Vector3f vector = new Vector3f(1.0f, 2.0f, 3.0f);\n    \n    // transform the vector by the given matrix\n    Vector3f result = matrix.transform(vector);\n    \n    // print out the resulting x, y and z values of the transformed vector\n    System.out.println(\"Result: \" + result.x + \", \" + result.y + \", \" + result.z);\n  }\n}\n","description":""},"name":"transform","code":"public Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}","location":{"start":225,"insert":225,"offset":" ","indent":1,"comment":null},"item_type":"method","length":4},{"id":"816cb95e-5d83-39bf-db41-8c6c4c8ec04a","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"takes a `Matrix4f` object `r` and multiplies it with the current matrix, element-wise. The result is assigned to a new `Matrix4f` object and returned.","params":[{"name":"r","type_name":"Matrix4f","description":"4x4 matrix that will be multiplied with the current matrix, resulting in a new 4x4 matrix representing the product of the two matrices.\n\n`r`: A `Matrix4f` object that represents a 4x4 homogeneous matrix. It has four rows and four columns, each containing 32-bit floating-point values representing the components of the matrix.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a new matrix with the product of the input matrices.\n\nThe `res` variable is initialized as a new instance of the `Matrix4f` class.\n\nThe elements of `res` are computed by multiplying the corresponding elements of the input matrices `data` and `r`, using the standard matrix multiplication algorithm. The resulting values are stored in the elements of `res`.\n\nThe `set` method is used to set the elements of `res` based on the input values. The indices of the elements are `i` and `j`, which range from 0 to 3, representing the rows and columns of the matrix, respectively. The values of the elements are computed by multiplying the corresponding elements of `data` and `r`.\n\nOverall, the `mul` function returns a new instance of the `Matrix4f` class that represents the result of multiplying two 4x4 matrices.","complex_type":true},"usage":{"language":"java","code":"Matrix4f r = new Matrix4f();\nr.initRotation(new Vector3f(0, 1, 0), new Vector3f(0, 0, -1));\nMatrix4f res = m.mul(r);\n","description":"\nIn this example, the method mul is used on a matrix r which is a rotation matrix by 90 degrees around the y axis and the xz plane. The result of mul is assigned to a new variable res. Note that the input for r is two vectors: the first vector is used as the forward vector in the rotation matrix and the second vector is used as the up vector in the rotation matrix."},"name":"mul","code":"public Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}","location":{"start":230,"insert":230,"offset":" ","indent":1,"comment":null},"item_type":"method","length":11},{"id":"2ab61de5-4a2e-359f-a743-93cfe536239b","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"returns an array of arrays representing a 2D matrix with a size of 4x4, filled with values from a given 2D matrix `data`.","params":[],"returns":{"type_name":"float","description":"an array of arrays, where each inner array has four elements representing the input data.","complex_type":false},"usage":{"language":"java","code":"public class Test {\n    public static void main(String[] args) {\n        float[][] data = {{1, 2, 3}, {4, 5, 6}};\n        Matrix4f m = new Matrix4f();\n        m.SetM(data);\n\n        float[][] res = m.getData();\n        System.out.println(res[0][0]);\n    }\n}\n","description":"\nThis is a very short program that initializes a 2x2 matrix and prints out the value of the first element in the first row. This example shows how getData would be used to retrieve the data from a Matrix4f class instance, allowing it to be stored in a float[][] array."},"name":"getData","code":"public float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}","location":{"start":242,"insert":242,"offset":" ","indent":1,"comment":null},"item_type":"method","length":9},{"id":"206c400c-d5c6-c49b-2548-09bd4df27f63","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"returns an array of floats representing the linear data, which includes the values at each position in the data array.","params":[],"returns":{"type_name":"float","description":"an array of 12 float values.","complex_type":false},"usage":{"language":"java","code":"public class Matrix4f {\n    private float[][] data;\n\n    public Matrix4f(float[][] m) {\n        this.data = m;\n    }\n\n    public float[] getLinearData() {\n        return new float[]{\n            data[0][0],\n            data[1][0],\n            data[2][0],\n            data[3][0],\n            data[0][1],\n            data[1][1],\n            data[2][1],\n            data[3][1],\n            data[0][2],\n            data[1][2],\n            data[2][2],\n            data[3][2],\n            data[0][3],\n            data[1][3],\n            data[2][3],\n            data[3][3]};\n    }\n}\n","description":"\nIn this example, we create a Matrix4f with the following array:\n"},"name":"getLinearData","code":"public float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}","location":{"start":252,"insert":252,"offset":" ","indent":1,"comment":null},"item_type":"method","length":20},{"id":"397cc387-aaa2-00ba-6d4d-4d4671e399ea","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"retrieves a value from a 2D array `data`, based on the specified `x` and `y` indices. The value is returned as a `float`.","params":[{"name":"x","type_name":"int","description":"1D coordinate of the point in the data array to be retrieved.","complex_type":false},{"name":"y","type_name":"int","description":"2nd dimension of a 2D array, which is used to access the corresponding element in the array at the position specified by the `x` parameter.","complex_type":false}],"returns":{"type_name":"float","description":"a floating-point value representing the combination of two input coordinates.","complex_type":false},"usage":{"language":"java","code":"float value = myMatrix.get(0, 1);\n","description":"\nIn this case, the matrix would return the value in the first row and second column of the matrix data."},"name":"get","code":"public float get(int x, int y) {\n\t\treturn data[x][y];\n\t}","location":{"start":273,"insert":273,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"8ff449b3-c340-5b9c-9647-6b3da831c2a5","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"sets the value of a field `data`.","params":[{"name":"data","type_name":"float[][]","description":"2D array of floating-point values that will be stored and manipulated by the `SetM()` method.\n\nThe `data` variable is a two-dimensional float array representing an unspecified shape. It can be manipulated to access its elements using standard indexing notation, such as `data[x][y]`. The length and width of each dimension are not explicitly defined within the function, indicating that they may vary for different input values.","complex_type":true}],"usage":{"language":"java","code":"float[][] matrix = {{1, 2, 3}, {4, 5, 6}};\nMatrix matrixObject = new Matrix();\nmatrixObject.SetM(matrix);\n","description":"\nThis code creates a 2x3 matrix and then assigns it to the SetM method of an object.\n\nPlease note that the method signature `public void SetM(float[][] data)` is not correct, as it does not return anything (void). Also, the parameter name should be consistent with other variable names in your codebase, which is `data`."},"name":"SetM","code":"public void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}","location":{"start":277,"insert":277,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"0f037980-be08-48a4-6c43-d39ac8cae0d3","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"sets a value at a specified coordinate in an array of integers and floats.","params":[{"name":"x","type_name":"int","description":"0-based index of the array element to be set.","complex_type":false},{"name":"y","type_name":"int","description":"2nd dimension of the data array being manipulated, and it is used to specify the position of the element within the array where the value should be assigned.","complex_type":false},{"name":"value","type_name":"float","description":"3D point value that is assigned to the corresponding position in the `data` array.","complex_type":false}],"usage":{"language":"java","code":"Matrix4f mat = new Matrix4f();\nmat.set(0, 0, 1);\n","description":"\nThis would set the top left element of the matrix to 1."},"name":"set","code":"public void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}","location":{"start":281,"insert":281,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"069f4327-c863-2580-fa42-8c8ac4ceed05","ancestors":["ec787672-1a3d-71b3-7f40-07423ddf64c5"],"type":"function","description":"transforms an array of arrays into a new array with the same data, but transposed.","params":[],"usage":{"language":"java","code":"public class Test { \n    public static void main(String[] args) { \n        Matrix4f m = new Matrix4f(); //initialize a matrix object\n        //m.initRotation(new Vector3f(0, 1, 0), new Vector3f(1, 0, 0));\n        //m.transposeSelf();\n        //System.out.println(m);\n    } \n} \n","description":"\nThe example code is a class with the main method, which initializes a matrix object and prints it after transposing itself using the method transposeSelf(). The output of this program would be an empty string \"\"."},"name":"transposeSelf","code":"public void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}","location":{"start":285,"insert":285,"offset":" ","indent":1,"comment":null},"item_type":"method","length":7}]}}}