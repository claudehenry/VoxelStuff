{"name":"Matrix4f.java","path":"src/com/ch/math/Matrix4f.java","content":{"structured":{"description":"","items":[{"id":"5af9cc9c-3389-4e24-90fc-0a6ca4b8c805","ancestors":[],"type":"function","name":"initIdentity","location":{"offset":"\t","indent":1,"insert":11,"start":11},"returns":"Matrix4f","params":[],"code":"public Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"length":20,"comment":{"description":"initializes a matrix to the identity matrix, with all elements set to their default value of 0 or 1.","params":[],"returns":{"type":"Matrix4f","description":"a Matrix4f object with identity values."}}},{"id":"9ca6f24e-a918-4ee6-847b-3a951d7d6503","ancestors":[],"type":"function","name":"initTranslation","location":{"offset":"\t","indent":1,"insert":32,"start":32},"returns":"Matrix4f","params":[{"name":"x","type":"float"},{"name":"y","type":"float"},{"name":"z","type":"float"}],"code":"public Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"length":21,"comment":{"description":"initializes a Matrix4f object with translation coordinates (x, y, z). It updates the matrix data accordingly and returns the modified matrix object.","params":[{"name":"x","type":"float","description":"3D translation vector's x-coordinate in the returned matrix."},{"name":"y","type":"float","description":"2D coordinate of the translation origin along the y-axis."},{"name":"z","type":"float","description":"3rd translation axis and sets its value to the input `z` value, which is then included in the resulting matrix."}],"returns":{"type":"Matrix4f","description":"a Matrix4f object with the specified translation applied to its components."}}},{"id":"285d492f-b679-46e5-b4af-9cebb3613a8c","ancestors":[],"type":"function","name":"initRotation","location":{"offset":"\t","indent":1,"insert":54,"start":54},"returns":"Matrix4f","params":[{"name":"x","type":"float"},{"name":"y","type":"float"},{"name":"z","type":"float"}],"code":"public Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}","skip":false,"length":64,"comment":{"description":"generates a rotation matrix based on three Euler angles (x, y, z) and returns it as a Matrix4f object.","params":[{"name":"x","type":"float","description":"3D rotation around the x-axis."},{"name":"y","type":"float","description":"2D rotation angle around the z-axis, which is applied to the z-rotation matrix along with the x-rotation matrix multiplied by the y-rotation matrix."},{"name":"z","type":"float","description":"3D rotation axis around which the matrix is rotated, and it is used to compute the components of the rotation matrix."}],"returns":{"type":"Matrix4f","description":"a 4x4 homogeneous transformation matrix representing a rotation in 3D space."}}},{"id":"c15694aa-3cb0-4f37-a214-3fc4562fdf13","ancestors":[],"type":"function","name":"initScale","location":{"offset":"\t","indent":1,"insert":119,"start":119},"returns":"Matrix4f","params":[{"name":"x","type":"float"},{"name":"y","type":"float"},{"name":"z","type":"float"}],"code":"public Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"length":20,"comment":{"description":"modifies the elements of a `Matrix4f` object to reflect a new scaling transformation, where the x, y, and z components are applied element-wise.","params":[{"name":"x","type":"float","description":"3D position of the top-left corner of the scaled matrix, which is set as the value of the `data[0][0]` element."},{"name":"y","type":"float","description":"2D scale factor for the vertical dimension of the matrix."},{"name":"z","type":"float","description":"2nd component of the scale vector and is used to set the value for that component of the matrix's representation of the transformation."}],"returns":{"type":"Matrix4f","description":"a matrix with scaled elements."}}},{"id":"22b92cd9-3512-4c37-ae1f-c2b7b30522b9","ancestors":[],"type":"function","name":"initPerspective","location":{"offset":"\t","indent":1,"insert":140,"start":140},"returns":"Matrix4f","params":[{"name":"fov","type":"float"},{"name":"aspectRatio","type":"float"},{"name":"zNear","type":"float"},{"name":"zFar","type":"float"}],"code":"public Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}","skip":false,"length":23,"comment":{"description":"calculates a perspective projection matrix based on field of view (fov), aspect ratio, near and far distances, resulting in a transformed coordinate system for visualization purposes.","params":[{"name":"fov","type":"float","description":"90-degree field of view of the camera, which determines the aspect ratio of the image and is used to calculate the tan of half of the field of view."},{"name":"aspectRatio","type":"float","description":"2D screen aspect ratio of the perspective projection, which is used to calculate the scaling factor for the x-axis in the projection matrix."},{"name":"zNear","type":"float","description":"near plane distance of the perspective projection."},{"name":"zFar","type":"float","description":"3D distance from the viewer to the farthest point in the scene, which is used to calculate the correct perspective projection of the scene."}],"returns":{"type":"Matrix4f","description":"a `Matrix4f` object with the necessary elements to represent a perspective projection."}}},{"id":"e15d091b-95b7-4b27-bcec-c54c834b77cc","ancestors":[],"type":"function","name":"initOrthographic","location":{"offset":"\t","indent":1,"insert":164,"start":164},"returns":"Matrix4f","params":[{"name":"left","type":"float"},{"name":"right","type":"float"},{"name":"bottom","type":"float"},{"name":"top","type":"float"},{"name":"near","type":"float"},{"name":"far","type":"float"}],"code":"public Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"length":24,"comment":{"description":"initializes a matrix for orthographic projection, where left and right are the coordinates of the near clipping plane, bottom and top are the coordinates of the far clipping plane, near is the distance from the camera to the near clipping plane, and far is the distance from the camera to the far clipping plane.","params":[{"name":"left","type":"float","description":"2D coordinate of one of the two left corners of the orthographic projection, which determines the origin of the projection."},{"name":"right","type":"float","description":"2D right coordinate of the orthographic projection, which is used to compute the scaling factors for the matrix's data array."},{"name":"bottom","type":"float","description":"2D coordinate of the bottom-left corner of the viewport in the orthogonal projection, which is used to calculate the width and height of the viewport."},{"name":"top","type":"float","description":"2D coordinate of the top of the orthographic projection, which is used to calculate the position of the projected points in the vertical dimension."},{"name":"near","type":"float","description":"near plane of the orthographic projection, which determines how the perspective view is zoomed in or out."},{"name":"far","type":"float","description":"3D point from which to view the scene, and it determines the distance of the near plane from the viewer's eye."}],"returns":{"type":"Matrix4f","description":"a matrix that represents an orthographic projection."}}},{"id":"d9741988-aa6e-4304-8a24-cc37c0771702","ancestors":[],"type":"function","name":"initRotation","location":{"offset":"\t","indent":1,"insert":189,"start":189},"returns":"Matrix4f","params":[{"name":"forward","type":"Vector3f"},{"name":"up","type":"Vector3f"}],"code":"public Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}","skip":false,"length":10,"comment":{"description":"initializes a rotation matrix based on three input vectors: `forward`, `up`, and `r`. It computes the rotation axis `u` and returns the rotation matrix.","params":[{"name":"forward","type":"Vector3f","description":"3D direction of rotation."},{"name":"up","type":"Vector3f","description":"3D up direction of the rotation, which is cross-producted with the `forward` parameter to form the rotational axis."}],"returns":{"type":"Matrix4f","description":"a matrix representing a rotation transformation."}}},{"id":"f0ee89dc-b4a7-4b94-85be-321d9e0ea89c","ancestors":[],"type":"function","name":"initRotation","location":{"offset":"\t","indent":1,"insert":200,"start":200},"returns":"Matrix4f","params":[{"name":"forward","type":"Vector3f"},{"name":"up","type":"Vector3f"},{"name":"right","type":"Vector3f"}],"code":"public Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"length":24,"comment":{"description":"initializes a rotation matrix based on three input vectors: `forward`, `up`, and `right`. It sets the elements of the rotation matrix to the corresponding components of the input vectors, ensuring that the resulting matrix represents a valid rotation.","params":[{"name":"forward","type":"Vector3f","description":"3D direction of the rotation axis, which is used to initialize the rotation matrix."},{"name":"up","type":"Vector3f","description":"3D direction perpendicular to the rotation axis, which is used to define the orientation of the rotation matrix."},{"name":"right","type":"Vector3f","description":"3D right vector of the rotation, which is used to initialize the elements of the output matrix."}],"returns":{"type":"Matrix4f","description":"a `Matrix4f` object representing the rotation matrix."}}},{"id":"907c2948-14f1-4304-99a3-ae6e58b090a4","ancestors":[],"type":"function","name":"transform","location":{"offset":"\t","indent":1,"insert":225,"start":225},"returns":"Vector3f","params":[{"name":"r","type":"Vector3f"}],"code":"public Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}","skip":false,"length":4,"comment":{"description":"takes a `Vector3f` argument `r` and returns a new `Vector3f` object with transformed coordinates based on a set of linear transformations represented by a 3x3 matrix stored in the class's instance variables.","params":[{"name":"r","type":"Vector3f","description":"3D transformation to be applied to the output vector."}],"returns":{"type":"Vector3f","description":"a new Vector3f object containing the result of multiplying each component of the input vector `r` by the corresponding components of a set of data, and then adding the products together."}}},{"id":"6bbd549f-5228-4c4d-a100-3a7697d4c43e","ancestors":[],"type":"function","name":"mul","location":{"offset":"\t","indent":1,"insert":230,"start":230},"returns":"Matrix4f","params":[{"name":"r","type":"Matrix4f"}],"code":"public Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}","skip":false,"length":11,"comment":{"description":"multiplies a matrix `r` by another matrix `data` and returns the result as a new matrix.","params":[{"name":"r","type":"Matrix4f","description":"4x4 matrix that is multiplied with the current matrix, resulting in the updated state of the current matrix."}],"returns":{"type":"Matrix4f","description":"a new Matrix4f object containing the result of multiplying the input matrix `r` with the current matrix."}}},{"id":"a23069b6-2e00-4f14-9acd-3eb0ee2abae8","ancestors":[],"type":"function","name":"getData","location":{"offset":"\t","indent":1,"insert":242,"start":242},"returns":"float[][]","params":[],"code":"public float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}","skip":false,"length":9,"comment":{"description":"returns an array of arrays, where each inner array has four elements representing the four quadrants of a square matrix with dimensions 4x4. The returned values are the same as the input `data`.","params":[],"returns":{"type":"float[][]","description":"an array of arrays, where each inner array has four elements representing the input data."}}},{"id":"c36b1377-42ff-40bd-a8b6-5fa97e6a0d2e","ancestors":[],"type":"function","name":"getLinearData","location":{"offset":"\t","indent":1,"insert":252,"start":252},"returns":"float[]","params":[],"code":"public float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}","skip":false,"length":20,"comment":{"description":"returns an array of floats representing a linear dataset with eight data points, each consisting of two values (x and y coordinates).","params":[],"returns":{"type":"float[]","description":"an array of 12 floats, representing the linear data."}}},{"id":"ae1dc0af-c130-490a-8033-5e1030a49989","ancestors":[],"type":"function","name":"get","location":{"offset":"\t","indent":1,"insert":273,"start":273},"returns":"float","params":[{"name":"x","type":"int"},{"name":"y","type":"int"}],"code":"public float get(int x, int y) {\n\t\treturn data[x][y];\n\t}","skip":false,"length":3,"comment":{"description":"retrieves a value from a two-dimensional array `data`. It takes two integer arguments `x` and `y` representing the row and column indices, respectively, of the desired element within the array. The function returns the value stored at the specified position in the array.","params":[{"name":"x","type":"int","description":"1D coordinate of the point in the 2D array at which to retrieve the value."},{"name":"y","type":"int","description":"2nd dimension of the data array being accessed by the function, which is used to locate the corresponding value in the array."}],"returns":{"type":"float","description":"a floating-point number representing the value at the specified coordinates of an array."}}},{"id":"42767f16-ccee-4e4e-91d7-8dbfa573f750","ancestors":[],"type":"function","name":"SetM","location":{"offset":"\t","indent":1,"insert":277,"start":277},"returns":false,"params":[{"name":"data","type":"float[][]"}],"code":"public void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}","skip":false,"length":3,"comment":{"description":"sets the value of the object's internal `data` field to the provided array of floats.","params":[{"name":"data","type":"float[][]","description":"2D array of floating-point values that will be assigned to the `data` field of the `SetM` method."}],"returns":null}},{"id":"8279d57c-d611-43e2-89ce-73f0e31ee678","ancestors":[],"type":"function","name":"set","location":{"offset":"\t","indent":1,"insert":281,"start":281},"returns":false,"params":[{"name":"x","type":"int"},{"name":"y","type":"int"},{"name":"value","type":"float"}],"code":"public void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}","skip":false,"length":3,"comment":{"description":"sets a value at a specific position in a 2D array.","params":[{"name":"x","type":"int","description":"0-based index of the row in the 2D array where the value of `value` will be stored."},{"name":"y","type":"int","description":"2nd dimension of the data array being manipulated by the function."},{"name":"value","type":"float","description":"3D coordinate value to be stored at the specified position in the data array."}],"returns":null}},{"id":"9a68209b-1d29-43f7-9588-e9d530d131dc","ancestors":[],"type":"function","name":"transposeSelf","location":{"offset":"\t","indent":1,"insert":285,"start":285},"returns":false,"params":[],"code":"public void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}","skip":false,"length":7,"comment":{"description":"transforms an array of floats into its transposed form, which is a 2D array of rows as columns. It sets the new data array to be the same as the original data array.","params":[],"returns":null}}]}}}