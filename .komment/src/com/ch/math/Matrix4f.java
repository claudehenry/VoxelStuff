{"name":"Matrix4f.java","path":"src/com/ch/math/Matrix4f.java","content":{"structured":{"description":"A class called Matrix4f that represents a 4x4 matrix in the homogeneous coordinate space. The class has several methods for setting and getting values of the matrix elements, as well as methods for transforming vectors using the matrix. Additionally, the code includes functions for initializing the matrix with different types of transformations (orthographic, rotation, or identity), and for multiplying the matrix with another matrix. Overall, the code provides a way to manipulate 4x4 matrices in Java.","items":[{"id":"a599ebf3-d183-9bb3-fe4c-f104c16983e3","ancestors":[],"type":"function","description":"TODO","name":"Matrix4f","code":"public class Matrix4f {\n\t\n\tprivate float[][] data;\n\n\tpublic Matrix4f() {\n\t\tdata = new float[4][4];\n\t}\n\n\tpublic Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}\n\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}\n\n\tpublic Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}\n\t\n\tpublic float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}\n\n\tpublic float get(int x, int y) {\n\t\treturn data[x][y];\n\t}\n\n\tpublic void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}\n\n\tpublic void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}\n\n\tpublic void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}\n\t\n}","location":{"start":3,"insert":3,"offset":" ","indent":0},"item_type":"class","length":291},{"id":"3b4113a6-78c9-d99c-274f-1bb50f1553bb","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"initializes a matrix to the identity matrix, where all elements are set to their default (0-based) values.","params":[],"returns":{"type_name":"Matrix4f","description":"a matrix with all elements set to either 0 or 1, depending on their position in the matrix.\n\n* The `Matrix4f` object is returned as the output, indicating that it has been initialized with an identity matrix.\n* The elements of the matrix are set to their default values, which are 1 for the diagonal elements (row and column), and 0 for all other elements. This ensures that the matrix has no transformation effect when passed through.\n* The returned object is a reference to the original `Matrix4f` instance, indicating that it remains unchanged and can be used further in the program.","complex_type":true},"usage":{"language":"java","code":"Matrix4f mat = new Matrix4f();\nmat.initIdentity();\n","description":"\nIn this case, the matrix is initialized with the identity matrix, which has all diagonal elements as 1 and zeroes in every other element. This is a common pattern when working with matrices in computer graphics, where most operations can be performed on these matrices directly."},"name":"initIdentity","code":"public Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":11,"insert":11,"offset":" ","indent":1},"item_type":"method","length":20},{"id":"1f2f6ce4-94e7-6d85-da4f-7b94993eef45","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"sets the translation components (x, y, z) for a 4D matrix. The x, y and z values are transformed to create a new coordinate system based on the matrix's transformation rules.","params":[{"name":"x","type_name":"float","description":"3D translation's x-coordinate in the returned matrix.","complex_type":false},{"name":"y","type_name":"float","description":"2nd component of the translation vector, which is added to the origin of the matrix.","complex_type":false},{"name":"z","type_name":"float","description":"3rd translation component in the resulting matrix, which is updated to have a value of 1 in the corresponding position of the matrix.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the original matrix4f object.\n\nThe `Matrix4f` object is returned as the output, which represents a 4x4 homogeneous transformation matrix.\n\nThe elements of the matrix are set to specific values, including:\n\n* data[0][0] = 1 (the identity matrix has this value)\n* data[0][1] = 0 (this element is ignored)\n* data[0][2] = 0 (the x-axis is not translated)\n* data[0][3] = x (the translation amount on the x-axis)\n* data[1][0] = 0 (the y-axis is not translated)\n* data[1][1] = 1 (the identity matrix has this value)\n* data[1][2] = 0 (the y-axis is not translated)\n* data[1][3] = y (the translation amount on the y-axis)\n* data[2][0] = 0 (the z-axis is not translated)\n* data[2][1] = 0 (this element is ignored)\n* data[2][2] = 1 (the identity matrix has this value)\n* data[2][3] = z (the translation amount on the z-axis)\n* data[3][0] = 0 (the w-axis is not translated)\n* data[3][1] = 0 (this element is ignored)\n* data[3][2] = 0 (the x and y axes are not translated)\n* data[3][3] = 1 (the identity matrix has this value)\n\nIn summary, the `initTranslation` function sets the elements of a 4x4 homogeneous transformation matrix to specific values based on the input translation amounts.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Matrix4f m = new Matrix4f();\n    m.initTranslation(-3, -2, 0);\n    System.out.println(\"Matrix:\\n\" + m.toString());\n}\n","description":"\nThe code above would create a matrix that translates everything by (-3, -2, 0) in the x, y, and z dimensions respectively.  \nThis is an example of how to use initTranslation with (x, float):\n"},"name":"initTranslation","code":"public Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":32,"insert":32,"offset":" ","indent":1},"item_type":"method","length":21},{"id":"fc252ffe-2218-c897-0547-eecb93bac970","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"initializes a rotation matrix based on three Euler angles (x, y, z) and returns the resulting matrix.","params":[{"name":"x","type_name":"float","description":"3D rotation angle around the z-axis and is used to calculate the rotation matrix rz.","complex_type":false},{"name":"y","type_name":"float","description":"2D rotation angle around the x-axis, which is used to compute the rotation matrix rz.","complex_type":false},{"name":"z","type_name":"float","description":"3D rotation angle around the z-axis, which is used to create the third row of the resulting matrix.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a Matrix4f object representing a rotation matrix based on the provided Euler angles.\n\nThe `data` field of the returned object is an instance of the `Matrix4f` class, which represents a 4x4 homogeneous transformation matrix. The matrix elements represent the rotation and translation components of the final rotation.\n\nThe `data` field has four rows and four columns, each representing a component of the transformation matrix. The first three rows (0-2) represent the rotation component of the transformation, while the last row (3) represents the translation component. Each column represents a different component of the transformation, with the first column representing the x-axis, the second column representing the y-axis, and the third column representing the z-axis.\n\nThe elements of the matrix are represented as floating-point numbers, with each element being a complex number representing the magnitude and phase of the corresponding component of the transformation. The magnitude of each element is represented by its absolute value, while the phase is represented by its argument (in radians).\n\nThe `initRotation` function initializes the rotation and translation components of the matrix using the input parameters `x`, `y`, and `z`. Specifically, it sets the elements of the `rz` matrix to the complex exponentials of the rotation angles `x`, `y`, and `z`, respectively. It then multiplies the resulting matrix by the matrices `ry` and `rx` to further manipulate the rotation and translation components. Finally, it returns the transformed matrix as its output.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Matrix4f mat = new Matrix4f();\n    mat.initRotation(30, 60, 90);\n}\n","description":"\nThis will result in the following matrix:\n"},"name":"initRotation","code":"public Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}","location":{"start":54,"insert":54,"offset":" ","indent":1},"item_type":"method","length":64},{"id":"7bea16d3-3cf2-9d90-a547-2f3360747c52","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"modifies a matrix's scale factor by setting elements to specified values.","params":[{"name":"x","type_name":"float","description":"4th column of the matrix, which is scaled by the value assigned to it.","complex_type":false},{"name":"y","type_name":"float","description":"2nd element of the scaling matrix in the `initScale()` function.","complex_type":false},{"name":"z","type_name":"float","description":"2nd element of the scaling vector in the returned matrix.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the original matrix.\n\n* The `Matrix4f` object is returned, indicating that the method modifies the original matrix in place.\n* The data elements of the matrix are set to specific values for the x, y, and z components.\n* The matrix's identity is preserved, as evidenced by the return value being the same object as the original matrix.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initScale(2, 3, 4);\nSystem.out.println(m);\n","description":"\nThis will output the following:\n"},"name":"initScale","code":"public Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":119,"insert":119,"offset":" ","indent":1},"item_type":"method","length":20},{"id":"ea7315db-5a81-6289-d142-c19ec3a3083d","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"initializes a matrix for perspective projection, setting up the necessary elements to transform points from homogeneous space to screen space according to a specified field of view (FOV), aspect ratio, and near and far distances.","params":[{"name":"fov","type_name":"float","description":"90-degree field of view for the perspective projection, which determines the aspect ratio of the output matrix and is used to calculate the tan of half the field of view.","complex_type":false},{"name":"aspectRatio","type_name":"float","description":"2D aspect ratio of the view frustum, which determines how much the near and far clipping planes are stretched or compressed horizontally when the field of view is changed.","complex_type":false},{"name":"zNear","type_name":"float","description":"near plane distance of the perspective projection, which determines the position of the image plane in the virtual environment.","complex_type":false},{"name":"zFar","type_name":"float","description":"3D space far clipping plane, which determines how much of the 3D scene is visible from the camera's perspective.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a matrix that represents a perspective projection, with values for each element of the matrix that determine the position and dimensions of the viewport.\n\n* `data`: This is an array of 16 floating-point values that represent the components of a 4x4 matrix.\n* `tanHalfFOV`: This variable represents the tan of half of the field of view in radians.\n* `aspectRatio`: This variable represents the aspect ratio of the viewport in the perspective projection.\n* `zNear`: This variable represents the near plane of the perspective projection in meters.\n* `zFar`: This variable represents the far plane of the perspective projection in meters.\n* `zRange`: This variable represents the distance between the near and far planes in meters.\n\nThe returned output is a modified version of the original matrix, with new values assigned to specific elements based on the input parameters. The properties of the returned matrix are:\n\n* The array has 16 elements, with dimensions [4, 4].\n* The elements are floating-point values between 0 and 1.\n* The matrix is a perspective projection matrix, which means it maps points in 3D space to points on a 2D viewport.\n* The matrix is orthonormal, meaning that its rows and columns are orthonormal vectors.","complex_type":true},"usage":{"language":"java","code":"// Create a new matrix4f to initialize\nMatrix4f mat = new Matrix4f();\n\n// Initialize the matrix using the fov, aspectRatio, zNear, and zFar arguments.\nmat.initPerspective(70f, 16f/9f, 0.1f, 100f);\n","description":"\nIn this example we are creating a new instance of Matrix4f and using the initPerspective method to set up the perspective matrix for a specific field of view, aspect ratio, near plane distance, and far plane distance. The resulting perspective matrix is then stored in mat."},"name":"initPerspective","code":"public Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}","location":{"start":140,"insert":140,"offset":" ","indent":1},"item_type":"method","length":23},{"id":"6ce472a0-5ffe-f7bc-b54e-4f47bdc2f98d","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"initializes a matrix representing an orthographic projection, where the near and far planes are specified, and the left, right, bottom, top, and depth of the view frustum are set.","params":[{"name":"left","type_name":"float","description":"left side of the orthographic projection, which determines the scale factor for the x-axis of the resulting matrix.","complex_type":false},{"name":"right","type_name":"float","description":"right edge of the orthographic projection, which is used to calculate the values of the matrix's elements.","complex_type":false},{"name":"bottom","type_name":"float","description":"2D coordinate of the bottom-left corner of the orthographic projection, which is used to determine the size and orientation of the projection matrix.","complex_type":false},{"name":"top","type_name":"float","description":"2D coordinate of the top-left corner of the orthographic projection, which is used to determine the scale factor for the y-axis in the orthogonal projection.","complex_type":false},{"name":"near","type_name":"float","description":"near clipping plane of the orthographic projection, and is used to calculate the values of the matrix elements responsible for projecting points from behind the near clipping plane onto the image plane.","complex_type":false},{"name":"far","type_name":"float","description":"4th coordinate of the orthographic projection, which is used to calculate the depth of the projected image.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the original matrix object.\n\n* `data`: This is an array of 16 floating-point values that represent the components of a 4x4 orthogonal projection matrix.\n* Each element in the `data` array has a specific property:\n\t+ Elements at row 0, column 0 have a value of 2/width, indicating the scaling factor for the x-axis.\n\t+ Elements at row 0, column 1 have a value of 0, indicating no translation along the x-axis.\n\t+ Elements at row 0, column 2 have a value of 0, indicating no rotation around the x-axis.\n\t+ Elements at row 0, column 3 have a value of -(right + left) / width, indicating the translation along the x-axis.\n\t+ Similarly, elements at row i, column j have values that represent the scaling factor and translation/rotation along the i-th axis for each axis.\n* The `return this;` statement indicates that the function returns a reference to the same matrix object that was passed as an argument.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initOrthographic(-1, 1, -1, 1, 0, 2);\n","description":"\nThis example initializes the matrix m with an orthographic projection. The parameters are as follows:\n* left: -1\n* right: 1\n* bottom: -1\n* top: 1\n* near: 0\n* far: 2\n\nThe method initOrthographic initializes a Matrix4f instance with the specified values. The result is stored in m. This can then be used to set up an orthographic projection matrix for a camera in a graphics engine."},"name":"initOrthographic","code":"public Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":164,"insert":164,"offset":" ","indent":1},"item_type":"method","length":24},{"id":"ea42d0c0-6373-2899-a54c-782b7a2efb09","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"initializes a rotation matrix from three vectors: `forward`, `up`, and `u`. The vectors are used to compute the x, y, and z components of the rotation matrix using the dot product and cross product operations.","params":[{"name":"forward","type_name":"Vector3f","description":"3D direction of the object's forward motion and is used to calculate the rotation axis.\n\n* `forward` is a vector in 3D space with a magnitude and direction.\n* The magnitude of `forward` is non-zero, indicating that it represents a direction in space.\n* The direction of `forward` is a unit vector, as it has been normalized to have a length of one.","complex_type":true},{"name":"up","type_name":"Vector3f","description":"3D direction perpendicular to the forward direction, which is used to compute the rotation matrix.\n\n* `normalized()` is applied to both `forward` and `up`, which normalizes the vectors to have a length of 1. This ensures that the rotation matrix has units that are consistent throughout.\n* The cross product `r = up.cross(f)` computes a vector `r` that is perpendicular to both `forward` and `up`. This vector will be used as the third column of the rotation matrix.\n* The cross product `u = f.cross(r)` computes a vector `u` that is perpendicular to both `f` and `r`. This vector will be used as the second column of the rotation matrix.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a `Matrix4f` object representing a rotation matrix based on two input vectors.\n\n* The output is a `Matrix4f` object representing a rotation matrix.\n* The rotation is defined by three vectors: `forward`, `up`, and `r`.\n* The vectors `f`, `u`, and `r` are normalized, meaning their magnitudes are equal to 1.\n* The resulting rotation matrix is computed using the cross product operation between the vectors.","complex_type":true},"usage":{"language":"java","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t// Normalize the input vectors to obtain a correct rotation matrix\n\tVector3f f = forward.normalized();\n\tVector3f r = up.normalized();\n\t\n\t// Calculate the cross product of the normalized vectors to get the third axis (u)\n\tVector3f u = f.cross(r);\n\t\n\treturn initRotation(f, u, r);\n}\n","description":"\nThe provided method would be called like so:\n"},"name":"initRotation","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}","location":{"start":189,"insert":189,"offset":" ","indent":1},"item_type":"method","length":10},{"id":"088b7faf-c112-2182-0140-3c4d4c4d4107","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"sets the elements of a Matrix4f object to represent a rotation based on three vectors: forward, right, and up.","params":[{"name":"forward","type_name":"Vector3f","description":"3D forward direction of the rotation, which is used to initialize the rotation matrix.\n\n* `forward` is a 3D vector representing the forward direction in the rotation. It has three components: `x`, `y`, and `z`.\n* The `x`, `y`, and `z` components of `forward` can take on any real value within their respective ranges.\n* The magnitude of `forward` is the length of the vector, which can be used to determine the orientation of the rotation.\n* The direction of `forward` is the direction in which the rotation is applied.\n\nThe properties and attributes of `up` and `right` are similar: they are also 3D vectors representing the upward and rightward directions, respectively.","complex_type":true},{"name":"up","type_name":"Vector3f","description":"3D direction perpendicular to the rotation axis and is used to set the z-component of the rotation matrix.\n\n* `up` is a `Vector3f` object representing the up direction vector in 3D space.\n* It has three components: `x`, `y`, and `z`, which represent the coordinates of the direction vector in the x, y, and z axes, respectively.\n* The magnitude (length) of the `up` vector is equal to 1 by default, but it can be modified if desired.","complex_type":true},{"name":"right","type_name":"Vector3f","description":"3D rightward vector, which is used to initialize the rotation matrix's elements.\n\n* `r.getX()` returns the x-coordinate of the right vector.\n* `r.getY()` returns the y-coordinate of the right vector.\n* `r.getZ()` returns the z-coordinate of the right vector.\n* `r` is a 3D vector representing the rightward direction.\n* `u.getX()`, `u.getY()`, and `u.getZ()` return the x, y, and z coordinates of the up vector, respectively.\n* `u` is a 3D vector representing the upward direction.\n* `f.getX()`, `f.getY()`, and `f.getZ()` return the x, y, and z coordinates of the forward vector, respectively.\n* `f` is a 3D vector representing the forward direction.\n\nThe function then sets the corresponding elements of the matrix `data` to the values of the input vectors. Finally, it returns the transformed matrix.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a `Matrix4f` object representing the rotation matrix.\n\n* `data`: This is an array of length 4, where each element is a floating-point value representing the rotation matrix components in the order of (x, y, z, w). The elements are initialized to the corresponding values from the input vectors `forward`, `up`, and `right`.\n* `this`: This refers to the `Matrix4f` object being modified. It is used to indicate that the return value is a reference to the same object being mutated.","complex_type":true},"usage":{"language":"java","code":"// Forward and up vectors\nVector3f forward = new Vector3f(1, 0, 0);\nVector3f up = new Vector3f(0, 1, 0);\nVector3f right = new Vector3f(0, 0, 1);\n\n// Initialize a Matrix4f with the given vectors\nMatrix4f rotationMatrix = new Matrix4f();\nrotationMatrix.initRotation(forward, up, right);\n","description":"\nThis method initializes a rotation matrix that rotates a vector to match another vector (the forward vector). It does this by creating the following matrix:\n"},"name":"initRotation","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":200,"insert":200,"offset":" ","indent":1},"item_type":"method","length":24},{"id":"250842ff-43c2-6d96-6e41-24cf5b3dd5a1","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"takes a `Vector3f` object `r` as input and returns a new `Vector3f` object with the result of multiplying each component of the input vector by corresponding components of a predefined array `data`, and then adding the result of these multiplications together.","params":[{"name":"r","type_name":"Vector3f","description":"3D transformation to be applied to the output vector.\n\n* `getX()` and `getY()` represent the x-axis and y-axis coordinates of `r`, respectively.\n* `getZ()` represents the z-axis coordinate of `r`.\n* `data[0][0]`, `data[0][1]`, `data[0][2]`, and `data[0][3]` are variables that hold the transformation values for each dimension of the input vector.\n* `data[1][0]`, `data[1][1]`, `data[1][2]`, and `data[1][3]` are similar to `data[0]`.\n* `data[2][0]`, `data[2][1]`, `data[2][2]`, and `data[2][3]` are similar to `data[0]`.","complex_type":true}],"returns":{"type_name":"Vector3f","description":"a new Vector3f object containing the result of multiplying each component of the input vector `r` by the corresponding components of the input matrix `data`.\n\n* The first component of the output is calculated as `data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ()`.\n* The second component of the output is calculated as `data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2] * r.getZ()`.\n* The third component of the output is calculated as `data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ()`.\n\nThe output is a new `Vector3f` object with values calculated by multiplying the corresponding components of the input `r` vector with the corresponding components of the fixed function `data`.","complex_type":true},"usage":{"language":"java","code":"Vector3f r = new Vector3f(1, 2, 3);\nMatrix4f m = new Matrix4f();\nm.initIdentity();\n\n// Transform a vector by a matrix\nVector3f transformedR = m.transform(r);\nSystem.out.println(\"Transformed R: \" + transformedR);\n","description":"\nIn this example, the matrix is initialized to identity, and then used to transform a vector by multiplying it with the vector. The resulting vector is printed out, which will be the same as the original vector."},"name":"transform","code":"public Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}","location":{"start":225,"insert":225,"offset":" ","indent":1},"item_type":"method","length":4},{"id":"5b08ae7f-56a4-8e90-cb45-6720ed805bdc","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"multiplies a matrix by another matrix, component-wise, and returns the result as a new matrix.","params":[{"name":"r","type_name":"Matrix4f","description":"4x4 matrix that is multiplied with the current matrix to produce the result matrix.\n\nThe `r` object is an instance of `Matrix4f`, which represents a 4x4 matrix in homogeneous coordinates. It has four rows and four columns, each containing 32-bit floating-point values representing the elements of the matrix. The elements are arranged in a row-major order, meaning that the elements of each row are stored in consecutive memory locations.\n\nThe `r` object has several attributes that can be used to manipulate it:\n\n* `get(int r, int c)`: Returns the element at position `(r, c)` as a 32-bit floating-point value.\n* `set(int r, int c, float value)`: Sets the element at position `(r, c)` to the specified value.\n* `get(int[] rows, int[] cols)`: Returns an array of 32-bit floating-point values representing the elements of the matrix in the specified rows and columns.\n* `set(int[] rows, int[] cols, float[] values)`: Sets the elements of the matrix in the specified rows and columns to the specified values.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a new Matrix4f object containing the result of multiplying the input matrix with another unknown matrix.\n\nThe `res` variable is initialized as a new instance of the `Matrix4f` class.\n\nThe elements of the output matrix are calculated by multiplying corresponding elements of the input matrices and storing them in the output matrix. The indices of the output matrix are zero-based, meaning that the first element of the output matrix corresponds to the first element of the input matrices, and so on.\n\nThe `set` method is used to set the elements of the output matrix. The method takes two integers, `i` and `j`, representing the row and column index of the element to be set, respectively, and a single integer `value` representing the value to be set. In this case, the value being set is the result of multiplying the corresponding elements of the input matrices.\n\nThe output matrix has four elements, each representing a 4D vector in homogeneous coordinates. The elements are represented by floating-point numbers and have a range of values between -1 and 1, inclusive.","complex_type":true},"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Matrix4f m = new Matrix4f();\n        Matrix4f r = new Matrix4f();\n\n        float[][] mData = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n        float[][] rData = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n        \n        m.SetM(mData);\n        r.SetM(rData);\n\n        Matrix4f res = m.mul(r);\n    }\n}\n","description":""},"name":"mul","code":"public Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}","location":{"start":230,"insert":230,"offset":" ","indent":1},"item_type":"method","length":11},{"id":"48ddf850-31d9-1089-794f-6fb9f81da9bc","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"generates an array of floats, `res`, with dimensions 4x4 by copying values from an existing array, `data`.","params":[],"returns":{"type_name":"float","description":"an array of arrays of float values.","complex_type":false},"usage":{"language":"java","code":"public float[][] data = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\nMatrix4f mat = new Matrix4f();\nmat.SetM(data);\n\nfloat[][] result = mat.getData();\n","description":"\nExplanation:\nThe matrix is initialized with the data provided in the input. The method getData() is then called on the initialized matrix object and returns a 2D array of floats containing the same values as the original data array. This shows that the method is working correctly by checking if the returned result matches the original data array."},"name":"getData","code":"public float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}","location":{"start":242,"insert":242,"offset":" ","indent":1},"item_type":"method","length":9},{"id":"989fefba-360e-7f8b-024b-8b8a9e150833","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"returns an array of floats representing a linear data set with 6 elements, each element being a 2D array with 4 elements (x, y coordinates).","params":[],"returns":{"type_name":"float","description":"an array of 12 float values.","complex_type":false},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Matrix4f matrix = new Matrix4f();\n    float[] data = matrix.getLinearData();\n    for (int i = 0; i < data.length; i++) {\n        System.out.println(\"Element \" + i + \": \" + data[i]);\n    }\n}\n","description":"\nIn this example, the getLinearData method is called on a Matrix4f object and assigned to an array of floats. The for loop then prints out each element in the array to show that all elements have been retrieved correctly. This demonstrates how the getLinearData method can be used to retrieve all the data stored within a 4x4 matrix."},"name":"getLinearData","code":"public float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}","location":{"start":252,"insert":252,"offset":" ","indent":1},"item_type":"method","length":20},{"id":"9822ab1b-2970-ea97-054a-8046af6ab3d0","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"retrieves a value from a 2D array `data`, based on the coordinates `x` and `y`. The value is returned as a `float`.","params":[{"name":"x","type_name":"int","description":"0-based index of the pixel location within the 2D array 'data'.","complex_type":false},{"name":"y","type_name":"int","description":"2nd dimension of the data array being accessed by the function, which is used to compute the desired value.","complex_type":false}],"returns":{"type_name":"float","description":"a floating-point value representing the element at the specified position in a 2D array.","complex_type":false},"usage":{"language":"java","code":"int x = 1;\nint y = 2;\nfloat result = matrix4f.get(x, y);\n// result would be equal to the value at index (x, y) in the data member of the Matrix4f class.\n","description":""},"name":"get","code":"public float get(int x, int y) {\n\t\treturn data[x][y];\n\t}","location":{"start":273,"insert":273,"offset":" ","indent":1},"item_type":"method","length":3},{"id":"1b3b7ed4-0c04-e5be-2c48-b659001c8a56","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"sets the value of a member field `data`.","params":[{"name":"data","type_name":"float[][]","description":"2D array of float values that will be stored in the class instance variable `data`.\n\n* The input `data` is an array of arrays, with each inner array being of type float.\n* The length of the inner array can vary, depending on the input provided.\n* The elements of the inner array represent the values to be processed by the function.","complex_type":true}],"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        float[][] matrix = {{1, 2}, {3, 4}};\n        Matrix4f mat = new Matrix4f();\n        mat.SetM(matrix);\n    }\n}\n","description":"\nThis code would create a 4x4 matrix and set its values to those of the input float[][]."},"name":"SetM","code":"public void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}","location":{"start":277,"insert":277,"offset":" ","indent":1},"item_type":"method","length":3},{"id":"bf0b754e-c1b9-07ba-7f44-d76d4401613b","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"updates the element at position (x, y) of a two-dimensional array with the provided floating-point value.","params":[{"name":"x","type_name":"int","description":"0-based index of a cell in the grid, where the value is being assigned to.","complex_type":false},{"name":"y","type_name":"int","description":"2D coordinate position of the data element being updated in the `data` array.","complex_type":false},{"name":"value","type_name":"float","description":"3D vector value that is assigned to the corresponding elements of the 2D array `data`.","complex_type":false}],"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initIdentity();\n\n// Set the value at position (1,2) to 3\nm.set(1, 2, 3);\n\n// Print the value at position (1,2)\nSystem.out.println(m.get(1, 2)); // Output: 3\n","description":""},"name":"set","code":"public void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}","location":{"start":281,"insert":281,"offset":" ","indent":1},"item_type":"method","length":3},{"id":"f33b2d66-3abe-eb86-ec49-9232be8fb684","ancestors":["a599ebf3-d183-9bb3-fe4c-f104c16983e3"],"type":"function","description":"transposes an array of floats by copying its elements to a new array, and assigns the new array to the function's field `data`.","params":[],"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initIdentity();\n//Transposing the matrix using the transposeSelf method\nm.transposeSelf();\nSystem.out.println(m); // Outputs: 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1\n","description":"\nIn this example, we first create a matrix and initialize it to the identity matrix using the initIdentity() method. Then, we transpose the matrix by calling the transposeSelf() method. Finally, we print the content of the resulting matrix. The output shows that the matrix has been successfully transposed, with all elements swapped."},"name":"transposeSelf","code":"public void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}","location":{"start":285,"insert":285,"offset":" ","indent":1},"item_type":"method","length":7}]}}}