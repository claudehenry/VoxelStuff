{"name":"Util.java","path":"src/com/ch/Util.java","content":{"structured":{"description":"Various utility methods for working with buffers, matrices, and lists. The methods include creating buffers from arrays, flipping buffers, and converting between buffer types. Additionally, there are methods for manipulating matrices and lists, such as creating matrices from array data and removing empty strings from lists.","items":[{"id":"cc12d9b5-f7e6-6684-d841-4a88e25df344","ancestors":[],"type":"function","description":"provides several methods for manipulating data arrays and buffers, including creation of new buffers, flipping of buffers, and conversion of data types. It also includes a method for removing empty strings from an array and converting integers and floats to arrays. Additionally, there are some unimplemented methods in the class, such as `createFlippedBuffer` and `loatMat4`, which appear to be intended for working with matrices.","name":"Util","code":"public class Util {\n\t\n\tpublic static FloatBuffer createFloatBuffer(int size) {\n\t\treturn BufferUtils.createFloatBuffer(size);\n\t}\n\n\tpublic static IntBuffer createIntBuffer(int size) {\n\t\treturn BufferUtils.createIntBuffer(size);\n\t}\n\n\tpublic static ByteBuffer createByteBuffer(int size) {\n\t\treturn BufferUtils.createByteBuffer(size);\n\t}\n\n\tpublic static IntBuffer createFlippedBuffer(int... values) {\n\t\tIntBuffer buffer = createIntBuffer(values.length);\n\t\tbuffer.put(values);\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}\n\t\n\tpublic static FloatBuffer createFlippedBuffer(float... values) {\n\t\tFloatBuffer buffer = createFloatBuffer(values.length);\n\t\tbuffer.put(values);\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}\n\n\t/*\n\tpublic static FloatBuffer createFlippedBuffer(Vertex[] vertices) {\n\t\tFloatBuffer buffer = createFloatBuffer(vertices.length * Vertex.SIZE);\n\n\t\tfor (int i = 0; i < vertices.length; i++) {\n\t\t\tbuffer.put(vertices[i].getPos().getX());\n\t\t\tbuffer.put(vertices[i].getPos().getY());\n\t\t\tbuffer.put(vertices[i].getPos().getZ());\n\t\t\tbuffer.put(vertices[i].getTexCoord().getX());\n\t\t\tbuffer.put(vertices[i].getTexCoord().getY());\n\t\t\tbuffer.put(vertices[i].getNormal().getX());\n\t\t\tbuffer.put(vertices[i].getNormal().getY());\n\t\t\tbuffer.put(vertices[i].getNormal().getZ());\n\t\t\tbuffer.put(vertices[i].getTangent().getX());\n\t\t\tbuffer.put(vertices[i].getTangent().getY());\n\t\t\tbuffer.put(vertices[i].getTangent().getZ());\n\t\t}\n\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}\n\t*/\n\n\t/*\n\tpublic static FloatBuffer createFlippedBuffer(Matrix4f value) {\n\t\tFloatBuffer buffer = createFloatBuffer(4 * 4);\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tbuffer.put(value.get(i, j));\n\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}\n\t\n\tpublic static Matrix4f loatMat4(FloatBuffer vals) {\n\t\t\n//\t\tvals.flip();\n\t\t\n\t\tMatrix4f m = new Matrix4f();\n\t\t\n\t\tint index;\n\t\tfor (index = 0; index < 16; index++)\n\t\t\tm.set(index % 4, index / 4, vals.get());\n\t\t\n\t\treturn m;\n\t}\n*/\n\tpublic static String[] removeEmptyStrings(String[] data) {\n\t\tArrayList<String> result = new ArrayList<String>();\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tif (!data[i].equals(\"\"))\n\t\t\t\tresult.add(data[i]);\n\n\t\tString[] res = new String[result.size()];\n\t\tresult.toArray(res);\n\n\t\treturn res;\n\t}\n\n\tpublic static int[] toIntArray(Integer[] data) {\n\t\tint[] result = new int[data.length];\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tresult[i] = data[i];\n\n\t\treturn result;\n\t}\n\t\n\tpublic static int[] toIntArray(List<Integer> data) {\n\t\tint[] result = new int[data.size()];\n\n\t\tfor (int i = 0; i < data.size(); i++)\n\t\t\tresult[i] = data.get(i);\n\n\t\treturn result;\n\t}\n\t\n\tpublic static float[] toFloatArray(Float[] data) {\n\t\tfloat[] result = new float[data.length];\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tresult[i] = data[i];\n\n\t\treturn result;\n\t}\n\t\n\tpublic static float[] toFloatArray(List<Float> data) {\n\t\tfloat[] result = new float[data.size()];\n\n\t\tfor (int i = 0; i < data.size(); i++)\n\t\t\tresult[i] = data.get(i);\n\n\t\treturn result;\n\t}\n}","location":{"start":11,"insert":11,"offset":" ","indent":0,"comment":null},"item_type":"class","length":129},{"id":"9b13d389-2747-30a9-c643-0927eaedaccf","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"creates a new `FloatBuffer` object with the specified size. The returned buffer contains the specified number of float values.","params":[{"name":"size","type_name":"int","description":"number of elements in the FloatBuffer that will be created and returned by the function.","complex_type":false}],"returns":{"type_name":"FloatBuffer","description":"a `FloatBuffer` object of the specified size.\n\nThe method returns an instance of `FloatBuffer`, which is a type-safe wrapper around a native `FloatBuffer`.\nThe `FloatBuffer` object represents a contiguous block of memory that can be accessed and manipulated using buffer-related methods.\nThe size of the returned `FloatBuffer` is specified by the parameter `size`, which must be a non-negative integer.","complex_type":true},"name":"createFloatBuffer","code":"public static FloatBuffer createFloatBuffer(int size) {\n\t\treturn BufferUtils.createFloatBuffer(size);\n\t}","location":{"start":13,"insert":13,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"2939924e-4270-5f90-4849-25ba8337bd2e","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"creates an `IntBuffer` object of a specified size, using the `BufferUtils` class to perform the creation.","params":[{"name":"size","type_name":"int","description":"number of elements to be stored in the IntBuffer created by the function.","complex_type":false}],"returns":{"type_name":"IntBuffer","description":"an `IntBuffer` object that represents a buffer of integers with the specified size.\n\n* The `IntBuffer` object is generated by BufferUtils, which implies that it has been created using a specific mechanism.\n* The size of the buffer is specified in the parameter `size`, indicating the number of integers that can be stored in the buffer.\n* The buffer is returned as an instance of the `IntBuffer` class, which represents a contiguous block of integers.","complex_type":true},"name":"createIntBuffer","code":"public static IntBuffer createIntBuffer(int size) {\n\t\treturn BufferUtils.createIntBuffer(size);\n\t}","location":{"start":17,"insert":17,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"dd15d2b0-33be-f08e-6140-9bcd19809f66","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"creates a new byte buffer instance with the specified size. The returned buffer is managed by the `BufferUtils` class and can be used for various operations on the fly.","params":[{"name":"size","type_name":"int","description":"initial capacity of the ByteBuffer to be created, which determines the amount of memory allocated for storing data.","complex_type":false}],"returns":{"type_name":"ByteBuffer","description":"a ByteBuffer object with the specified size.\n\nThe `ByteBuffer` object is created using the `BufferUtils` class.\nIt has an initial capacity of `size` bytes.\nIt can be resized dynamically by calling methods such as `rewind()`, `clear()`, and `put()`.","complex_type":true},"name":"createByteBuffer","code":"public static ByteBuffer createByteBuffer(int size) {\n\t\treturn BufferUtils.createByteBuffer(size);\n\t}","location":{"start":21,"insert":21,"offset":" ","indent":1,"comment":null},"item_type":"method","length":3},{"id":"c932fbcf-b45e-56a2-764d-1e766b27f9a7","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"creates an `IntBuffer` from a provided array of integers, then flips it to create a view of the original data in ascending order.","params":[],"returns":{"type_name":"IntBuffer","description":"an flipped IntBuffer containing the input values.\n\n* The `IntBuffer` object returned by the function is flipped, meaning that it contains the contents of the original array in reverse order.\n* The buffer is a view of the original array, which means that it has the same content as the array but is a separate entity with its own references.\n* The buffer has a length property that indicates the number of elements it contains.\n* The buffer can be accessed and manipulated using the `put` and `get` methods.","complex_type":true},"name":"createFlippedBuffer","code":"public static IntBuffer createFlippedBuffer(int... values) {\n\t\tIntBuffer buffer = createIntBuffer(values.length);\n\t\tbuffer.put(values);\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}","location":{"start":25,"insert":25,"offset":" ","indent":1,"comment":null},"item_type":"method","length":7},{"id":"28464116-918e-70b9-9f43-ff6fbae3f848","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"creates a new `FloatBuffer` instance by copying a provided array of floating-point values and flipping the order of the buffer. The resulting buffer is ready to be accessed and manipulated using standard buffer operations.","params":[],"returns":{"type_name":"FloatBuffer","description":"a flipped FloatBuffer containing the input values.\n\n* The output is a `FloatBuffer`, which is an implementation of the `Buffer` interface in Java.\n* The buffer has a length equal to the number of input values passed to the function.\n* The buffer contains the same sequence of floating-point numbers as the input array, in the order specified by the input values.\n* The buffer is flipped after being created, meaning that its position is incremented to point to the next available location for writing.","complex_type":true},"name":"createFlippedBuffer","code":"public static FloatBuffer createFlippedBuffer(float... values) {\n\t\tFloatBuffer buffer = createFloatBuffer(values.length);\n\t\tbuffer.put(values);\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}","location":{"start":33,"insert":33,"offset":" ","indent":1,"comment":null},"item_type":"method","length":7},{"id":"46a3d311-eb93-ae85-454b-a295383996f1","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"removes empty strings from an array of strings and returns a new array with the non-empty strings.","params":[{"name":"data","type_name":"String[]","description":"an array of strings to be processed, which is transformed into an ArrayList and then returned as a new array of strings.\n\nThe `data` array is an instance of `String[]`, indicating it is an array of strings.\n\nThe length of the `data` array is determined by a variable `i`, which ranges from 0 to `data.length-1`. This suggests that `data` may contain multiple elements, each represented by a string in the array.\n\nWithin each index of the array, the value is either an empty string or a non-empty string, as determined by the comparison with the String literals `\"\"`. If the value is not empty, it is added to an `ArrayList` called `result`.\n\nThe `result` list is created and initialized using the `new ArrayList<String>()` constructor.\n\nFinally, the elements of the `result` list are copied into a new `String[]` array using the `toArray(res)` method.\n\nOverall, the function appears to remove all empty strings from an input `String[]` array and return a new array with only non-empty strings.","complex_type":true}],"returns":{"type_name":"String","description":"an array of non-empty strings.","complex_type":false},"name":"removeEmptyStrings","code":"public static String[] removeEmptyStrings(String[] data) {\n\t\tArrayList<String> result = new ArrayList<String>();\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tif (!data[i].equals(\"\"))\n\t\t\t\tresult.add(data[i]);\n\n\t\tString[] res = new String[result.size()];\n\t\tresult.toArray(res);\n\n\t\treturn res;\n\t}","location":{"start":91,"insert":91,"offset":" ","indent":1,"comment":null},"item_type":"method","length":12},{"id":"99051145-1706-9592-e94a-0f01bfdce439","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"converts an `Integer` array to an `int` array with the same length, by simply copying the values of the original array to the new array.","params":[{"name":"data","type_name":"Integer[]","description":"1D array of integers that is converted into a 1D integer array by the function.\n\nThe input `data` is an array of integers.\nIt has a length property that indicates the number of elements in the array.\nEach element in the array is accessed through its index, which ranges from 0 to `data.length - 1`.","complex_type":true}],"returns":{"type_name":"int","description":"an integer array with the same elements as the input `data` array.","complex_type":false},"name":"toIntArray","code":"public static int[] toIntArray(Integer[] data) {\n\t\tint[] result = new int[data.length];\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tresult[i] = data[i];\n\n\t\treturn result;\n\t}","location":{"start":104,"insert":104,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"5aeb6bb1-d2e8-598c-aa46-a277a6c44b77","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"takes a list of integers as input and returns an integer array with the same size as the input list. The elements of the input list are copied into the corresponding positions of the output array in a one-to-one manner.","params":[{"name":"data","type_name":"List<Integer>","description":"list of integers that will be converted to an integer array by the `toIntArray()` method.\n\nThe input `data` is a list of integers, which means it is an ordered collection of items that can be accessed by their index.\n\nThe `size()` method is used to retrieve the number of elements in the list.\n\nThe `get()` method is used to retrieve a specific element from the list based on its index.","complex_type":true}],"returns":{"type_name":"int","description":"an integer array with the same size as the input list of integers.","complex_type":false},"name":"toIntArray","code":"public static int[] toIntArray(List<Integer> data) {\n\t\tint[] result = new int[data.size()];\n\n\t\tfor (int i = 0; i < data.size(); i++)\n\t\t\tresult[i] = data.get(i);\n\n\t\treturn result;\n\t}","location":{"start":113,"insert":113,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"6df6758e-a672-b489-ac40-c341ab068cb5","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"takes a `Float[]` array as input and returns an equivalent `float[]` array with the same elements.","params":[{"name":"data","type_name":"Float[]","description":"0-based array of floating-point values that will be converted to a new 0-based array of floating-point values.\n\n* Length: The function takes an array of floating-point numbers `data`, which has a length property that indicates the number of elements in the array.\n* Element type: Each element in the `data` array is of type `Float`, indicating that the function operates on individual floating-point values.\n* Data integrity: The function assumes that the input `data` is well-formed and does not contain any invalid or out-of-range values, which could result in unexpected behavior if not properly handled.","complex_type":true}],"returns":{"type_name":"float","description":"an array of floating-point values equivalent to the input `Float[]` array.","complex_type":false},"name":"toFloatArray","code":"public static float[] toFloatArray(Float[] data) {\n\t\tfloat[] result = new float[data.length];\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tresult[i] = data[i];\n\n\t\treturn result;\n\t}","location":{"start":122,"insert":122,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8},{"id":"a5600c74-75cd-6d9a-4e44-1cce0507f94a","ancestors":["cc12d9b5-f7e6-6684-d841-4a88e25df344"],"type":"function","description":"converts a `List<Float>` into an array of `float`. It loops through each element in the list and assigns it to the corresponding position in the returned array.","params":[{"name":"data","type_name":"List<Float>","description":"List<Float> of values that will be converted into an array of float values.\n\n* `data` is an instance of `List`.\n* The size of the list is accessed using the `size()` method.\n* A new array of `float` type with the same size as the list is created using the `new float[data.size()]` expression.\n* The elements of the list are copied into the array using a for loop, with the index of the element being accessed using the `i` variable.\n* The value of each element is copied into the corresponding position in the new array using the `result[i] = data.get(i)` expression.","complex_type":true}],"returns":{"type_name":"float","description":"an array of size equal to the number of elements in the input list, containing the corresponding float values.","complex_type":false},"name":"toFloatArray","code":"public static float[] toFloatArray(List<Float> data) {\n\t\tfloat[] result = new float[data.size()];\n\n\t\tfor (int i = 0; i < data.size(); i++)\n\t\t\tresult[i] = data.get(i);\n\n\t\treturn result;\n\t}","location":{"start":131,"insert":131,"offset":" ","indent":1,"comment":null},"item_type":"method","length":8}]}}}