package com.ch;

import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL15;
import org.lwjgl.opengl.GL20;
import org.lwjgl.opengl.GL30;

/**
 * Is designed for handling and rendering 3D models. It provides functionality for
 * loading model data from vertices and indices, storing it in OpenGL buffers, and
 * drawing the model on the screen using vertex arrays. The class also enables or
 * disables attribute access for efficient rendering.
 */
public class Model {

	private int vao, size;
	
	public Model(int vao, int count) {
		this.vao = vao;
		this.size = count;
	}
	
	/**
	 * Binds a vertex array object to the GPU, enables vertex attribute arrays for position
	 * and color data, draws triangles using indices, and then disables these attributes
	 * and unbinds the vertex array object. The drawing operation is done using elements,
	 * not vertices. It clears up resources afterwards.
	 */
	public void draw() {
		GL30.glBindVertexArray(vao);
		GL20.glEnableVertexAttribArray(0);
		GL20.glEnableVertexAttribArray(1);
		//GL11.glDrawArrays(GL11.GL_TRIANGLES, 0, size);
		GL11.glDrawElements(GL11.GL_TRIANGLES, size, GL11.GL_UNSIGNED_INT, 0);
		GL20.glDisableVertexAttribArray(0);
		GL20.glDisableVertexAttribArray(1);
		GL30.glBindVertexArray(0);
	}
	
	/**
	 * Enables attribute array access for two attributes, indexed as 0 and 1, using OpenGL
	 * functions. This prepares the graphics pipeline to receive data from these attributes.
	 * Attribute arrays are used to pass vertex data from application memory to the
	 * graphics processing unit (GPU).
	 */
	public static void enableAttribs() {
		GL20.glEnableVertexAttribArray(0);
		GL20.glEnableVertexAttribArray(1);
	}
	
	/**
	 * Disables vertex attribute arrays at indices 0 and 1 using OpenGL's API. It does
	 * not enable any attributes, merely suppresses their contribution to rendering. This
	 * action effectively removes the influence of these attributes on the graphics pipeline.
	 */
	public static void disableAttribs() {
		GL20.glDisableVertexAttribArray(0);
		GL20.glDisableVertexAttribArray(1);
	}
	
	/**
	 * Retrieves and returns the value of a variable `vao`. It serves as a getter method,
	 * allowing access to the stored value without modifying it. The returned integer
	 * represents an identifier associated with a Vertex Array Object (VAO).
	 *
	 * @returns an integer value representing a VAO (Vertex Array Object).
	 */
	public int getVAO() {
		return vao;
	}
	
	/**
	 * Returns an integer value representing the size attribute. The function is designed
	 * to retrieve and expose the current size state. It allows access to the internal
	 * size variable through a public getter method.
	 *
	 * @returns an integer representing the current size of a data structure or object.
	 * The value is accessed from a field named `size`. It is directly retrieved and returned.
	 */
	public int getSize() {
		return size;
	}
	
	/**
	 * Initializes a graphics model by creating a Vertex Array Object (VAO), storing
	 * vertex data and indices, and returning a new Model instance with the VAO ID and
	 * index count. It also unbinds the VAO to prevent resource leaks.
	 *
	 * @param vertices 3D model's vertex data to be stored in the graphics buffer.
	 *
	 * @param indices 1D array of integers that stores the connectivity information between
	 * vertices, allowing for efficient rendering and culling of polygons.
	 *
	 * @returns a `Model` object with a generated VAO and vertex count.
	 */
	public static Model load(float[] vertices, int[] indices) {
		int vao = createVAO();
		storeIndices(indices);
		storeData(0, vertices);
		unbindVAO();
		int v_count = indices.length;
		return new Model(vao, v_count);
	}
	
	/**
	 * Generates a new OpenGL Vertex Array Object (VAO) using `glGenVertexArrays`, binds
	 * it to the current context with `glBindVertexArray`, and returns its identifier. A
	 * VAO is used to manage a group of vertex buffer objects and their associated data.
	 *
	 * @returns a unique identifier for a newly created vertex array object.
	 * Generated by the OpenGL API as an integer value.
	 * Assigned to the local variable `vao`.
	 */
	private static int createVAO() {
		int vao = GL30.glGenVertexArrays();
		GL30.glBindVertexArray(vao);
		return vao;
	}
	
	/**
	 * Generates a buffer object to store vertex data, binds it to the array buffer target,
	 * and loads the data into it using a flipped buffer created by the `createFlippedBuffer`
	 * method. It also specifies the attributes for vertex position and texture coordinates.
	 *
	 * @param attrib 16-bit unsigned integer that specifies an attribute index for vertex
	 * attributes.
	 *
	 * @param data 2D array of floats that is stored in a vertex buffer object (VBO) using
	 * OpenGL functions.
	 */
	private static void storeData(int attrib, float[] data) {
		int vbo = GL15.glGenBuffers();
		GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vbo);
		GL15.glBufferData(GL15.GL_ARRAY_BUFFER, Util.createFlippedBuffer(data), GL15.GL_STATIC_DRAW);
		GL20.glVertexAttribPointer(attrib, 3, GL11.GL_FLOAT, false, 5 * 4,     0);
		GL20.glVertexAttribPointer(attrib + 1, 2, GL11.GL_FLOAT, false, 5 * 4, 3 * 4);
		GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
	}
	
	/**
	 * Creates a buffer object on the GPU to store vertex indices. It generates a buffer
	 * ID using glGenBuffers, binds it as an element array buffer, and loads the given
	 * indices into the buffer. The data is stored in static draw mode for efficiency.
	 *
	 * @param indices 1D array of indices that will be stored in a buffer object on the
	 * GPU for use in rendering or other graphics operations.
	 */
	private static void storeIndices(int[] indices) {
		int ibo = GL15.glGenBuffers();
		GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, ibo);
		GL15.glBufferData(GL15.GL_ELEMENT_ARRAY_BUFFER, Util.createFlippedBuffer(indices), GL15.GL_STATIC_DRAW);
	}
	
	/**
	 * Binds a default value to the current VAO, effectively disabling it and allowing
	 * other VAOs or non-VAO objects to be used without interference. The specific default
	 * value bound is not specified, but it resets the VAO state to its initial configuration.
	 */
	private static void unbindVAO() {
		GL30.glBindVertexArray(0);
	}
}
