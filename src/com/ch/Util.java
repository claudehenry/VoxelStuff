package com.ch;

import java.util.List;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;

import org.lwjgl.BufferUtils;

/**
 * provides several methods for manipulating data arrays and buffers, including
 * creation of new buffers, flipping of buffers, and conversion of data types. It
 * also includes a method for removing empty strings from an array and converting
 * integers and floats to arrays. Additionally, there are some unimplemented methods
 * in the class, such as `createFlippedBuffer` and `loatMat4`, which appear to be
 * intended for working with matrices.
 */
public class Util {
	
 /**
  * creates a new `FloatBuffer` object with the specified size. The returned buffer
  * contains the specified number of float values.
  * 
  * @param size number of elements in the FloatBuffer that will be created and returned
  * by the function.
  * 
  * @returns a `FloatBuffer` object of the specified size.
  * 
  * The method returns an instance of `FloatBuffer`, which is a type-safe wrapper
  * around a native `FloatBuffer`.
  * The `FloatBuffer` object represents a contiguous block of memory that can be
  * accessed and manipulated using buffer-related methods.
  * The size of the returned `FloatBuffer` is specified by the parameter `size`, which
  * must be a non-negative integer.
  */
	public static FloatBuffer createFloatBuffer(int size) {
		return BufferUtils.createFloatBuffer(size);
	}

 /**
  * creates an `IntBuffer` object of a specified size, using the `BufferUtils` class
  * to perform the creation.
  * 
  * @param size number of elements to be stored in the IntBuffer created by the function.
  * 
  * @returns an `IntBuffer` object that represents a buffer of integers with the
  * specified size.
  * 
  * 	- The `IntBuffer` object is generated by BufferUtils, which implies that it has
  * been created using a specific mechanism.
  * 	- The size of the buffer is specified in the parameter `size`, indicating the
  * number of integers that can be stored in the buffer.
  * 	- The buffer is returned as an instance of the `IntBuffer` class, which represents
  * a contiguous block of integers.
  */
	public static IntBuffer createIntBuffer(int size) {
		return BufferUtils.createIntBuffer(size);
	}

 /**
  * creates a new byte buffer instance with the specified size. The returned buffer
  * is managed by the `BufferUtils` class and can be used for various operations on
  * the fly.
  * 
  * @param size initial capacity of the ByteBuffer to be created, which determines the
  * amount of memory allocated for storing data.
  * 
  * @returns a ByteBuffer object with the specified size.
  * 
  * The `ByteBuffer` object is created using the `BufferUtils` class.
  * It has an initial capacity of `size` bytes.
  * It can be resized dynamically by calling methods such as `rewind()`, `clear()`,
  * and `put()`.
  */
	public static ByteBuffer createByteBuffer(int size) {
		return BufferUtils.createByteBuffer(size);
	}

 /**
  * creates an `IntBuffer` from a provided array of integers, then flips it to create
  * a view of the original data in ascending order.
  * 
  * @returns an flipped IntBuffer containing the input values.
  * 
  * 	- The `IntBuffer` object returned by the function is flipped, meaning that it
  * contains the contents of the original array in reverse order.
  * 	- The buffer is a view of the original array, which means that it has the same
  * content as the array but is a separate entity with its own references.
  * 	- The buffer has a length property that indicates the number of elements it contains.
  * 	- The buffer can be accessed and manipulated using the `put` and `get` methods.
  */
	public static IntBuffer createFlippedBuffer(int... values) {
		IntBuffer buffer = createIntBuffer(values.length);
		buffer.put(values);
		buffer.flip();

		return buffer;
	}
	
 /**
  * creates a new `FloatBuffer` instance by copying a provided array of floating-point
  * values and flipping the order of the buffer. The resulting buffer is ready to be
  * accessed and manipulated using standard buffer operations.
  * 
  * @returns a flipped FloatBuffer containing the input values.
  * 
  * 	- The output is a `FloatBuffer`, which is an implementation of the `Buffer`
  * interface in Java.
  * 	- The buffer has a length equal to the number of input values passed to the function.
  * 	- The buffer contains the same sequence of floating-point numbers as the input
  * array, in the order specified by the input values.
  * 	- The buffer is flipped after being created, meaning that its position is incremented
  * to point to the next available location for writing.
  */
	public static FloatBuffer createFlippedBuffer(float... values) {
		FloatBuffer buffer = createFloatBuffer(values.length);
		buffer.put(values);
		buffer.flip();

		return buffer;
	}

	/*
	public static FloatBuffer createFlippedBuffer(Vertex[] vertices) {
		FloatBuffer buffer = createFloatBuffer(vertices.length * Vertex.SIZE);

		for (int i = 0; i < vertices.length; i++) {
			buffer.put(vertices[i].getPos().getX());
			buffer.put(vertices[i].getPos().getY());
			buffer.put(vertices[i].getPos().getZ());
			buffer.put(vertices[i].getTexCoord().getX());
			buffer.put(vertices[i].getTexCoord().getY());
			buffer.put(vertices[i].getNormal().getX());
			buffer.put(vertices[i].getNormal().getY());
			buffer.put(vertices[i].getNormal().getZ());
			buffer.put(vertices[i].getTangent().getX());
			buffer.put(vertices[i].getTangent().getY());
			buffer.put(vertices[i].getTangent().getZ());
		}

		buffer.flip();

		return buffer;
	}
	*/

	/*
	public static FloatBuffer createFlippedBuffer(Matrix4f value) {
		FloatBuffer buffer = createFloatBuffer(4 * 4);

		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++)
				buffer.put(value.get(i, j));

		buffer.flip();

		return buffer;
	}
	
	public static Matrix4f loatMat4(FloatBuffer vals) {
		
//		vals.flip();
		
		Matrix4f m = new Matrix4f();
		
		int index;
		for (index = 0; index < 16; index++)
			m.set(index % 4, index / 4, vals.get());
		
		return m;
	}
*/
 /**
  * removes empty strings from an array of strings and returns a new array with the
  * non-empty strings.
  * 
  * @param data an array of strings to be processed, which is transformed into an
  * ArrayList and then returned as a new array of strings.
  * 
  * The `data` array is an instance of `String[]`, indicating it is an array of strings.
  * 
  * The length of the `data` array is determined by a variable `i`, which ranges from
  * 0 to `data.length-1`. This suggests that `data` may contain multiple elements,
  * each represented by a string in the array.
  * 
  * Within each index of the array, the value is either an empty string or a non-empty
  * string, as determined by the comparison with the String literals `""`. If the value
  * is not empty, it is added to an `ArrayList` called `result`.
  * 
  * The `result` list is created and initialized using the `new ArrayList<String>()`
  * constructor.
  * 
  * Finally, the elements of the `result` list are copied into a new `String[]` array
  * using the `toArray(res)` method.
  * 
  * Overall, the function appears to remove all empty strings from an input `String[]`
  * array and return a new array with only non-empty strings.
  * 
  * @returns an array of non-empty strings.
  */
	public static String[] removeEmptyStrings(String[] data) {
		ArrayList<String> result = new ArrayList<String>();

		for (int i = 0; i < data.length; i++)
			if (!data[i].equals(""))
				result.add(data[i]);

		String[] res = new String[result.size()];
		result.toArray(res);

		return res;
	}

 /**
  * converts an `Integer` array to an `int` array with the same length, by simply
  * copying the values of the original array to the new array.
  * 
  * @param data 1D array of integers that is converted into a 1D integer array by the
  * function.
  * 
  * The input `data` is an array of integers.
  * It has a length property that indicates the number of elements in the array.
  * Each element in the array is accessed through its index, which ranges from 0 to
  * `data.length - 1`.
  * 
  * @returns an integer array with the same elements as the input `data` array.
  */
	public static int[] toIntArray(Integer[] data) {
		int[] result = new int[data.length];

		for (int i = 0; i < data.length; i++)
			result[i] = data[i];

		return result;
	}
	
 /**
  * takes a list of integers as input and returns an integer array with the same size
  * as the input list. The elements of the input list are copied into the corresponding
  * positions of the output array in a one-to-one manner.
  * 
  * @param data list of integers that will be converted to an integer array by the
  * `toIntArray()` method.
  * 
  * The input `data` is a list of integers, which means it is an ordered collection
  * of items that can be accessed by their index.
  * 
  * The `size()` method is used to retrieve the number of elements in the list.
  * 
  * The `get()` method is used to retrieve a specific element from the list based on
  * its index.
  * 
  * @returns an integer array with the same size as the input list of integers.
  */
	public static int[] toIntArray(List<Integer> data) {
		int[] result = new int[data.size()];

		for (int i = 0; i < data.size(); i++)
			result[i] = data.get(i);

		return result;
	}
	
 /**
  * takes a `Float[]` array as input and returns an equivalent `float[]` array with
  * the same elements.
  * 
  * @param data 0-based array of floating-point values that will be converted to a new
  * 0-based array of floating-point values.
  * 
  * 	- Length: The function takes an array of floating-point numbers `data`, which has
  * a length property that indicates the number of elements in the array.
  * 	- Element type: Each element in the `data` array is of type `Float`, indicating
  * that the function operates on individual floating-point values.
  * 	- Data integrity: The function assumes that the input `data` is well-formed and
  * does not contain any invalid or out-of-range values, which could result in unexpected
  * behavior if not properly handled.
  * 
  * @returns an array of floating-point values equivalent to the input `Float[]` array.
  */
	public static float[] toFloatArray(Float[] data) {
		float[] result = new float[data.length];

		for (int i = 0; i < data.length; i++)
			result[i] = data[i];

		return result;
	}
	
 /**
  * converts a `List<Float>` into an array of `float`. It loops through each element
  * in the list and assigns it to the corresponding position in the returned array.
  * 
  * @param data List<Float> of values that will be converted into an array of float values.
  * 
  * 	- `data` is an instance of `List`.
  * 	- The size of the list is accessed using the `size()` method.
  * 	- A new array of `float` type with the same size as the list is created using the
  * `new float[data.size()]` expression.
  * 	- The elements of the list are copied into the array using a for loop, with the
  * index of the element being accessed using the `i` variable.
  * 	- The value of each element is copied into the corresponding position in the new
  * array using the `result[i] = data.get(i)` expression.
  * 
  * @returns an array of size equal to the number of elements in the input list,
  * containing the corresponding float values.
  */
	public static float[] toFloatArray(List<Float> data) {
		float[] result = new float[data.size()];

		for (int i = 0; i < data.size(); i++)
			result[i] = data.get(i);

		return result;
	}
}
