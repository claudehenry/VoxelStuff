package com.ch.voxel;

import java.util.ArrayList;
import java.util.List;

import com.ch.Model;
import com.ch.SimplexNoise;
import com.ch.Util;
import com.ch.math.Matrix4f;

/**
 * in the provided code is responsible for generating a 3D model of a chunk from a
 * list of vertices, indices, and block data. It has several methods for generating
 * the model, including `genModel()` which creates the model and `gen` which generates
 * the vertices and indices for each type of block in the chunk. The `gen` method
 * takes in the list of vertices and indices as well as the current maximum index and
 * generates the vertices and indices for each type of block based on its properties
 * (e.g. float, back, top, bottom, etc.). It then returns the new maximum index.
 */
public class Chunk {

	public static final int CHUNK_SIZE = 64;
	private static final int CHUNK_SIZE_SQUARED = CHUNK_SIZE * CHUNK_SIZE;
	private static final int CHUNK_SIZE_CUBED = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE;

	private Block[] blocks;
	public int x, y, z;
	private Model model;
	
 /**
  * retrieves a `Model` instance and sets a flag to indicate that it has been generated.
  * If generation is required, it creates a new model and sets the flag to false before
  * returning the model.
  * 
  * @returns a `Model` object.
  * 
  * 	- `to_gen_model`: This variable indicates whether the model has been generated
  * or not. If it is `true`, then the model has been generated, and if it is `false`,
  * then the model has not been generated yet.
  * 	- `model`: This variable returns the model object that is generated by the function.
  * The properties of this object depend on how the function is implemented.
  */
	public Model getModel() {
		if (to_gen_model) {
			createModel();
			to_gen_model = false;
		}
		return model;
	}
	
 /**
  * calculates a transformation matrix that translates a 3D model by a certain distance
  * along the x, y, and z axes. The returned matrix is an instance of the `Matrix4f`
  * class.
  * 
  * @returns a 4x4 matrix representing a translation of a specific distance in each dimension.
  * 
  * The `getModelMatrix` function returns a `Matrix4f` object representing the
  * transformation matrix for rendering a 3D model in the scene. The matrix is initialized
  * with a translation vector consisting of three components: `x`, `y`, and `z`, which
  * represent the position of the model in the world space.
  * 
  * The returned matrix has the following properties:
  * 
  * 	- The columns represent the homogeneous coordinates of the transformation, where
  * the first column represents the 3D position of the model, the second column
  * represents the scale of the model, and the third column represents the rotation
  * of the model around the origin.
  * 	- The rows represent the inverse of the transformation matrix, which is used to
  * transform the world space coordinates of a point or vector back to its original
  * position in the scene.
  * 	- The determinant of the matrix is 1, indicating that the transformation is
  * non-singular and can be inverted.
  * 
  * Overall, the `getModelMatrix` function returns a matrix representation of the
  * rendering transformation for a 3D model in the scene, which can be used to perform
  * various operations such as translating, scaling, and rotating the model during rendering.
  */
	public Matrix4f getModelMatrix() {
		return new Matrix4f().initTranslation(x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE);
	}

	public Chunk(int _x, int _y, int _z) {
		
		this.x = _x;
		this.y = _y;
		this.z = _z;
		
		blocks = new Block[CHUNK_SIZE_CUBED];
		
		for (int i = 0; i < CHUNK_SIZE_CUBED; i++) {
			int z = i / CHUNK_SIZE_SQUARED;
			int ii = i - (z * CHUNK_SIZE_SQUARED);
			int y = ii / CHUNK_SIZE;
			int x = ii % CHUNK_SIZE;
			if (SimplexNoise.noise((x + this.x * CHUNK_SIZE) / 10f, (y + this.y * CHUNK_SIZE) / 10f, (z + this.z * CHUNK_SIZE) / 10f) > 0.1f) {
			blocks[i] = new Block(x, y, z);
			}
		}
	}
	
	

 /**
  * updates the linked list of blocks in a 3D grid by traversing through the chunks
  * and checking for neighbors, setting the `lt`, `bt`, `ft`, `rt`, `tp`, and `bk`
  * fields accordingly.
  */
	public void updateBlocks() {
		for (int i = 0; i < CHUNK_SIZE_CUBED; i++) {
			Block b = blocks[i];
				if (b != null) {
				int n_x = i - 1;
				int p_x = i + 1;
				int n_y = i - CHUNK_SIZE;
				int p_y = i + CHUNK_SIZE;
				int n_z = i - CHUNK_SIZE_SQUARED;
				int p_z = i + CHUNK_SIZE_SQUARED;
				
				if (b.x - 1 < 0) {
					//TODO: check neighbor chunk
					b.lt = false;
				} else {
					Block bl = blocks[n_x];
					if (bl == null)
						b.lt = true;
					else
						b.lt = false;
				}
				if (b.y - 1 < 0) {
					//TODO: check neighbor chunk
					b.bt = false;
				} else {
					Block bl = blocks[n_y];
					if (bl == null)
						b.bt = true;
					else
						b.bt = false;
				}
				if (b.z - 1 < 0) {
					//TODO: check neighbor chunk
					b.ft = false;
				} else {
					Block bl = blocks[n_z];
					if (bl == null)
						b.ft = true;
					else
						b.ft = false;
				}
				
				if (b.x + 1 >= CHUNK_SIZE) {
					//TODO: check neighbor chunk
					b.rt = false;
				} else {
					Block bl = blocks[p_x];
					if (bl == null)
						b.rt = true;
					else
						b.rt = false;
				}
				if (b.y + 1 >= CHUNK_SIZE) {
					//TODO: check neighbor chunk
					b.tp = false;
				} else {
					Block bl = blocks[p_y];
					if (bl == null)
						b.tp = true;
					else
						b.tp = false;
				}
				if (b.z + 1 >= CHUNK_SIZE) {
					//TODO: check neighbor chunk
					b.bk = false;
				} else {
					Block bl = blocks[p_z];
					if (bl == null)
						b.bk = true;
					else
						b.bk = false;
				}
			}
		}
	}
	
//	class Vertex3i {
//		
//		public int x, y, z; 
//		public float u, v;
//		
//		public Vertex3i(x, y, z, u, v) {
//			
//		}
//		
//	}
	
	private ArrayList<Float> vertices = new ArrayList<>();
	private ArrayList<Integer> indices = new ArrayList<>();
	private boolean to_gen_model;
	
	
 /**
  * sets a model object's state to that of a generated model, based on a provided
  * parameter indicating whether the generation should be done from scratch or from
  * an existing model.
  */
	public void toGenModel() { toGenModel(false); };
	
 /**
  * generates a model from a set of vertices, indices, and blocks, and stores it in
  * the `Model` class. It also maintains a flag for whether to generate the model or
  * not.
  * 
  * @param now boolean value of whether to generate a new model or not, and it determines
  * whether the function will create a new model or just set the `to_gen_model` variable
  * to true or false.
  */
	public void toGenModel(boolean now) {

		int max_index = 0;
//		System.out.println("gen model");
		for (int i = 0; i < CHUNK_SIZE_CUBED; i++) {
			Block b = blocks[i];
			if (b != null) {
				max_index = gen(vertices, indices, b, max_index);
					
			}
		}
//		System.out.println("vertice   : " + vertices.size() / 5 + " -- floats : " + vertices.size());
//		System.out.println("indices   : " + indices.size());
//		System.out.println("triangles : " + indices.size() / 3);
//		System.out.println("quads     : " + indices.size() / 6);
//		System.out.println("---------------------------\nloading model arrays");
		
		// cant implement filtering and re-indexing for textured cubes
//		{
//			
//			ArrayList<Integer>
//			
//		}
		
//		return Model.load(Util.toFloatArray(new_vertices), Util.toIntArray(new_indices));
		
		if (now) {
			createModel();
			to_gen_model = false;
		} else {
			to_gen_model = true;
		}
		
	}
	
 /**
  * loads a 3D model from a buffer and stores it in a `Model` object, which can be
  * used for rendering or other applications.
  */
	private void createModel() {
		this.model = Model.load(Util.toFloatArray(vertices), Util.toIntArray(indices));
	}
	
 /**
  * generates a model based on input parameters and stores it in the `model` variable.
  * 
  * @returns a `Model` object containing the generated model data.
  * 
  * The `genModel` function returns a `Model` object, which is an instance of a class
  * that represents a model in the program. The `Model` class has various attributes
  * and methods that allow for the manipulation and analysis of the model. These may
  * include information such as the model's structure, parameters, and performance metrics.
  * 
  * The return value of `genModel` indicates the successful creation of a new model
  * instance, which can be used for further processing or analysis in the program.
  */
	public Model genModel() {
		
		toGenModel(true);
		
		return this.model;
	}

 /**
  * generates vertices and indices for a 3D mesh based on a given block layout,
  * incrementing a maximum index variable. It adds vertices and indices in different
  * cases of block properties (ft, bk, bt, tp, lt, rt).
  * 
  * @param vertices 2D vertices of a 3D object, which are added to an array as the
  * block's geometry is generated.
  * 
  * 	- `List<Float>` - The type of the `vertices` list, which contains floating-point
  * numbers representing 3D vertices in a mesh.
  * 	- `indices`: A `List<Integer>` containing indices of the vertices in the mesh.
  * Each index corresponds to a vertex in the `vertices` list.
  * 	- `block`: An instance of an unknown class `Block`, which contains properties
  * that determine how the vertices are generated based on its type.
  * 	- `max_index`: An integer variable used to keep track of the highest index assigned
  * to a vertex or an edge, which is incremented for each block type.
  * 
  * The `gen` function performs different operations based on the type of the `block`
  * instance, such as adding vertices and indices to the `vertices` and `indices`
  * lists, respectively. The generated vertices are floats values representing 3D
  * points, while the indices are integers representing the order of the vertices in
  * the mesh.
  * 
  * @param indices 4-element array that stores the indices of the vertices in the mesh,
  * which are used to identify and update the corresponding vertices in the `vertices`
  * list.
  * 
  * 	- The `indices` array is an instance of the `java.util.ArrayList` class and has
  * a fixed size based on the number of vertices in the block.
  * 	- The elements of the `indices` array represent the indices of the vertices in
  * the block, where each index is an integer between 0 and the total number of vertices
  * - 1.
  * 	- Each element of the `indices` array corresponds to a vertex in the block, with
  * the first vertex having index 0 and the last vertex having index equal to the total
  * number of vertices minus 1.
  * 	- The `indices` array is immutable and cannot be modified after creation.
  * 
  * In summary, the `indices` array is an immutable list of integers that represent
  * the indices of vertices in a 3D block.
  * 
  * @param block 3D block being generated, and its values determine which specific
  * geometry is added to the vertices and indices lists.
  * 
  * 	- `x`, `y`, and `z`: coordinates of the block's position in 3D space.
  * 	- `ft`, `bk`, `bt`, `tp`, and `lt`: boolean flags indicating whether each face
  * of the block has a specific attribute (not yet specified).
  * 	- `indices`: an array of integers representing the indices of the vertices in the
  * block's mesh.
  * 	- `max_index`: an integer representing the total number of vertices in the block's
  * mesh, which is updated incrementally as new vertices are added.
  * 
  * @param max_index 0-based index of the current block in the mesh, and is incremented
  * after each iteration to keep track of the number of vertices and indices generated
  * for each block.
  * 
  * @returns an integer representing the maximum index added to the `indices` list.
  * 
  * 	- `max_index`: This is an integer variable that keeps track of the maximum index
  * used so far in the generation of vertices and indices. It is incremented for each
  * block processed.
  * 	- `vertices`: This is a list of floating-point values that represent the vertices
  * of the generated mesh. Each vertex is stored as a separate element in the list.
  * 	- `indices`: This is a list of integers that represent the indices of the vertices
  * in the mesh. The length of this list is equal to the number of vertices in the
  * mesh, and each integer index corresponds to a particular vertex in the mesh.
  * 
  * The `gen` function processes different types of blocks (i.e., `block.ft`, `block.bk`,
  * `block.bt`, `block.tp`, and `block.lt`) and generates corresponding vertices and
  * indices for each block type. The generated vertices are stored in the `vertices`
  * list, and the indices are stored in the `indices` list. The `max_index` variable
  * is used to keep track of the maximum index used so far in the generation process.
  */
	private static int gen(List<Float> vertices, List<Integer> indices, Block block, int max_index) {
		
		float x = block.x;
		float y = block.y;
		float z = block.z;
		
		if (block.ft) {
			float[] tmp_v = { //
				x,   y,   z,   0, 0, //
				x+1, y,   z,   1, 0, //
				x+1, y+1, z,   1, 1, //
				x,   y+1, z,   0, 1, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.bk) {
			float[] tmp_v = { //
				x,   y,   z+1,   1, 0, //
				x+1, y,   z+1,   0, 0, //
				x+1, y+1, z+1,   0, 1, //
				x,   y+1, z+1,   1, 1, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.bt) {
			float[] tmp_v = { //
				x,   y,   z,     0, 0, //
				x+1, y,   z,   	 1, 0, //
				x+1, y,   z+1,   1, 1, //
				x,   y,   z+1,   0, 1, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.tp) {
			float[] tmp_v = { //
				x,   y+1, z,     0, 0, //
				x+1, y+1, z,     1, 0, //
				x+1, y+1, z+1,   1, 1, //
				x,   y+1, z+1,   0, 1, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.lt) {
			float[] tmp_v = { //
				x,   y,   z,     1, 0, //
				x,   y+1, z,     1, 1, //
				x,   y+1, z+1,   0, 1, //
				x,   y,   z+1,   0, 0, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.rt) {
			float[] tmp_v = { //
				x+1, y,   z,     0, 0, //
				x+1, y+1, z,     0, 1, //
				x+1, y+1, z+1,   1, 1, //
				x+1, y,   z+1,   1, 0, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);
			max_index += 4;
		}
		return max_index;
	}

}
