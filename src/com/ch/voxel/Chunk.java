package com.ch.voxel;

import java.util.ArrayList;
import java.util.List;

import com.ch.Model;
import com.ch.SimplexNoise;
import com.ch.Util;
import com.ch.math.Matrix4f;

/**
 * TODO
 */
public class Chunk {

	public static final int CHUNK_SIZE = 64;
	private static final int CHUNK_SIZE_SQUARED = CHUNK_SIZE * CHUNK_SIZE;
	private static final int CHUNK_SIZE_CUBED = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE;

	private Block[] blocks;
	public int x, y, z;
	private Model model;
	
 /**
  * retrieves a `Model` object from a storage location and returns it to the caller.
  * If the `to_gen_model` flag is set, the function creates a new model instance instead
  * of returning an existing one.
  * 
  * @returns a `Model` object.
  * 
  * The `model` variable is an instance of the `Model` class, which represents a
  * mathematical model. The model can be manipulated and used for various purposes,
  * such as solving optimization problems or performing statistical analysis.
  * 
  * The `to_gen_model` field indicates whether the model was generated by the function
  * or not. If `to_gen_model` is `true`, then the model was generated by the function,
  * and if it is `false`, then the model was already available before calling the function.
  * 
  * No other properties or attributes of the returned output are mentioned in the code
  * snippet provided.
  */
	public Model getModel() {
		if (to_gen_model) {
			createModel();
			to_gen_model = false;
		}
		return model;
	}
	
 /**
  * computes and returns a transformation matrix representing the position and scale
  * of an object in 3D space.
  * 
  * @returns a transformation matrix representing a translation of a certain magnitude
  * in the x, y, and z directions.
  * 
  * 1/ The matrix is a `Matrix4f` object representing a 4D transformation matrix.
  * 2/ The matrix is initialized with a translation vector consisting of three components
  * (x, y, and z) multiplied by the chunk size (CHUNK_SIZE).
  * 3/ The resulting matrix represents a translation of the origin of the coordinate
  * system by the specified amount in each dimension.
  */
	public Matrix4f getModelMatrix() {
		return new Matrix4f().initTranslation(x * CHUNK_SIZE, y * CHUNK_SIZE, z * CHUNK_SIZE);
	}

	public Chunk(int _x, int _y, int _z) {
		
		this.x = _x;
		this.y = _y;
		this.z = _z;
		
		blocks = new Block[CHUNK_SIZE_CUBED];
		
		for (int i = 0; i < CHUNK_SIZE_CUBED; i++) {
			int z = i / CHUNK_SIZE_SQUARED;
			int ii = i - (z * CHUNK_SIZE_SQUARED);
			int y = ii / CHUNK_SIZE;
			int x = ii % CHUNK_SIZE;
			if (SimplexNoise.noise((x + this.x * CHUNK_SIZE) / 10f, (y + this.y * CHUNK_SIZE) / 10f, (z + this.z * CHUNK_SIZE) / 10f) > 0.1f) {
			blocks[i] = new Block(x, y, z);
			}
		}
	}
	
	

 /**
  * updates the blocks in a 3D grid by checking and updating their neighbors based on
  * chunk size. It also checks for boundary conditions and sets appropriate flags.
  */
	public void updateBlocks() {
		for (int i = 0; i < CHUNK_SIZE_CUBED; i++) {
			Block b = blocks[i];
				if (b != null) {
				int n_x = i - 1;
				int p_x = i + 1;
				int n_y = i - CHUNK_SIZE;
				int p_y = i + CHUNK_SIZE;
				int n_z = i - CHUNK_SIZE_SQUARED;
				int p_z = i + CHUNK_SIZE_SQUARED;
				
				if (b.x - 1 < 0) {
					//TODO: check neighbor chunk
					b.lt = false;
				} else {
					Block bl = blocks[n_x];
					if (bl == null)
						b.lt = true;
					else
						b.lt = false;
				}
				if (b.y - 1 < 0) {
					//TODO: check neighbor chunk
					b.bt = false;
				} else {
					Block bl = blocks[n_y];
					if (bl == null)
						b.bt = true;
					else
						b.bt = false;
				}
				if (b.z - 1 < 0) {
					//TODO: check neighbor chunk
					b.ft = false;
				} else {
					Block bl = blocks[n_z];
					if (bl == null)
						b.ft = true;
					else
						b.ft = false;
				}
				
				if (b.x + 1 >= CHUNK_SIZE) {
					//TODO: check neighbor chunk
					b.rt = false;
				} else {
					Block bl = blocks[p_x];
					if (bl == null)
						b.rt = true;
					else
						b.rt = false;
				}
				if (b.y + 1 >= CHUNK_SIZE) {
					//TODO: check neighbor chunk
					b.tp = false;
				} else {
					Block bl = blocks[p_y];
					if (bl == null)
						b.tp = true;
					else
						b.tp = false;
				}
				if (b.z + 1 >= CHUNK_SIZE) {
					//TODO: check neighbor chunk
					b.bk = false;
				} else {
					Block bl = blocks[p_z];
					if (bl == null)
						b.bk = true;
					else
						b.bk = false;
				}
			}
		}
	}
	
//	class Vertex3i {
//		
//		public int x, y, z; 
//		public float u, v;
//		
//		public Vertex3i(x, y, z, u, v) {
//			
//		}
//		
//	}
	
	private ArrayList<Float> vertices = new ArrayList<>();
	private ArrayList<Integer> indices = new ArrayList<>();
	private boolean to_gen_model;
	
	
 /**
  * transforms a given model into a Generated Model, which can be used for further
  * processing or analysis.
  */
	public void toGenModel() { toGenModel(false); };
	
 /**
  * generates a 3D model by recursively dividing a large chunk of vertices and indices
  * into smaller chunks, processes them, and repeats the process until the desired
  * level of detail is reached. It also filters out unnecessary data and re-indexes
  * the remaining vertices and indices for efficient storage and access.
  * 
  * @param now boolean value that determines whether to generate a new model or not.
  */
	public void toGenModel(boolean now) {

		int max_index = 0;
//		System.out.println("gen model");
		for (int i = 0; i < CHUNK_SIZE_CUBED; i++) {
			Block b = blocks[i];
			if (b != null) {
				max_index = gen(vertices, indices, b, max_index);
					
			}
		}
//		System.out.println("vertice   : " + vertices.size() / 5 + " -- floats : " + vertices.size());
//		System.out.println("indices   : " + indices.size());
//		System.out.println("triangles : " + indices.size() / 3);
//		System.out.println("quads     : " + indices.size() / 6);
//		System.out.println("---------------------------\nloading model arrays");
		
		// cant implement filtering and re-indexing for textured cubes
//		{
//			
//			ArrayList<Integer>
//			
//		}
		
//		return Model.load(Util.toFloatArray(new_vertices), Util.toIntArray(new_indices));
		
		if (now) {
			createModel();
			to_gen_model = false;
		} else {
			to_gen_model = true;
		}
		
	}
	
 /**
  * loads a 3D model from a file into a `Model` object, using the provided vertices
  * and indices as input.
  */
	private void createModel() {
		this.model = Model.load(Util.toFloatArray(vertices), Util.toIntArray(indices));
	}
	
 /**
  * generates a model based on input `toGenModel`. It returns the generated model.
  * 
  * @returns a `Model` object representing the generated model.
  * 
  * 	- `model`: A `Model` object representing the generated model.
  * 	- `toGenModel(true)`: A method called to initialize the model generation process
  * with the given parameter.
  * 
  * These details provide a brief understanding of the inner workings of the `genModel`
  * function, without including any unnecessary information or summaries.
  */
	public Model genModel() {
		
		toGenModel(true);
		
		return this.model;
	}

 /**
  * generates new vertices and indices for a 3D mesh based on the given block's topology.
  * It recursively calls itself for each face of the block, adding vertices and indices
  * to the mesh. The function returns the total number of indices added.
  * 
  * @param vertices 2D coordinates of the vertices that make up the block, which are
  * added to an array for later use in rendering the 3D model.
  * 
  * 	- `vertices`: A list of floating-point values representing 3D vertices in the mesh.
  * 	- `indices`: A list of integer values representing the indices of the vertices
  * in the mesh.
  * 	- `block`: An instance of a `Block` class, which contains information about the
  * current block being generated. The properties of the block include `x`, `y`, `z`,
  * `ft`, `bk`, `bt`, `tp`, and `lt`. These properties determine the type of geometry
  * that is generated for each vertex in the mesh.
  * 	- `max_index`: An integer variable that keeps track of the total number of vertices
  * generated so far. It is updated incrementally as new vertices are generated for
  * each block.
  * 
  * @param indices 4-element integer array that stores the indices of the vertices in
  * the mesh, which are added to the `vertices` list and used to calculate the next
  * index value for the `max_index` variable.
  * 
  * 	- `new int[] {0, 1, 2, 0, 2, 3}`: This is an array of integers containing the
  * starting indices for each of the four blocks.
  * 	- `indices.add(max_index + i)`: For each element in the `indices` array, a new
  * index is added to the list, where the index is the sum of the current maximum index
  * and the corresponding starting index from the `new int[]`.
  * 	- `return max_index`: The function returns the maximum index generated after
  * deserializing the input `indices`.
  * 
  * @param block 3D block of the scene being generated, and its values determine which
  * triangles are added to the list of vertices and indices.
  * 
  * 	- `x`, `y`, and `z`: These are the coordinates of the block's position in 3D space.
  * 	- `ft`, `bk`, `bt`, `tp`, and `lt`: These are boolean values indicating whether
  * each face of the block has a specific property (e.g., floating or non-floating).
  * 	- `indices`: An array of integers that corresponds to the vertices of the block.
  * 	- `max_index`: A variable that keeps track of the total number of vertices and
  * indices generated so far.
  * 
  * @param max_index index of the last vertex or index that has been processed and
  * added to the `vertices` and `indices` lists, respectively, before returning the
  * value at the end of the function.
  * 
  * @returns an integer representing the maximum index added to the `indices` list.
  * 
  * 	- The `max_index` variable is used to keep track of the index of the current
  * vertex or index in the `indices` list. It starts from 0 and increases by 4 for
  * each block generated.
  * 	- The `vertices` list stores the coordinates of the vertices in the block. Each
  * time a new block is generated, a new set of vertices is added to the list.
  * 	- The `indices` list stores the indices of the vertices in the block. Each time
  * a new block is generated, a new set of indices is added to the list, starting from
  * 0.
  * 	- The function takes into account the `ft`, `bk`, `bt`, `tp`, and `lt` properties
  * of the current block being generated. Depending on these properties, different
  * sets of vertices are added to the `vertices` list, and different indices are added
  * to the `indices` list.
  * 	- The function returns the maximum index of the `indices` list after all blocks
  * have been generated.
  */
	private static int gen(List<Float> vertices, List<Integer> indices, Block block, int max_index) {
		
		float x = block.x;
		float y = block.y;
		float z = block.z;
		
		if (block.ft) {
			float[] tmp_v = { //
				x,   y,   z,   0, 0, //
				x+1, y,   z,   1, 0, //
				x+1, y+1, z,   1, 1, //
				x,   y+1, z,   0, 1, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.bk) {
			float[] tmp_v = { //
				x,   y,   z+1,   1, 0, //
				x+1, y,   z+1,   0, 0, //
				x+1, y+1, z+1,   0, 1, //
				x,   y+1, z+1,   1, 1, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.bt) {
			float[] tmp_v = { //
				x,   y,   z,     0, 0, //
				x+1, y,   z,   	 1, 0, //
				x+1, y,   z+1,   1, 1, //
				x,   y,   z+1,   0, 1, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.tp) {
			float[] tmp_v = { //
				x,   y+1, z,     0, 0, //
				x+1, y+1, z,     1, 0, //
				x+1, y+1, z+1,   1, 1, //
				x,   y+1, z+1,   0, 1, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.lt) {
			float[] tmp_v = { //
				x,   y,   z,     1, 0, //
				x,   y+1, z,     1, 1, //
				x,   y+1, z+1,   0, 1, //
				x,   y,   z+1,   0, 0, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);
			max_index += 4;
		}
		if (block.rt) {
			float[] tmp_v = { //
				x+1, y,   z,     0, 0, //
				x+1, y+1, z,     0, 1, //
				x+1, y+1, z+1,   1, 1, //
				x+1, y,   z+1,   1, 0, //
			}; //
			for (float f : tmp_v) vertices.add(f);
			for (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);
			max_index += 4;
		}
		return max_index;
	}

}
